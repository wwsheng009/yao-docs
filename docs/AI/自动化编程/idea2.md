好，那我们直接上 **可落地的工程级方案** ——
不是理念，而是你可以放进项目里用的那种。

下面是完整的：

> 🧩 **《AI 自动编程安全工作流模板（工程版）》**

这套东西的目标只有一个：

> **把“AI 写代码”变成“AI 按工程规范执行变更”**

---

# 🏗️ 一、整体思想：把 AI 关进“工程笼子”

AI 不应该直接面对代码，而应该在这个流程里工作：

```
任务系统  →  架构规则  →  项目索引  →  AI 执行单步变更  →  自动校验
```

而不是：

```
人类一句话  →  AI 直接改代码（❌灾难）
```

---

# 📐 二、必须准备的 4 个“AI 基础设施”

这是让 AI 能“像工程师一样工作”的前提。

---

## ① `ARCHITECTURE.md`（AI 的宪法）

作用：**防止 AI 乱设计**

内容必须包括：

```
# 系统架构规则

## 分层
- ui → service → domain → infra
- 禁止跨层调用

## 模块边界
- account 模块只处理账户
- auth 模块不能访问 db 以外资源

## 依赖原则
- domain 层禁止依赖 ui
- 所有外部系统调用必须走 adapter

## 扩展方式
- 新功能优先用 adapter / plugin
- 禁止修改核心模块 public API
```

👉 AI 每次工作都必须先读取它

---

## ② `AI_TASKS.md`（外部记忆系统）

你说的 todo list，其实是 AI 的“工作内存”。

示例：

```
# 当前任务

## TASK-017 插件系统改造

[ ] 1. 创建 plugin 接口定义
[ ] 2. 修改 main 初始化逻辑支持注册
[ ] 3. 把 moduleA 改为 plugin 实现
[ ] 4. 保留旧逻辑（不要删除）
[ ] 5. 添加测试入口

规则：
- 每次只做一个 checkbox
- 完成后更新状态
```

👉 这可以防止 AI 对话漂移

---

## ③ `PROJECT_INDEX.md`（项目语义索引）

这是解决你说的“AI 不知道已有实现”的核心武器。

```
# 项目能力索引

## 日志
- pkg/log/logger.go → 全局日志入口

## HTTP
- pkg/http/client.go → 标准 HTTP 客户端

## 配置
- pkg/config → 配置加载系统

## DB
- infra/db/mysql.go → MySQL 连接封装
```

AI 在写代码前必须查这里，而不是“猜”。

---

## ④ `AI_RULES.md`（行为限制）

这是“防 AI 发疯”的东西：

```
# AI 编程行为规则

1. 不允许直接删除旧代码
2. 不允许跨文件大规模重构
3. 不允许改 public interface
4. 优先新增文件，而不是改老文件
5. 所有修改必须说明影响范围
```

这能把 AI 的破坏性降 80%

---

# ⚙️ 三、标准 AI 编程执行流程（核心）

以后每个任务都按这个流程走：

---

## 🔹 STEP 0 — AI 不准写代码

必须先做信息收集：

```
1. 列出相关目录结构
2. 打开目标文件完整内容
3. 搜索是否已有类似实现
4. 找出依赖调用链
```

👉 这一阶段 **禁止生成代码**

---

## 🔹 STEP 1 — AI 先做“变更设计”

AI 只能输出：

```
变更计划：
- 新增文件：xxx.go
- 修改文件：main.go
- 不影响模块：auth、db

风险评估：
- 只新增，不删除
- 无接口变更
```

你确认后，才进入下一步。

---

## 🔹 STEP 2 — 单文件变更

规则：

- 一次只改一个文件
- 必须给出 diff 级说明
- 禁止“顺便优化”

---

## 🔹 STEP 3 — 自动检查

结合：

- 单元测试
- linter
- 编译检查

AI 改代码 → 机器验证，而不是靠对话

---

# 🧠 四、AI 适配的架构设计（关键）

为了让 AI 能安全工作，架构要做调整：

| 传统写法 | AI 友好写法    |
| -------- | -------------- |
| 深层耦合 | 接口隔离       |
| 逻辑嵌套 | 组合 + adapter |
| 改老模块 | 新模块包装     |
| 巨型文件 | 小文件单职责   |

---

## ⭐ 黄金原则

> **宁可增加层，不让 AI 改核心层**

这就是 AI 时代的架构哲学变化。

---

# 🚨 五、哪些任务绝对不要让 AI 做

| 类型           | 原因              |
| -------------- | ----------------- |
| 大规模重构     | 上下文爆炸        |
| 改核心数据结构 | 连锁反应          |
| 改接口签名     | 影响不可见        |
| 删除旧代码     | AI 不知道历史依赖 |

---

# 🎯 六、最终你会得到什么效果？

如果按这套来：

| 方式               | 结果                  |
| ------------------ | --------------------- |
| 直接对话式写代码   | 频繁崩溃              |
| 受控流程式 AI 编程 | 稳定可控              |
| 无任务拆解         | AI 漫游               |
| 原子任务           | AI 像“实习生”可控执行 |

---

# 🧨 一句本质总结

> **你不是在“用 AI 写代码”**
> **你是在设计一个“可被 AI 操作的软件工程系统”**

这就是从“AI 工具使用者”到“AI 工程架构师”的跃迁。

---

如果你下一步想深入，我可以带你做一个更高级的东西：

> 🔥 **“AI 代码变更防崩溃机制（自动检测 AI 破坏）”**

这个是生产级 AI 编程系统才会做的东西。
