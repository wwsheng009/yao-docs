# Plan 组件 - 精简版

## 概述

Plan 是一个灵活的任务编排系统，提供共享状态管理和信号控制功能，支持 JS 和 Go 双接口。

## 核心特性

- **任务编排**: 支持顺序执行和并行执行
- **共享状态**: 线程安全的数据共享机制
- **生命周期控制**: 暂停/恢复/停止任务
- **信号通信**: 基于信号的任务间通信
- **事件驱动**: 内置事件订阅和通知机制

## 执行模型

### Order 机制

Plan 使用 Order 来控制任务执行顺序：

```
Order 0: [Task A, Task B, Task C]  ← 并行执行
         ↓ WaitGroup.Wait()
Order 1: [Task D, Task E]         ← 并行执行
         ↓ WaitGroup.Wait()
Order 2: [Task F]                 ← 单个执行
```

**关键特性:**

- **同Order内**: 任务并行执行
- **跨Order间**: 严格串行执行，后Order等待前Order完成

## 共享状态管理

### 核心接口

```go
type SharedSpace interface {
    Set(key string, value interface{}) error
    Get(key string) (interface{}, error)
    Delete(key string) error
    Subscribe(key string, callback func(key string, value interface{})) error
    // ...
}
```

### 数据可见性

| 场景                | 数据可见性 | 可靠性 | 使用建议     |
| ------------------- | ---------- | ------ | ------------ |
| **同Order并行Task** | 实时可见   | 中等   | 需要同步机制 |
| **跨Order串行Task** | 保证可见   | 高     | 推荐模式     |

### 使用决策树

```
需要Task间通信吗？
    ↓ No → 使用其他方式（消息队列、数据库）
    ↓ Yes
有明确依赖关系吗？
    ├── Yes → 跨Order流水线 ⭐推荐
    └── No
        需要实时协作吗？
        ├── Yes → 同Order+同步机制 ⚠️复杂
        └── No → 避免共享空间
```

## 实际应用场景

### 1. ETL数据处理流水线（推荐）

```javascript
function ETLPipeline() {
  const plan = new Plan('etl-pipeline');

  // Order 1: 并行数据提取
  plan.Add('extract-users', 1, extractUsers, 'db1');
  plan.Add('extract-orders', 1, extractOrders, 'db2');

  // Order 2: 串行数据转换（依赖Order 1）
  plan.Add('transform-data', 2, transformData, plan);

  // Order 3: 并行数据加载（依赖Order 2）
  plan.Add('load-users', 3, loadUsers, plan);
  plan.Add('load-orders', 3, loadOrders, plan);

  return plan;
}
```

### 2. 实时协作处理（谨慎使用）

```javascript
function RealtimeCollaboration() {
  const plan = new Plan('realtime-collab');

  // 同Order内需要同步机制
  plan.Add('data-producer', 1, dataProducer, plan);
  plan.Add('data-consumer', 1, dataConsumer, plan);

  return plan;
}

// 需要同步等待机制
function dataConsumer(planId, taskId, plan) {
  // 等待生产者数据
  let dataReady = false;
  while (!dataReady) {
    try {
      const data = plan.Get('produced_data');
      if (data) {
        dataReady = true;
        return processData(data);
      }
    } catch (e) {
      // 数据还未准备好
    }
    time.Sleep(50);
  }
}
```

### 3. 配置和状态共享

```javascript
function ConfigSharing() {
  const plan = new Plan('config-sharing');

  // Order 1: 初始化配置
  plan.Add('init-config', 1, initConfig, plan);

  // Order 2: 并行工作器使用配置
  plan.Add('worker-1', 2, workerTask, 'worker1', plan);
  plan.Add('worker-2', 2, workerTask, 'worker2', plan);

  return plan;
}
```

## 关键限制和注意事项

### 1. 同Order竞态条件

```javascript
// ❌ 错误：同Order内的强依赖
plan.Add('task-a', 1, taskA, plan); // 设置数据
plan.Add('task-b', 1, taskB, plan); // 依赖taskA，但执行顺序不确定

// ✅ 正确：使用不同Order
plan.Add('task-a', 1, taskA, plan); // Order 1
plan.Add('task-b', 2, taskB, plan); // Order 2，确保taskA先完成
```

### 2. 性能限制

- **内存限制**: 数据存储在内存中
- **锁竞争**: 高并发时可能出现读写锁竞争
- **同步执行**: 订阅者回调同步执行，可能阻塞

### 3. 最佳实践

- **优先跨Order流水线**: 简单可靠
- **结构化数据**: 避免过于分散的键值对
- **及时清理**: 避免内存泄漏
- **容错设计**: 处理数据不存在的情况

## API 参考

### 创建Plan

```javascript
const plan = new Plan(planId);
```

### 任务管理

```javascript
plan.Add(taskId, order, process, ...args); // 添加任务
plan.Run(); // 执行计划
plan.Release(); // 释放资源
```

### 共享空间操作

```javascript
plan.Set(key, value); // 设置值
plan.Get(key); // 获取值
plan.Delete(key); // 删除值
plan.Subscribe(key, handler); // 订阅变化
```

## 总结

Plan组件通过Order机制和共享空间，提供了灵活的任务编排能力：

1. **跨Order流水线** - 最推荐，简单可靠
2. **同Order协作** - 需要同步机制，复杂但功能强大
3. **避免共享空间** - 独立任务的最佳选择

正确选择使用模式是构建高效可靠任务编排系统的关键。
