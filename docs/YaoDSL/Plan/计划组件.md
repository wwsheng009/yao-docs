# 计划组件

js Plan 对象 提供了灵活的任务编排系统，具有共享状态管理和信号控制功能。

Plan对象提供了Js接口与GO lang接口。

## 特性

- 任务排序和并行执行，同一个order的任务会并行执行。
- 任务间共享状态管理
- 任务生命周期控制（暂停/恢复/停止）
- 基于信号的任务通信
- 可配置的状态检查间隔
- 线程安全操作
- 资源清理管理

## 核心概念

### Plan

Plan 是一个具有共享状态空间的任务集合。它管理任务的执行顺序和生命周期。

### Task

Task 是一个工作单元，具有以下特性：

- 可以访问共享状态
- 可以响应控制信号
- 可以与同一顺序的其他任务并行执行
- 可以报告其状态并存储任务特定数据

### 共享空间

共享空间提供了一个线程安全的存储机制，用于任务之间共享数据和通信。

## 执行逻辑与机制

### Plan 执行流程图

```
┌─────────────────┐
│   Plan.Start()  │
└─────────┬───────┘
          │
          ▼
┌─────────────────┐
│  Status = Run   │
└─────────┬───────┘
          │
          ▼
┌─────────────────┐
│ Find Max Order  │
│ from Tasks      │
└─────────┬───────┘
          │
          ▼
┌─────────────────┐
│   Order = 0     │◄────────────────┐
└─────────┬───────┘                 │
          │                         │
          ▼                         │
┌─────────────────┐                 │
│ Get Tasks with  │                 │
│ Current Order   │                 │
└─────────┬───────┘                 │
          │                         │
          ▼                         │
┌─────────────────┐                 │
│ Create WaitGroup│                 │
│ + Error Channel │                 │
└─────────┬───────┘                 │
          │                         │
          ▼                         │
┌─────────────────┐                 │
│ Start Goroutine │                 │
│ for Each Task   │                 │
└─────────┬───────┘                 │
          │                         │
          ▼                         │
    ┌─────────────┐                 │
    │ Task Status  │                 │
    │ = Running   │                 │
    └─────┬───────┘                 │
          │                         │
          ▼                         │
┌─────────────────┐                 │
│ Execute Task    │                 │
│ Function Fn()   │                 │
└─────────┬───────┘                 │
          │                         │
          ▼                         │
    ┌─────────────┐                 │
    │   Error?    │                 │
    └─────┬───────┘                 │
          │ No                      │
          ▼                         │
    ┌─────────────┐                 │
    │ Status =    │                 │
    │ Completed   │                 │
    └─────┬───────┘                 │
          │                         │
          └─────────┐                 │
                    │                 │
          │ Yes      │                 │
          ▼          │                 │
    ┌─────────────┐ │                 │
    │ Status =    │ │                 │
    │ Failed      │ │                 │
    │ Store Error │ │                 │
    └─────┬───────┘ │                 │
          │         │                 │
          └─────────┘                 │
                    │                 │
                    ▼                 │
          ┌─────────────────┐         │
          │ Send to Error   │         │
          │ Channel         │         │
          └─────────┬───────┘         │
                    │                 │
                    ▼                 │
          ┌─────────────────┐         │
          │ WaitGroup.Done()│         │
          └─────────────────┘         │
                                        │
                    ┌───────────────────┘
                    │
                    ▼
          ┌─────────────────┐
          │ WaitGroup.Wait()│
          └─────────┬───────┘
                    │
                    ▼
          ┌─────────────────┐
          │ Check Error     │
          │ Channel         │
          └─────────┬───────┘
                    │
          ┌─────────┴─────────┐
          │                   │
          ▼                   ▼
    ┌─────────────┐    ┌─────────────┐
    │ Has Error?  │    │ Context Done│
    └─────┬───────┘    └─────┬───────┘
          │ No                 │ Yes
          ▼                   │
    ┌─────────────┐           │
    │ Order++     │           │
    └─────┬───────┘           │
          │                   │
          ▼                   │
    ┌─────────────┐           │
    │ Order >     │           │
    │ MaxOrder?   │           │
    └─────┬───────┘           │
          │ No                │
          ▼                   │
    ┌─────────────┐           │
    │   Loop      │           │
    └─────┬───────┘           │
          │                   │
          └─────────┐         │
                    │         │
          │ Yes      │         │
          ▼          │         │
    ┌─────────────┐ │         │
    │ Status =    │ │         │
    │ Completed   │ │         │
    └─────┬───────┘ │         │
          │         │         │
          └─────────┼─────────┘
                    │
                    ▼
          ┌─────────────────┐
          │ Return nil      │
          │ (Success)       │
          └─────────────────┘

          │ Yes
          ▼
┌─────────────────┐
│ Status = Failed │
│ Return Error    │
└─────────────────┘
```

### 共享空间交互机制

```
┌─────────────────────────────────────────────────────────┐
│                    Plan Instance                        │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐      │
│  │   Order 0   │  │   Order 1   │  │   Order 2   │      │
│  │ ┌─────────┐ │  │ ┌─────────┐ │  │ ┌─────────┐ │      │
│  │ │ Task A  │◄┼──┼►│ Task C  │◄┼──┼►│ Task E  │ │      │
│  │ │Set("key",││  │ │Get("key",││  │ │Del("key",││      │
│  │ │"value") │ │  │ │"value") │ │  │ │"key")   │ │      │
│  │ └─────────┘ │  │ └─────────┘ │  │ └─────────┘ │      │
│  │             │  │             │  │             │      │
│  │ ┌─────────┐ │  │ ┌─────────┐ │  │ ┌─────────┐ │      │
│  │ │ Task B  │◄┼──┼─►│ Task D  │◄┼──┼─►│ Task F  ││      │
│  │ │Subscribe│ │  │ │Trigger  │ │  │ │Set     │ │      │
│  │ │Callback │ │  │ │Event    │ │  │ │Data    │ │      │
│  │ └─────────┘ │  │ └─────────┘ │  │ └─────────┘ │      │
│  └─────────────┘  └─────────────┘  └─────────────┘      │
│           │                │                │             │
│           └────────────────┼────────────────┘             │
│                            │                             │
│  ┌─────────────────────────────────────────────────────┐ │
│  │              SharedSpace                             │ │
│  │                                                     │ │
│  │  ┌─────────────────────────────────────────────┐   │ │
│  │  │            Memory Storage                    │   │ │
│  │  │  ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐  │   │ │
│  │  │  │Key1 │ │Key2 │ │Key3 │ │Key4 │ │Key5 │  │   │ │
│  │  │  │Val1 │ │Val2 │ │Val3 │ │Val4 │ │Val5 │  │   │ │
│  │  │  └─────┘ └─────┘ └─────┘ └─────┘ └─────┘  │   │ │
│  │  └─────────────────────────────────────────────┘   │ │
│  │                                                     │ │
│  │  ┌─────────────────────────────────────────────┐   │ │
│  │  │            Subscribers                       │   │ │
│  │  │  ┌─────────┐ ┌─────────┐ ┌─────────┐       │   │ │
│  │  │  │Key1: fn │ │Key2: fn │ │Key3: fn │ ...   │   │ │
│  │  │  └─────────┘ └─────────┘ └─────────┘       │   │ │
│  │  └─────────────────────────────────────────────┘   │ │
│  └─────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
```

### 事件触发机制

```
┌─────────────────────────────────────────────────────────┐
│                    Event Flow                            │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  ┌─────────────┐    Set()    ┌─────────────────┐        │
│  │   Task A    │─────────────►│   SharedSpace   │        │
│  │             │             │                 │        │
│  │ Set("key",  │             │ ┌─────────────┐ │        │
│  │ "value")    │             │ │Data: {key:   │ │        │
│  └─────────────┘             │ │  value}     │ │        │
│                              │ └─────────────┘ │        │
│                              │                 │        │
│                              │ ┌─────────────┐ │        │
│                              │ │Subscribers:  │ │        │
│                              │ │[key: [fn1,   │ │        │
│                              │ │  fn2, ...]]  │ │        │
│                              │ └─────────────┘ │        │
│                              └─────────────────┘        │
│                                       │                 │
│                                       │ Trigger        │
│                                       ▼                 │
│                              ┌─────────────────┐        │
│                              │ Notify Callback │        │
│                              │ Functions       │        │
│                              │                 │        │
│                              │ fn1(key, value) │        │
│                              │ fn2(key, value) │        │
│                              └─────────────────┘        │
│                                       │                 │
│                                       ▼                 │
│                              ┌─────────────────┐        │
│                              │ Execute Handlers│        │
│                              │                 │        │
│                              │ • Update DB     │        │
│                              │ • Send Notify   │        │
│                              │ • Log Event     │        │
│                              └─────────────────┘        │
│                                                         │
│  Built-in Events:                                       │
│  ┌─────────────────────────────────────────────────┐    │
│  │ TaskStarted   → Task Added to Plan              │    │
│  │ TaskCompleted → Task Finished Successfully      │    │
│  │ TaskError     → Task Failed                     │    │
│  │ Released      → SharedSpace Cleared            │    │
│  └─────────────────────────────────────────────────┘    │
└─────────────────────────────────────────────────────────┘
```

### 任务状态转换图

```
    ┌─────────────┐
    │   Created   │
    └─────┬───────┘
          │ AddTask()
          ▼
    ┌─────────────┐
    │   Running   │◄───────────┐
    └─────┬───────┘            │
          │                    │
    ┌─────┴─────┐              │
    │           │              │
    ▼           ▼              │
┌─────────┐ ┌─────────┐         │
│Completed│ │ Failed  │         │
└─────────┘ └─────────┘         │
                         │    │
                   Pause()│    │Stop()
                         ▼    ▼
    ┌─────────────┐ ┌─────────────┐
    │   Paused    │ │  Destroyed  │
    └─────┬───────┘ └─────────────┘
          │
      Resume()
          │
          ▼
    ┌─────────────┐
    │   Running   │
    └─────────────┘
```

### 并发执行模型

```
Time Axis: ────────────────────────────────────────────▶

Order 0:  ┌─────┐ ┌─────┐ ┌─────┐
          │TaskA│ │TaskB│ │TaskC│  ← Parallel Execution
          └─────┘ └─────┘ └─────┘
          └─────────────────────┘
                 │ WaitGroup.Wait() - 等待Order 0所有任务完成
                 ▼

Order 1:        ┌─────┐ ┌─────┐
                │TaskD│ │TaskE│  ← Parallel Execution
                └─────┘ └─────┘
                └─────────────┘
                       │ WaitGroup.Wait() - 等待Order 1所有任务完成
                       ▼

Order 2:              ┌─────┐
                      │TaskF│  ← Single Task
                      └─────┘
                      └─────┘
                     │ WaitGroup.Wait() - 等待Order 2任务完成
                     ▼

Final Status: Completed
```

### 关键执行特性说明

#### 1. **Order级别的串行执行**

- **不同Order之间是串行的**：下一个Order必须等待上一个Order的所有任务执行完成
- **执行顺序严格**：Order 0 → Order 1 → Order 2 → ...
- **依赖关系保证**：后续Order可以安全依赖前面Order的执行结果

#### 2. **Order内部的并行执行**

- **相同Order之间是并行的**：同一个Order内的所有Task同时执行
- **无锁竞争**：同Order任务通过SharedSpace安全共享数据
- **性能优化**：最大化并行度，提高整体执行效率

#### 3. **等待机制详解**

```go
// 源码中的关键等待逻辑
for order := 0; order <= maxOrder; order++ {
    // 1. 收集当前Order的所有任务
    for _, task := range p.Tasks {
        if task.Order == order {
            tasksAtOrder = append(tasksAtOrder, task)
        }
    }

    // 2. 并行执行当前Order的所有任务
    for _, task := range tasksAtOrder {
        wg.Add(1)
        go func() {
            defer wg.Done()
            task.Fn(task.Context, p.SharedSpace, task.SignalChan)
        }()
    }

    // 3. 关键：等待当前Order的所有任务完成
    wg.Wait()  // ⚠️ 这里会阻塞，直到当前Order所有Task完成

    // 4. 只有当前Order完成后，才会继续下一个Order
}
```

#### 4. **实际执行示例**

```javascript
const plan = new Plan('workflow-example');

// Order 1: 数据收集阶段（并行执行）
plan.Add('collect-user-data', 1, 'data.collect.user');
plan.Add('collect-product-data', 1, 'data.collect.product');
plan.Add('collect-order-data', 1, 'data.collect.order');

// Order 2: 数据处理阶段（等待Order 1完成后执行）
plan.Add('process-user-data', 2, 'data.process.user'); // 可以依赖Order 1的数据
plan.Add('process-product-data', 2, 'data.process.product'); // 可以依赖Order 1的数据

// Order 3: 报表生成阶段（等待Order 2完成后执行）
plan.Add('generate-report', 3, 'report.generate'); // 可以依赖Order 1和Order 2的数据

plan.Run();
```

**执行流程：**

1. **Order 1阶段**: 3个数据收集任务**并行执行**
2. **WaitGroup.Wait()**: 等待所有数据收集任务完成
3. **Order 2阶段**: 只有数据收集完成后，数据处理任务才开始执行
4. **WaitGroup.Wait()**: 等待所有数据处理任务完成
5. **Order 3阶段**: 只有数据处理完成后，报表生成任务才开始执行

#### 5. **错误处理对串行执行的影响**

- 如果某个Order中的任何Task失败，整个Plan会立即终止
- 后续的Order不会被执行
- 这确保了工作流的完整性和一致性

#### 6. **设计优势**

- **可控的并行度**: 既能利用并行计算，又能控制执行顺序
- **数据一致性**: 确保数据按正确的顺序产生和消费
- **依赖管理**: 天然支持任务间的依赖关系
- **错误隔离**: 失败时能够快速停止，避免无效执行

## 任务间共享状态管理详解

### 状态共享的作用范围

**重要说明**: 共享状态在整个Plan生命周期内的所有Task之间都可以使用，包括：

1. **同一个Order内的Task共享** - 并行Task之间可以实时共享数据
2. **不同Order间的Task共享** - 后续Order可以访问前面Order设置的数据
3. **所有Task共享同一个SharedSpace实例** - 由源码保证

#### **源码验证**

```go
// plan.go 第104行：所有Task共享同一个SharedSpace实例
for _, task := range tasksAtOrder {
    wg.Add(1)
    t := task
    go func() {
        defer wg.Done()
        t.Fn(t.Context, p.SharedSpace, t.SignalChan)  // 同一个p.SharedSpace
    }()
}
```

#### **数据可见性时序**

**同一个Order内的数据共享：**

```
Time: ──────────────────────────────────────────▶

Order 1:
Task1:  Set("key1", "value1") ────┐
                              │
Task2:                   ────┼─ Get("key1") → "value1"
                              │
Task3:                   ────┼─ Set("key1", "value2")
                              │
Task1:                   ────┼─ Get("key1") → "value2"
                              │
```

**不同Order间的数据共享：**

```
Time: ──────────────────────────────────────────▶

Order 1:
Task1.1: Set("order1_data", "data1")
Task1.2: Set("order1_result", "result1")
         ↓ WaitGroup.Wait() (等待Order 1完成)

Order 2:
Task2.1: Get("order1_data") → "data1"    ✅ 可见
Task2.2: Set("order2_data", "data2")
         ↓ WaitGroup.Wait() (等待Order 2完成)

Order 3:
Task3.1: Get("order1_data") → "data1"    ✅ 可见
Task3.2: Get("order2_data") → "data2"    ✅ 可见
Task3.3: Set("order3_data", "data3")
```

### 1. 共享状态核心机制

#### **SharedSpace 接口设计**

```go
type SharedSpace interface {
    Set(key string, value interface{}) error      // 设置键值
    Get(key string) (interface{}, error)          // 获取值
    Delete(key string) error                      // 删除键
    Clear() error                                // 清空所有数据
    ClearNotify() error                           // 清空并通知订阅者
    Subscribe(key string, callback func(key string, value interface{})) error
    Unsubscribe(key string) error
}
```

#### **MemorySharedSpace 实现原理**

```go
type MemorySharedSpace struct {
    mu          sync.RWMutex                           // 数据读写锁
    data        map[string]interface{}                 // 存储键值对
    subscribers map[string][]func(key string, value interface{}) // 订阅者回调
    subMu       sync.RWMutex                           // 订阅者读写锁
}
```

### 2. 共享状态操作流程

#### **Set 操作流程图**

```
Task调用shared.Set(key, value)
          │
          ▼
┌─────────────────┐
│ 获取写锁 m.mu   │
│ Lock()         │
└─────────┬───────┘
          │
          ▼
┌─────────────────┐
│ 更新数据        │
│ m.data[key]=value│
└─────────┬───────┘
          │
          ▼
┌─────────────────┐
│ 释放写锁        │
│ Unlock()        │
└─────────┬───────┘
          │
          ▼
┌─────────────────┐
│ 获取订阅者读锁   │
│ subMu.RLock()   │
└─────────┬───────┘
          │
          ▼
┌─────────────────┐
│ 遍历所有订阅者   │
│ for callback    │
└─────────┬───────┘
          │
          ▼
┌─────────────────┐
│ 同步调用回调函数 │
│ callback(key,value)│
└─────────┬───────┘
          │
          ▼
┌─────────────────┐
│ 释放订阅者读锁   │
│ subMu.RUnlock() │
└─────────────────┘
```

#### **Get 操作流程图**

```
Task调用shared.Get(key)
          │
          ▼
┌─────────────────┐
│ 获取读锁 m.mu   │
│ RLock()         │
└─────────┬───────┘
          │
          ▼
┌─────────────────┐
│ 检查键是否存在   │
│ value, exists   │
└─────────┬───────┘
          │
          ▼
    ┌─────────────┐
    │ exists?    │
    └─────┬───────┘
          │ No          │ Yes
          ▼             │
┌─────────────────┐     │
│ 返回错误        │     │
│ "key not found" │     │
└─────────┬───────┘     │
          │             │
          └─────────┐   │
                    │   │
                    ▼   ▼
          ┌─────────────────┐
          │ 释放读锁        │
          │ RUnlock()       │
          └─────────┬───────┘
                    │
                    ▼
          ┌─────────────────┐
          │ 返回值 value    │
          └─────────────────┘
```

### 3. 订阅机制详解

#### **订阅机制架构**

```
┌─────────────────────────────────────────────────────────┐
│                 SharedSpace                            │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  ┌─────────────────────────────────────────────────────┐ │
│  │              Data Storage                           │ │
│  │  ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐        │ │
│  │  │Key1 │ │Key2 │ │Key3 │ │Key4 │ │Key5 │        │ │
│  │  │Val1 │ │Val2 │ │Val3 │ │Val4 │ │Val5 │        │ │
│  │  └─────┘ └─────┘ └─────┘ └─────┘ └─────┘        │ │
│  └─────────────────────────────────────────────────────┘ │
│                                                         │
│  ┌─────────────────────────────────────────────────────┐ │
│  │            Subscribers Registry                     │ │
│  │                                                     │ │
│  │  Key1: [callback1, callback2, callback3]            │ │
│  │  Key2: [callback4, callback5]                        │ │
│  │  Key3: []                                          │ │
│  │  Key4: [callback6]                                 │ │
│  │  ...                                               │ │
│  └─────────────────────────────────────────────────────┘ │
│                                                         │
└─────────────────────────────────────────────────────────┘
          │               │               │
          ▼               ▼               ▼
    ┌─────────┐    ┌─────────┐    ┌─────────┐
    │ Task A  │    │ Task B  │    │ Task C  │
    │         │    │         │    │         │
    │ Set()   │    │ Get()   │    │ Set()   │
    │ → notify│    │         │    │ → notify│
    └─────────┘    └─────────┘    └─────────┘
```

#### **订阅触发机制**

```go
// Set操作触发订阅者
m.subMu.RLock()
if callbacks, exists := m.subscribers[key]; exists {
    for _, callback := range callbacks {
        callback(key, value)  // 同步调用，可能导致阻塞
    }
}
m.subMu.RUnlock()
```

### 4. 实际使用场景

#### **场景1: 同一个Order内的实时共享（生产者-消费者模式）**

```javascript
function ProducerConsumerSameOrder() {
  const plan = new Plan('producer-consumer');

  // 同一个Order内的生产者和消费者，实时共享数据
  plan.Add('producer', 1, 'data.producer', 10);
  plan.Add('consumer', 1, 'data.consumer', plan);

  plan.Run();
  plan.Release();
}

// 生产者任务：生成数据并放入共享空间
function data_producer(plan_id, task_id, count) {
  const plan = new Plan(plan_id);

  for (let i = 0; i < count; i++) {
    // 生产数据并放入共享空间
    plan.Set(`item_${i}`, { id: i, data: `data_${i}`, timestamp: Date.now() });
    plan.Set('last_produced', i);
    plan.Set('total_produced', i + 1);

    console.log(`Produced item ${i}`);
    time.Sleep(10); // 模拟生产时间
  }

  plan.Set('production_complete', true);
  return count;
}

// 消费者任务：从共享空间实时消费数据
function data_consumer(plan_id, task_id, plan) {
  let consumed = 0;
  const consumedItems = [];

  while (true) {
    try {
      const lastProduced = plan.Get('last_produced');
      const isComplete = plan.Get('production_complete');

      // 消费已生产的数据
      while (consumed <= lastProduced) {
        const item = plan.Get(`item_${consumed}`);
        if (item) {
          consumedItems.push(item);
          console.log(`Consumed:`, item);
          consumed++;

          // 更新消费状态
          plan.Set('last_consumed', consumed);
          plan.Set('consumed_items', consumedItems);
        } else {
          break; // 数据还未生产完成
        }
      }

      if (isComplete) {
        console.log('Production complete, consuming remaining items...');
        break;
      }

      time.Sleep(5); // 短暂等待新数据
    } catch (error) {
      // 数据还未准备好
      time.Sleep(5);
    }
  }

  plan.Set('consumption_complete', true);
  plan.Set('total_consumed', consumed);
  return consumed;
}
```

#### **场景2: 不同Order间的数据流水线**

```javascript
function PipelineDifferentOrders() {
  const plan = new Plan('pipeline');

  // Order 1: 数据提取阶段
  plan.Add('extract-users', 1, 'data.extract.users', 'user_db');
  plan.Add('extract-orders', 1, 'data.extract.orders', 'order_db');

  // Order 2: 数据清洗阶段（依赖Order 1的数据）
  plan.Add('clean-users', 2, 'data.clean.users', plan);
  plan.Add('clean-orders', 2, 'data.clean.orders', plan);

  // Order 3: 数据转换阶段（依赖Order 2的数据）
  plan.Add('transform-users', 3, 'data.transform.users', plan);
  plan.Add('transform-orders', 3, 'data.transform.orders', plan);

  // Order 4: 数据聚合和加载阶段（依赖Order 3的数据）
  plan.Add('aggregate-and-load', 4, 'data.aggregate.load', plan);

  plan.Run();
  plan.Release();
}

// Order 1: 提取用户数据
function data_extract_users(plan_id, task_id, source) {
  const plan = new Plan(plan_id);

  const rawUsers = extractUsersFromDatabase(source);

  // 存储到共享空间供Order 2使用
  plan.Set('raw_users', {
    data: rawUsers,
    count: rawUsers.length,
    source: source,
    extracted_at: Date.now()
  });

  console.log(`Extracted ${rawUsers.length} users from ${source}`);
  return rawUsers.length;
}

// Order 2: 清洗用户数据
function data_clean_users(plan_id, task_id, plan) {
  // 读取Order 1提取的数据
  const rawUserData = plan.Get('raw_users');
  if (!rawUserData) {
    throw new Error('Raw user data not found');
  }

  const cleanedUsers = rawUserData.data
    .filter((user) => user.email && user.email.includes('@')) // 过滤无效邮箱
    .map((user) => ({
      ...user,
      name: user.name?.trim(), // 清理空格
      email: user.email?.toLowerCase() // 标准化邮箱
    }));

  // 存储清洗后的数据供Order 3使用
  plan.Set('clean_users', {
    data: cleanedUsers,
    count: cleanedUsers.length,
    original_count: rawUserData.count,
    cleaned_at: Date.now()
  });

  console.log(
    `Cleaned ${cleanedUsers.length} users (removed ${rawUserData.count - cleanedUsers.length} invalid records)`
  );
  return cleanedUsers.length;
}

// Order 3: 转换用户数据
function data_transform_users(plan_id, task_id, plan) {
  // 读取Order 2清洗的数据
  const cleanUserData = plan.Get('clean_users');
  if (!cleanUserData) {
    throw new Error('Clean user data not found');
  }

  const transformedUsers = cleanUserData.data.map((user) => ({
    user_id: user.id,
    display_name: user.name,
    email_hash: hashEmail(user.email), // 隐私化处理
    registration_date: normalizeDate(user.created_at),
    status: determineUserStatus(user),
    transformed_at: Date.now()
  }));

  // 存储转换后的数据供Order 4使用
  plan.Set('transformed_users', {
    data: transformedUsers,
    count: transformedUsers.length,
    transformed_at: Date.now()
  });

  console.log(`Transformed ${transformedUsers.length} users`);
  return transformedUsers.length;
}

// Order 4: 聚合和加载
function data_aggregate_load(plan_id, task_id, plan) {
  // 读取所有前置Order处理的数据
  const transformedUsers = plan.Get('transformed_users');
  const transformedOrders = plan.Get('transformed_orders');

  // 读取原始统计信息
  const rawUserData = plan.Get('raw_users');
  const cleanUserData = plan.Get('clean_users');

  // 聚合统计信息
  const summary = {
    users: {
      original_count: rawUserData?.count || 0,
      cleaned_count: cleanUserData?.count || 0,
      final_count: transformedUsers?.count || 0,
      processed_at: Date.now()
    },
    orders: {
      final_count: transformedOrders?.count || 0
    },
    pipeline: {
      total_processed:
        (transformedUsers?.count || 0) + (transformedOrders?.count || 0),
      processing_time:
        Date.now() -
        Math.min(
          rawUserData?.extracted_at || 0,
          transformedOrders?.transformed_at || 0
        )
    }
  };

  // 存储最终结果
  plan.Set('final_summary', summary);
  plan.Set('pipeline_complete', true);

  console.log('Pipeline completed with summary:', summary);
  return summary;
}
```

#### **场景3: 混合模式（同Order协作 + 跨Order流水线）**

```javascript
function MixedModeExample() {
  const plan = new Plan('mixed-mode');

  // Order 1: 并行数据收集（同Order协作）
  plan.Add('collect-api', 1, 'collect.api', plan);
  plan.Add('collect-file', 1, 'collect.file', plan);
  plan.Add('monitor-progress', 1, 'monitor.progress', plan); // 监控同Order任务进度

  // Order 2: 数据验证（依赖Order 1的收集结果）
  plan.Add('validate-data', 2, 'validate.data', plan);

  // Order 3: 并行数据处理（同Order协作，依赖Order 2）
  plan.Add('process-users', 3, 'process.users', plan);
  plan.Add('process-products', 3, 'process.products', plan);

  // Order 4: 结果合并（依赖Order 3）
  plan.Add('merge-results', 4, 'merge.results', plan);

  plan.Run();
  plan.Release();
}

// Order 1: API数据收集
function collect_api(plan_id, task_id, plan) {
  const apiData = fetchFromAPI('https://api.example.com/data');

  // 与同Order的任务共享进度信息
  plan.Set('api_progress', {
    status: 'collecting',
    items_collected: apiData.length,
    timestamp: Date.now()
  });

  // 存储收集的数据
  plan.Set('api_data', apiData);

  // 通知同Order的其他任务
  plan.Set('api_complete', true);

  return apiData.length;
}

// Order 1: 文件数据收集
function collect_file(plan_id, task_id, plan) {
  const fileData = readFromFile('/data/input.json');

  plan.Set('file_progress', {
    status: 'collecting',
    items_collected: fileData.length,
    timestamp: Date.now()
  });

  plan.Set('file_data', fileData);
  plan.Set('file_complete', true);

  return fileData.length;
}

// Order 1: 进度监控（监控同Order任务）
function monitor_progress(plan_id, task_id, plan) {
  let apiComplete = false;
  let fileComplete = false;

  while (!apiComplete || !fileComplete) {
    const apiProgress = plan.Get('api_progress');
    const fileProgress = plan.Get('file_progress');

    console.log('Progress Monitor:', {
      api: apiProgress,
      file: fileProgress
    });

    apiComplete = plan.Get('api_complete') || false;
    fileComplete = plan.Get('file_complete') || false;

    time.Sleep(100);
  }

  // 计算总体进度
  const apiData = plan.Get('api_data');
  const fileData = plan.Get('file_data');

  const totalProgress = {
    api_collected: apiData.length,
    file_collected: fileData.length,
    total_collected: apiData.length + fileData.length,
    collection_complete: true,
    timestamp: Date.now()
  };

  // 存储总体进度供Order 2使用
  plan.Set('collection_progress', totalProgress);

  return totalProgress;
}
```

#### **场景2: 微服务编排**

```javascript
function OrderProcessing() {
  const plan = new Plan(`order-${order_id}`);

  // 订阅事件通知
  plan.Subscribe('payment_result', 'handlers.payment.complete');
  plan.Subscribe('inventory_reserved', 'handlers.inventory.reserved');

  // 阶段1: 并行验证
  plan.Add('validate-payment', 1, 'payment.validate', payment_info, plan);
  plan.Add('validate-inventory', 1, 'inventory.validate', product_list, plan);

  // 阶段2: 执行操作 (依赖验证结果)
  plan.Add('process-payment', 2, 'payment.process', plan);
  plan.Add('reserve-inventory', 2, 'inventory.reserve', plan);

  plan.Run();
  plan.Release();
}
```

#### **场景3: 复杂计算任务**

```javascript
function ComplexCalculation() {
  const plan = new Plan('complex-calc');

  // 阶段1: 并行计算子问题
  plan.Add('calculate-part1', 1, 'calc.part1', input_data, plan);
  plan.Add('calculate-part2', 1, 'calc.part2', input_data, plan);
  plan.Add('calculate-part3', 1, 'calc.part3', input_data, plan);

  // 阶段2: 合并结果
  plan.Add('merge-results', 2, 'calc.merge', plan);

  // 阶段3: 后处理
  plan.Add('post-process', 3, 'calc.post_process', plan);

  plan.Run();
  plan.Release();
}
```

### 5. 限制条件与注意事项

#### **1. 线程安全限制**

```go
// ✅ 正确: 使用读写锁保证线程安全
func (m *MemorySharedSpace) Set(key string, value interface{}) error {
    m.mu.Lock()
    m.data[key] = value
    m.mu.Unlock()
    return nil
}

// ⚠️ 注意: 订阅者回调是同步执行
for _, callback := range callbacks {
    callback(key, value)  // 可能在数据锁外执行，但订阅者锁内
}
```

#### **2. 订阅者回调限制**

- **同步执行**: 订阅者回调在Set/Delete操作时同步执行
- **阻塞风险**: 如果订阅者回调耗时较长，会影响Set/Delete性能
- **异常处理**: 订阅者回调中的异常不会影响数据存储操作

#### **3. 内存限制**

```go
// 共享空间数据存储在内存中
data map[string]interface{}

// 限制:
// - 数据量受内存大小限制
// - 大对象可能导致GC压力
// - 没有持久化机制
```

#### **4. 数据一致性限制**

- **最终一致性**: 在并行任务中，数据更新可能有短暂的不一致
- **原子性**: 单个Set/Delete操作是原子的
- **事务性**: 不支持多键事务操作

#### **5. 性能限制**

```go
// 读写锁的竞争
mu sync.RWMutex  // 数据锁
subMu sync.RWMutex  // 订阅者锁

// 高并发场景下可能出现:
// - 读多写少: RLock竞争较小
// - 写频繁: Lock竞争激烈
// - 订阅者多: subMu竞争
```

### 5. 同Order并行Task的状态同步问题

#### **问题说明**

**重要警告**: 在同一个Order的并行Task之间，**无法确保状态的设置与读取顺序**，因为：

1. **并行启动**: 同Order内的Task通过goroutine并行启动
2. **调度不确定**: Go运行时调度器决定执行顺序
3. **时序依赖**: 无法控制Task的精确执行时序

#### **执行时序的不确定性**

```
时间轴: ──────────────────────────────────────────▶

Order 1:
Task A:  Set("key1", "value1") ──┐
                              │ 可能先执行，也可能后执行
Task B:  Get("key1") → ???  ◄┘ 可能读取到：
                              • "value1" (如果Task A先执行)
                              • Error (如果Task B先执行)
                              • 部分状态 (如果交错执行)
```

#### **实际测试示例**

```javascript
function RaceConditionTest() {
  const plan = new Plan('race-test');

  // Order 1: 两个并行任务测试竞态条件
  plan.Add('writer-task', 1, 'task.writer', plan);
  plan.Add('reader-task', 1, 'task.reader', plan);

  plan.Run();
  plan.Release();
}

function task_writer(plan_id, task_id, plan) {
  const plan = new Plan(plan_id);

  console.log(`[${Date.now()}] Writer: Starting...`);

  // 写入数据
  plan.Set('test_key', 'writer_value_1');
  console.log(`[${Date.now()}] Writer: Set test_key = writer_value_1`);

  // 模拟一些工作
  time.Sleep(50);

  // 更新数据
  plan.Set('test_key', 'writer_value_2');
  console.log(`[${Date.now()}] Writer: Updated test_key = writer_value_2`);

  return 'writer_completed';
}

function task_reader(plan_id, task_id, plan) {
  const plan = new Plan(plan_id);

  console.log(`[${Date.now()}] Reader: Starting...`);

  // 多次尝试读取数据
  for (let i = 1; i <= 5; i++) {
    try {
      const value = plan.Get('test_key');
      console.log(
        `[${Date.now()}] Reader [attempt ${i}]: Read test_key = ${value}`
      );
    } catch (error) {
      console.log(
        `[${Date.now()}] Reader [attempt ${i}]: Error - ${error.message}`
      );
    }

    time.Sleep(20); // 短暂等待
  }

  return 'reader_completed';
}
```

**可能的输出结果（每次运行都可能不同）：**

```
运行1: Writer先执行
[1609459200000] Writer: Starting...
[1609459200001] Writer: Set test_key = writer_value_1
[1609459200002] Reader: Starting...
[1609459200003] Reader [attempt 1]: Read test_key = writer_value_1
[1609459200004] Reader [attempt 2]: Read test_key = writer_value_1
[1609459200050] Writer: Updated test_key = writer_value_2
[1609459200055] Reader [attempt 3]: Read test_key = writer_value_2
[1609459200075] Reader [attempt 4]: Read test_key = writer_value_2
[1609459200095] Reader [attempt 5]: Read test_key = writer_value_2

运行2: Reader先执行
[1609459200000] Reader: Starting...
[1609459200001] Reader [attempt 1]: Error - key test_key not found
[1609459200020] Reader [attempt 2]: Error - key test_key not found
[1609459200030] Writer: Starting...
[1609459200031] Writer: Set test_key = writer_value_1
[1609459200040] Reader [attempt 3]: Read test_key = writer_value_1
[1609459200060] Reader [attempt 4]: Read test_key = writer_value_1
[1609459200080] Writer: Updated test_key = writer_value_2
[1609459200085] Reader [attempt 5]: Read test_key = writer_value_2
```

#### **解决同Order状态同步的方法**

##### **方法1: 使用同步原语**

```javascript
function SynchronizedSameOrder() {
  const plan = new Plan('synchronized');

  // Order 1: 使用信号量同步的任务
  plan.Add('init-task', 1, 'task.init', plan);
  plan.Add('dependent-task', 1, 'task.dependent', plan);

  plan.Run();
  plan.Release();
}

function task_init(plan_id, task_id, plan) {
  const plan = new Plan(plan_id);

  // 设置初始化数据
  plan.Set('config', { initialized: true, data: 'some_data' });

  // 设置同步信号
  plan.Set('init_complete', true);
  console.log('Init task completed');

  return 'init_done';
}

function task_dependent(plan_id, task_id, plan) {
  const plan = new Plan(plan_id);

  // 等待初始化完成
  let initComplete = false;
  let attempts = 0;
  const maxAttempts = 50; // 最多等待1秒

  while (!initComplete && attempts < maxAttempts) {
    try {
      initComplete = plan.Get('init_complete');
      if (initComplete) break;
    } catch (error) {
      // 信号还未设置
    }

    time.Sleep(20); // 等待20ms
    attempts++;
  }

  if (!initComplete) {
    throw new Error('Initialization timeout');
  }

  // 现在可以安全地读取配置
  const config = plan.Get('config');
  console.log('Dependent task got config:', config);

  // 处理数据
  const result = processData(config.data);
  plan.Set('processed_result', result);

  return result;
}
```

##### **方法2: 事件驱动同步**

```javascript
function EventDrivenSync() {
  const plan = new Plan('event-driven');

  // 订阅初始化完成事件
  plan.Subscribe('init_complete', 'handlers.init.completed');

  // Order 1: 事件驱动的任务
  plan.Add('producer-task', 1, 'task.producer', plan);
  plan.Add('consumer-task', 1, 'task.consumer', plan);

  plan.Run();
  plan.Release();
}

function task_producer(plan_id, task_id, plan) {
  const plan = new Plan(plan_id);

  // 生产数据
  const data = generateData();
  plan.Set('produced_data', data);

  // 触发事件通知消费者
  plan.Set('init_complete', true);
  plan.Set('data_ready_event', { type: 'DATA_READY', data: data.length });

  console.log('Producer completed, data ready');
  return data.length;
}

function task_consumer(plan_id, task_id, plan) {
  const plan = new Plan(plan_id);

  // 使用事件通知机制
  let dataReady = false;

  // 轮询检查事件
  while (!dataReady) {
    try {
      const event = plan.Get('data_ready_event');
      if (event && event.type === 'DATA_READY') {
        dataReady = true;
        console.log('Consumer received event:', event);

        // 现在可以安全读取数据
        const data = plan.Get('produced_data');
        const result = consumeData(data);
        plan.Set('consumed_result', result);

        return result;
      }
    } catch (error) {
      // 事件还未触发
    }

    time.Sleep(10); // 短暂等待
  }
}
```

##### **方法3: 推荐方案 - 使用不同Order**

```javascript
function RecommendedApproach() {
  const plan = new Plan('recommended');

  // Order 1: 数据准备（确保先执行）
  plan.Add('data-preparation', 1, 'task.prepare', plan);

  // Order 2: 数据处理（依赖Order 1，确保数据已准备好）
  plan.Add('data-processing', 2, 'task.process', plan);

  plan.Run();
  plan.Release();
}

function task_prepare(plan_id, task_id, plan) {
  const plan = new Plan(plan_id);

  // 准备数据
  const data = prepareInitialData();
  plan.Set('prepared_data', data);
  plan.Set('data_status', 'ready');

  console.log('Data preparation completed');
  return data.length;
}

function task_process(plan_id, task_id, plan) {
  const plan = new Plan(plan_id);

  // 因为在Order 2，Order 1已经完成，所以数据肯定存在
  const data = plan.Get('prepared_data');
  const status = plan.Get('data_status');

  console.log('Processing data, status:', status);

  // 处理数据
  const result = processData(data);
  plan.Set('processed_result', result);

  return result;
}
```

#### **总结建议**

1. **避免在同Order内进行状态依赖**: 如果Task B需要依赖Task A设置的状态，考虑使用不同Order
2. **使用同步机制**: 如果必须在同Order内同步，使用轮询、事件或同步信号
3. **容错设计**: 始终处理"key not found"的情况，实现重试机制
4. **优先使用Order隔离**: 将有依赖关系的任务分配到不同的Order，利用Plan的串行执行保证

### 6. 共享空间使用指南

#### **正确使用共享空间的原则**

基于前面的分析，正确使用共享空间需要遵循以下原则：

##### **原则1: 明确数据流方向**

```
推荐的数据流模式:
Order 1 (数据生产) → Order 2 (数据消费) → Order 3 (结果聚合)

避免的模式:
Order 1 (互相依赖) ← → Order 1 (互相依赖)  ❌ 并行竞态
```

##### **原则2: 选择合适的共享模式**

| 模式              | 适用场景                | Order安排 | 实现复杂度 | 可靠性 |
| ----------------- | ----------------------- | --------- | ---------- | ------ |
| **跨Order流水线** | 数据处理管道、ETL       | 不同Order | 低         | 高     |
| **同Order协作**   | 生产者-消费者、并行聚合 | 同Order   | 中         | 中     |
| **混合模式**      | 复杂工作流              | 结合使用  | 高         | 高     |

##### **原则3: 数据生命周期管理**

```javascript
// ✅ 推荐: 明确的数据生命周期
function DataLifecycleExample() {
  const plan = new Plan('data-lifecycle');

  // Order 1: 数据创建
  plan.Add('create-data', 1, 'data.create', plan);

  // Order 2: 数据使用和清理
  plan.Add('use-and-cleanup', 2, 'data.use.cleanup', plan);

  // Order 3: 最终清理
  plan.Add('final-cleanup', 3, 'cleanup.final', plan);

  plan.Run();
  plan.Release(); // 确保所有数据清理
}

function data_create(plan_id, task_id, plan) {
  const plan = new Plan(plan_id);

  // 创建数据时标记生命周期
  const data = generateData();
  plan.Set('work_data', {
    data: data,
    created_at: Date.now(),
    status: 'active'
  });

  // 设置数据元信息
  plan.Set('data_metadata', {
    owner: task_id,
    created_at: Date.now(),
    cleanup_order: 2 // 指定清理Order
  });

  return data.length;
}

function data_use_cleanup(plan_id, task_id, plan) {
  const plan = new Plan(plan_id);

  // 使用数据
  const workData = plan.Get('work_data');
  const metadata = plan.Get('data_metadata');

  console.log('Using data created by:', metadata.owner);

  // 处理数据
  const result = processData(workData.data);

  // 立即清理不再需要的数据
  plan.Delete('work_data');
  plan.Set('processing_result', result);

  return result;
}

function cleanup_final(plan_id, task_id, plan) {
  const plan = new Plan(plan_id);

  // 最终清理
  plan.Delete('data_metadata');
  console.log('Final cleanup completed');

  return 'cleanup_done';
}
```

#### **适用场景详细分析**

##### **场景1: 数据处理流水线 (推荐)**

**特点**: 数据按阶段处理，后续依赖前置结果
**适用模式**: 跨Order共享
**实现方式**:

```javascript
function ETL_Pipeline() {
  const plan = new Plan('etl-pipeline');

  // Order 1: Extract (并行提取多个源)
  plan.Add('extract-users', 1, 'extract.users', 'db1');
  plan.Add('extract-orders', 1, 'extract.orders', 'db2');
  plan.Add('extract-products', 1, 'extract.products', 'api');

  // Order 2: Transform (串行转换，依赖Order 1)
  plan.Add('transform-users', 2, 'transform.users', plan);
  plan.Add('transform-orders', 2, 'transform.orders', plan);

  // Order 3: Load (并行加载，依赖Order 2)
  plan.Add('load-users', 3, 'load.users', plan);
  plan.Add('load-orders', 3, 'load.orders', plan);

  plan.Run();
  plan.Release();
}
```

**优势**:

- 数据流向清晰
- 错误隔离好
- 易于调试和监控

##### **场景2: 实时协作处理 (谨慎使用)**

**特点**: 同Order内Task需要实时共享数据
**适用模式**: 同Order共享 + 同步机制
**实现方式**:

```javascript
function RealTimeCollaboration() {
  const plan = new Plan('real-time-collab');

  // Order 1: 实时协作任务
  plan.Add('data-collector', 1, 'collect.data', plan);
  plan.Add('data-processor', 1, 'process.data', plan);
  plan.Add('progress-monitor', 1, 'monitor.progress', plan);

  plan.Run();
  plan.Release();
}

function collect_data(plan_id, task_id, plan) {
  const plan = new Plan(plan_id);

  for (let i = 0; i < 10; i++) {
    // 收集数据并实时共享
    const data = fetchBatch(i);
    plan.Set(`batch_${i}`, data);
    plan.Set('current_batch', i);
    plan.Set('total_collected', i + 1);

    // 通知其他任务
    plan.Set('new_data_available', { batch: i, count: data.length });

    time.Sleep(100);
  }

  plan.Set('collection_complete', true);
  return 10;
}

function process_data(plan_id, task_id, plan) {
  const plan = new Plan(plan_id);

  let processedCount = 0;

  while (processedCount < 10) {
    try {
      const currentBatch = plan.Get('current_batch');

      if (currentBatch >= processedCount) {
        // 处理新批次
        const batch = plan.Get(`batch_${processedCount}`);
        const result = processBatch(batch);

        plan.Set(`processed_${processedCount}`, result);
        plan.Set('processed_count', processedCount + 1);

        processedCount++;
      }
    } catch (error) {
      // 数据还未准备好
    }

    time.Sleep(50);
  }

  return 'processing_completed';
}
```

**注意事项**:

- 必须实现同步机制
- 需要处理数据不存在的情况
- 要设置超时避免死锁

##### **场景3: 配置和状态共享**

**特点**: 全局配置和状态信息共享
**适用模式**: 跨Order共享，一次性设置
**实现方式**:

```javascript
function ConfigSharing() {
  const plan = new Plan('config-sharing');

  // Order 1: 初始化配置
  plan.Add('init-config', 1, 'init.config', plan);

  // Order 2: 使用配置的任务 (并行)
  plan.Add('worker-1', 2, 'worker.task', 'worker1', plan);
  plan.Add('worker-2', 2, 'worker.task', 'worker2', plan);
  plan.Add('worker-3', 2, 'worker.task', 'worker3', plan);

  plan.Run();
  plan.Release();
}

function init_config(plan_id, task_id, plan) {
  const plan = new Plan(plan_id);

  // 全局配置
  const config = {
    database_url: 'postgresql://...',
    api_timeout: 30000,
    retry_count: 3,
    batch_size: 100,
    features: {
      enable_cache: true,
      enable_logging: false
    }
  };

  plan.Set('global_config', config);
  plan.Set('config_loaded_at', Date.now());

  // 运行时状态
  plan.Set('runtime_state', {
    workers_active: 0,
    total_processed: 0,
    errors: []
  });

  console.log('Configuration initialized');
  return 'config_loaded';
}

function worker_task(plan_id, task_id, workerId, plan) {
  const plan = new Plan(plan_id);

  // 读取全局配置
  const config = plan.Get('global_config');
  const state = plan.Get('runtime_state');

  console.log(`${workerId} started with config:`, config);

  // 更新运行时状态
  const updatedState = {
    ...state,
    workers_active: state.workers_active + 1
  };
  plan.Set('runtime_state', updatedState);

  try {
    // 执行工作
    const result = doWork(workerId, config);

    // 更新统计
    const finalState = plan.Get('runtime_state');
    plan.Set('runtime_state', {
      ...finalState,
      total_processed: finalState.total_processed + 1,
      workers_active: finalState.workers_active - 1
    });

    return result;
  } catch (error) {
    // 记录错误
    const errorState = plan.Get('runtime_state');
    plan.Set('runtime_state', {
      ...errorState,
      errors: [
        ...errorState.errors,
        { worker: workerId, error: error.message }
      ],
      workers_active: errorState.workers_active - 1
    });

    throw error;
  }
}
```

#### **共享空间的反模式**

##### **❌ 反模式1: 同Order内的强依赖**

```javascript
// 错误示例: 同Order内强依赖
function AntiPattern_StrongDependency() {
  const plan = new Plan('anti-pattern');

  // 同一个Order内，Task B强依赖Task A
  plan.Add('task-a', 1, 'task.a', plan); // 先执行
  plan.Add('task-b', 1, 'task.b', plan); // 依赖Task A，但执行顺序不确定

  plan.Run();
  plan.Release();
}

// 问题: Task B可能先执行，导致获取数据失败
```

##### **❌ 反模式2: 数据结构过于分散**

```javascript
// 错误示例: 过于分散的数据结构
function AntiPattern_ScatteredData() {
  const plan = new Plan('scattered-data');

  plan.Add('process', 1, 'process.scattered', plan);

  plan.Run();
  plan.Release();
}

function process_scattered(plan_id, task_id, plan) {
  // ❌ 不推荐: 分散存储
  plan.Set('user_1_name', 'Alice');
  plan.Set('user_1_email', 'alice@example.com');
  plan.Set('user_1_age', 30);
  plan.Set('user_2_name', 'Bob');
  plan.Set('user_2_email', 'bob@example.com');
  plan.Set('user_2_age', 25);
  // ... 1000个用户

  // ✅ 推荐: 结构化存储
  plan.Set('users', [
    { name: 'Alice', email: 'alice@example.com', age: 30 },
    { name: 'Bob', email: 'bob@example.com', age: 25 }
  ]);

  const users = plan.Get('users'); // 一次性获取所有数据
}
```

##### **❌ 反模式3: 忽略清理**

```javascript
// 错误示例: 忽略数据清理
function AntiPattern_NoCleanup() {
  const plan = new Plan('no-cleanup');

  plan.Add('process', 1, 'process.no.cleanup', plan);

  plan.Run();
  // ❌ 忘记调用 plan.Release()
}

function process_no_cleanup(plan_id, task_id, plan) {
  // 处理大量数据
  const bigData = loadLargeDataSet();
  plan.Set('temp_big_data', bigData);

  // 处理完成后没有清理
  // ❌ 应该调用 plan.Delete('temp_big_data')
}
```

#### **共享空间使用的决策树**

```
开始使用共享空间？
        │
        ▼
需要Task间通信吗？ ──No──→ 使用其他方式（消息队列、数据库等）
        │Yes
        ▼
有明确的依赖关系吗？
        │
    ┌───┴───┐
    │Yes    │No
    ▼        ▼
使用跨Order  需要实时协作吗？
流水线模式   │
    │        ┌───┴───┐
    │       │Yes    │No
    │       ▼        ▼
    │   同Order+   避免共享，
    │   同步机制   使用独立数据
    │
    ▼
实现简单、可靠
```

#### **决策树应用代码示例**

##### **1. 决策辅助函数**

```javascript
/**
 * 共享空间使用决策器
 * @param {Object} requirements - 需求分析
 * @param {boolean} requirements.needsCommunication - 是否需要Task间通信
 * @param {boolean} requirements.hasDependency - 是否有明确依赖关系
 * @param {boolean} requirements.needsRealtime - 是否需要实时协作
 * @returns {Object} 决策结果和建议
 */
function SharedSpaceDecisionMaker(requirements) {
  const { needsCommunication, hasDependency, needsRealtime } = requirements;

  // 决策树逻辑
  if (!needsCommunication) {
    return {
      recommendation: 'AVOID_SHARED_SPACE',
      reason: 'Task间不需要通信',
      alternative: '使用消息队列、数据库或独立变量',
      pattern: null,
      codeExample: null
    };
  }

  if (!hasDependency) {
    if (needsRealtime) {
      return {
        recommendation: 'SAME_ORDER_WITH_SYNC',
        reason: '需要实时协作但无明确依赖',
        pattern: '同Order + 同步机制',
        codeExample: 'realtimeCollaborationExample()'
      };
    } else {
      return {
        recommendation: 'AVOID_SHARED_SPACE',
        reason: '无明确依赖关系且不需要实时协作',
        alternative: '使用独立数据结构',
        pattern: null,
        codeExample: 'independentDataExample()'
      };
    }
  }

  // hasDependency === true
  return {
    recommendation: 'CROSS_ORDER_PIPELINE',
    reason: '有明确依赖关系，适合流水线模式',
    pattern: '跨Order流水线',
    codeExample: 'pipelineExample()'
  };
}
```

##### **2. 实际应用示例**

```javascript
// 示例1: ETL数据处理 - 明确依赖关系
const etlRequirements = {
  needsCommunication: true,
  hasDependency: true,
  needsRealtime: false
};

const etlDecision = SharedSpaceDecisionMaker(etlRequirements);
console.log('ETL决策结果:', etlDecision);
// 输出: { recommendation: 'CROSS_ORDER_PIPELINE', pattern: '跨Order流水线' }

// 应用决策结果
function buildETLPlan(decision) {
  if (decision.recommendation === 'CROSS_ORDER_PIPELINE') {
    return pipelineExample(); // 使用流水线模式
  }
}

// 示例2: 实时数据监控 - 无明确依赖但需要实时协作
const monitoringRequirements = {
  needsCommunication: true,
  hasDependency: false,
  needsRealtime: true
};

const monitoringDecision = SharedSpaceDecisionMaker(monitoringRequirements);
console.log('监控决策结果:', monitoringDecision);
// 输出: { recommendation: 'SAME_ORDER_WITH_SYNC', pattern: '同Order + 同步机制' }

// 示例3: 独立计算任务 - 不需要通信
const computeRequirements = {
  needsCommunication: false,
  hasDependency: false,
  needsRealtime: false
};

const computeDecision = SharedSpaceDecisionMaker(computeRequirements);
console.log('计算决策结果:', computeDecision);
// 输出: { recommendation: 'AVOID_SHARED_SPACE', alternative: '使用消息队列、数据库或独立变量' }
```

##### **3. 自动化Plan构建器**

```javascript
/**
 * 基于决策结果自动构建Plan
 */
class PlanBuilder {
  constructor(planId) {
    this.planId = planId;
    this.tasks = [];
    this.sharedSpace = new Plan(planId);
  }

  // 根据决策添加任务
  addTaskFromDecision(requirements, taskConfig) {
    const decision = SharedSpaceDecisionMaker(requirements);

    switch (decision.recommendation) {
      case 'CROSS_ORDER_PIPELINE':
        return this.addPipelineTask(taskConfig);

      case 'SAME_ORDER_WITH_SYNC':
        return this.addSyncedTask(taskConfig);

      case 'AVOID_SHARED_SPACE':
        return this.addIndependentTask(taskConfig);

      default:
        throw new Error(`Unknown recommendation: ${decision.recommendation}`);
    }
  }

  // 流水线任务添加
  addPipelineTask(taskConfig) {
    const { taskId, order, handler, ...params } = taskConfig;

    // 确保使用不同的Order
    this.sharedSpace.Add(
      taskId,
      order,
      handler,
      this.sharedSpace,
      ...Object.values(params)
    );
    this.tasks.push({ taskId, order, type: 'pipeline' });

    console.log(`✅ 添加流水线任务: ${taskId} (Order ${order})`);
    return this;
  }

  // 同步任务添加
  addSyncedTask(taskConfig) {
    const { taskId, order, handler, ...params } = taskConfig;

    // 添加同步机制
    const syncedHandler = function (planId, tid, plan, ...args) {
      // 添加同步等待逻辑
      const syncWait = (signalKey, timeout = 5000) => {
        const startTime = Date.now();
        while (Date.now() - startTime < timeout) {
          try {
            const signal = plan.Get(signalKey);
            if (signal) return signal;
          } catch (e) {
            // 信号还未设置
          }
          time.Sleep(50);
        }
        throw new Error(`Sync timeout for ${signalKey}`);
      };

      // 执行原始处理逻辑
      return handler.call(this, planId, tid, plan, syncWait, ...args);
    };

    this.sharedSpace.Add(
      taskId,
      order,
      syncedHandler,
      this.sharedSpace,
      ...Object.values(params)
    );
    this.tasks.push({ taskId, order, type: 'synced' });

    console.log(`⚠️ 添加同步任务: ${taskId} (Order ${order}) - 需要同步机制`);
    return this;
  }

  // 独立任务添加
  addIndependentTask(taskConfig) {
    const { taskId, handler, ...params } = taskConfig;

    // 直接执行，不使用共享空间
    console.log(`❌ 跳过共享空间: ${taskId} - 使用独立处理`);

    // 独立执行逻辑
    setTimeout(() => {
      handler(null, taskId, ...Object.values(params));
    }, 0);

    return this;
  }

  // 构建并执行Plan
  build() {
    console.log(`📋 Plan构建完成，包含 ${this.tasks.length} 个任务:`);
    this.tasks.forEach((task) => {
      console.log(`  - ${task.taskId} (${task.type}) - Order ${task.order}`);
    });

    // 自动执行
    this.sharedSpace.Run();
    this.sharedSpace.Release();

    return this.sharedSpace;
  }
}
```

##### **4. 实际应用演示**

```javascript
// 演示1: 自动构建ETL流水线
function buildETLPipeline() {
  const builder = new PlanBuilder('auto-etl');

  // 数据提取阶段 (Order 1)
  builder.addTaskFromDecision(
    { needsCommunication: true, hasDependency: true, needsRealtime: false },
    {
      taskId: 'extract-users',
      order: 1,
      handler: extractUsersHandler,
      dataSource: 'users_db'
    }
  );

  builder.addTaskFromDecision(
    { needsCommunication: true, hasDependency: true, needsRealtime: false },
    {
      taskId: 'extract-orders',
      order: 1,
      handler: extractOrdersHandler,
      dataSource: 'orders_db'
    }
  );

  // 数据转换阶段 (Order 2)
  builder.addTaskFromDecision(
    { needsCommunication: true, hasDependency: true, needsRealtime: false },
    {
      taskId: 'transform-data',
      order: 2,
      handler: transformDataHandler
    }
  );

  // 数据加载阶段 (Order 3)
  builder.addTaskFromDecision(
    { needsCommunication: true, hasDependency: true, needsRealtime: false },
    {
      taskId: 'load-data',
      order: 3,
      handler: loadDataHandler,
      target: 'warehouse_db'
    }
  );

  return builder.build();
}

// 演示2: 实时监控系统
function buildRealtimeMonitor() {
  const builder = new PlanBuilder('realtime-monitor');

  // 数据收集器 (Order 1)
  builder.addTaskFromDecision(
    { needsCommunication: true, hasDependency: false, needsRealtime: true },
    {
      taskId: 'data-collector',
      order: 1,
      handler: dataCollectorHandler,
      sources: ['api1', 'api2', 'api3']
    }
  );

  // 实时处理器 (Order 1 - 同Order协作)
  builder.addTaskFromDecision(
    { needsCommunication: true, hasDependency: false, needsRealtime: true },
    {
      taskId: 'realtime-processor',
      order: 1,
      handler: realtimeProcessorHandler,
      processingType: 'streaming'
    }
  );

  // 告警器 (Order 1 - 同Order协作)
  builder.addTaskFromDecision(
    { needsCommunication: true, hasDependency: false, needsRealtime: true },
    {
      taskId: 'alert-generator',
      order: 1,
      handler: alertGeneratorHandler,
      thresholds: { cpu: 80, memory: 90 }
    }
  );

  return builder.build();
}

// 演示3: 独立计算任务
function buildIndependentCompute() {
  const builder = new PlanBuilder('independent-compute');

  // 独立计算任务 - 不需要共享空间
  builder.addTaskFromDecision(
    { needsCommunication: false, hasDependency: false, needsRealtime: false },
    {
      taskId: 'math-compute',
      handler: mathComputeHandler,
      formula: 'complex_calculation',
      inputs: [1, 2, 3, 4, 5]
    }
  );

  builder.addTaskFromDecision(
    { needsCommunication: false, hasDependency: false, needsRealtime: false },
    {
      taskId: 'image-process',
      handler: imageProcessHandler,
      imagePath: '/path/to/image.jpg',
      filters: ['blur', 'sharpen']
    }
  );

  return builder.build();
}
```

##### **5. 决策结果验证器**

```javascript
/**
 * 验证决策结果的正确性
 */
function validateDecision(requirements, decision) {
  const validation = { valid: true, warnings: [] };

  // 验证逻辑
  if (
    requirements.needsCommunication &&
    decision.recommendation === 'AVOID_SHARED_SPACE'
  ) {
    validation.valid = false;
    validation.warnings.push('需要通信但选择避免共享空间，可能导致功能缺失');
  }

  if (
    requirements.hasDependency &&
    decision.recommendation === 'SAME_ORDER_WITH_SYNC'
  ) {
    validation.warnings.push(
      '有明确依赖关系但使用同Order+同步，建议考虑跨Order流水线'
    );
  }

  if (
    !requirements.needsRealtime &&
    decision.recommendation === 'SAME_ORDER_WITH_SYNC'
  ) {
    validation.warnings.push('不需要实时协作但使用同步机制，可能过度设计');
  }

  return validation;
}

// 使用示例
function demonstrateDecisionMaking() {
  const scenarios = [
    {
      name: 'ETL处理',
      requirements: {
        needsCommunication: true,
        hasDependency: true,
        needsRealtime: false
      }
    },
    {
      name: '实时监控',
      requirements: {
        needsCommunication: true,
        hasDependency: false,
        needsRealtime: true
      }
    },
    {
      name: '独立计算',
      requirements: {
        needsCommunication: false,
        hasDependency: false,
        needsRealtime: false
      }
    }
  ];

  scenarios.forEach((scenario) => {
    const decision = SharedSpaceDecisionMaker(scenario.requirements);
    const validation = validateDecision(scenario.requirements, decision);

    console.log(`\n=== ${scenario.name} ===`);
    console.log('需求:', scenario.requirements);
    console.log('决策:', decision);
    console.log('验证:', validation);

    if (!validation.valid) {
      console.log('⚠️ 决策可能有问题，请重新评估');
    }

    if (validation.warnings.length > 0) {
      console.log('📝 建议:');
      validation.warnings.forEach((warning) => console.log(`  - ${warning}`));
    }
  });
}
```

##### **6. 快速决策工具**

```javascript
/**
 * 命令行/交互式决策工具
 */
function quickDecisionTool() {
  console.log('🤖 Plan共享空间决策助手');
  console.log('请回答以下问题:\n');

  const questions = [
    {
      key: 'needsCommunication',
      text: '1. Task之间需要通信吗？ (y/n): '
    },
    {
      key: 'hasDependency',
      text: '2. 有明确的依赖关系吗？ (y/n): '
    },
    {
      key: 'needsRealtime',
      text: '3. 需要实时协作吗？ (y/n): '
    }
  ];

  // 模拟用户输入 (实际使用时可以从命令行读取)
  const userAnswers = {
    needsCommunication: true,
    hasDependency: true,
    needsRealtime: false
  };

  const decision = SharedSpaceDecisionMaker(userAnswers);
  const validation = validateDecision(userAnswers, decision);

  console.log('\n📊 决策结果:');
  console.log(`推荐方案: ${decision.pattern || decision.alternative}`);
  console.log(`原因: ${decision.reason}`);

  if (decision.codeExample) {
    console.log(`参考示例: ${decision.codeExample}`);
  }

  if (!validation.valid) {
    console.log('\n⚠️ 警告: 决策可能需要调整');
    validation.warnings.forEach((w) => console.log(`  - ${w}`));
  }

  return decision;
}
```

#### **性能优化建议**

##### **1. 数据访问优化**

```javascript
// ✅ 批量读取
function optimized_reading(plan_id, task_id, plan) {
  const plan = new Plan(plan_id);

  // 一次性获取所有需要的数据
  const metadata = plan.Get('data_metadata');
  const config = plan.Get('global_config');
  const state = plan.Get('runtime_state');

  // 使用数据
  processData(metadata, config, state);

  // ❌ 避免频繁的单独访问
  // const name = plan.Get('name');
  // const email = plan.Get('email');
  // const age = plan.Get('age');
  // ...
}
```

##### **2. 数据结构优化**

```javascript
// ✅ 使用索引和缓存
function optimized_structure(plan_id, task_id, plan) {
  const plan = new Plan(plan_id);

  // 建立索引
  const users = plan.Get('users');
  const userIndex = {};
  users.forEach((user) => {
    userIndex[user.id] = user;
  });

  plan.Set('user_index', userIndex); // 缓存索引

  // 快速查找
  const user = plan.Get('user_index')[userId];
}
```

##### **3. 内存管理优化**

```javascript
// ✅ 及时清理大对象
function memory_optimized(plan_id, task_id, plan) {
  const plan = new Plan(plan_id);

  // 处理大对象
  const bigData = plan.Get('temp_big_data');
  const result = processBigData(bigData);

  // 立即清理
  plan.Delete('temp_big_data');

  // 存储小结果
  plan.Set('processing_result', result);

  return result;
}
```

### 6. 最佳实践建议

#### **1. 数据结构设计**

```javascript
// ✅ 推荐: 使用结构化数据
plan.Set('user_data', {
  users: [...],
  count: 100,
  last_updated: Date.now()
});

// ❌ 避免: 过多的键值对
plan.Set('user_1', user1);
plan.Set('user_2', user2);
// ... 1000个用户
```

#### **2. 订阅者设计**

```javascript
// ✅ 推荐: 快速执行的回调
plan.Subscribe('key1', function (key, value) {
  // 快速处理，避免阻塞
  results.push(value);
});

// ❌ 避免: 耗时操作
plan.Subscribe('key1', function (key, value) {
  // 不要在这里做耗时操作
  const result = longRunningCalculation(value);
  saveToDatabase(result); // 可能阻塞其他操作
});
```

#### **3. 错误处理**

```javascript
function robustTask(plan_id, task_id, plan) {
  try {
    // 安全的获取数据
    const data = plan.Get('required_key');
    if (!data) {
      throw new Error('Required data not found');
    }

    // 处理数据
    const result = processData(data);

    // 安全的存储数据
    plan.Set('result_key', result);
    return result;
  } catch (error) {
    // 记录错误到共享空间
    plan.Set('error', {
      task_id: task_id,
      error: error.message,
      timestamp: Date.now()
    });
    throw error;
  }
}
```

#### **4. 资源管理**

```javascript
function cleanupPlan() {
  const plan = new Plan('cleanup-example');

  // 使用try-finally确保资源清理
  try {
    // 执行任务
    plan.Run();
  } finally {
    // 确保清理共享空间
    plan.Clear();
    plan.Release();
  }
}
```

### 错误传播机制

```
┌─────────────────┐    Error     ┌─────────────────┐
│   Task A        │─────────────►│   Error Channel │
│ (Failed)        │              │                 │
└─────────────────┘              │ error: "..."    │
                                 │                 │
                                 └─────────┬───────┘
                                           │
                                           ▼
                                 ┌─────────────────┐
                                 │ WaitGroup.Wait()│
                                 │ Detect Error    │
                                 └─────────┬───────┘
                                           │
                                           ▼
                                 ┌─────────────────┐
                                 │ Plan.Status =   │
                                 │ Failed          │
                                 │ Return Error    │
                                 └─────────────────┘

         Context Cancellation:
┌─────────────────┐    Cancel   ┌─────────────────┐
│   Plan.Context  │────────────►│   Task.Context  │
│ (ctx.Done())    │             │ (Detect Cancel) │
└─────────────────┘             └─────────┬───────┘
                                           │
                                           ▼
                                 ┌─────────────────┐
                                 │ Task Stop       │
                                 │ Early Return    │
                                 └─────────────────┘
```

## API 参考

### Plan 创建

```typescript
class Plan {
  constructor(id: string) {
    // 初始化计划
  }
}
```

创建一个新的 Plan 实例，需要传入plan_id,如果此id已经存在，会返回已存在的Plan。

```typescript
const plan = new Plan(plan_id: string);
```

## 类型定义

```typescript
/**
 * 计划或任务的状态
 */
export type PlanStatus =
  | 'created' //初始状态
  | 'running' //任务执行中
  | 'paused' //任务暂停
  | 'completed' //任务成功完成
  | 'failed' //任务执行失败
  | 'destroyed' //任务已终止
  | 'unknown';

/**
 * Plan 类
 */
export declare class Plan {
  /**
   * @param plan_id - 计划ID
   */
  constructor(plan_id: string);

  /**
   * 订阅计划
   * @param key - 要订阅的键
   * @param subscribe_fn - 计划变更时执行的处理器，注意不支持直接传js回调函数
   * @param subscribe_args - 传递给订阅处理器的参数,The rest of the arguments are the arguments to the process
   */
  Subscribe(key: string, subscribe_fn: string, ...subscribe_args: any[]): void;

  /**
   * 添加任务到计划
   *
   * will Trigger the TaskStarted signal "TaskStarted"
   * @param task_id - 任务ID
   * @param order - 任务顺序，同一个order的任务会并行执行
   * @param task_process - 要执行的任务处理函数或是处理器名称,默认情况下只支持处理器名称，如果需要直接传入函数，需要定制开发。
   * @param task_args - 传递给任务的参数
   */
  Add(
    task_id: string,
    order: number,
    task_process: string,
    ...task_args: any[]
  ): void;

  /**
   * 同步运行计划
   */
  Run(): void;

  /**
   * 释放计划,清空共享空间
   */
  Release(): void;

  /**
   * 获取计划状态和每个任务的状态
   */
  Status(): {
    plan: PlanStatus;
    tasks: Record<string, PlanStatus>;
  };

  /**
   * 获取任务状态
   */
  TaskStatus(task_id: string): PlanStatus;

  /**
   * 获取或设置任务数据，如果未提供数据则返回当前数据，否则设置数据并返回之前的数据
   */
  TaskData(task_id: string, data?: any): any;

  /**
   * 从共享空间获取值
   */
  Get(key: string): any;

  /**
   * 在共享空间中设置值，如果有订阅相关的Key,会触发相关的subscribe事件。
   */
  Set(key: string, value: any): void;

  /**
   * 从共享空间删除值
   */
  Del(key: string): void;

  /**
   * 清空共享空间
   */
  Clear(): void;
}
```

## 示例

```typescript
import { Plan, time } from '@yao/runtime';

function Test() {
  const namespace = 'scripts.runtime.api.plan';

  //same id with same namespace,will be the same plan
  //同一个id,多次new Plan,会返回同一个plan
  const plan = new Plan('test-plan');
  // 订阅任务的变化
  plan.Subscribe('TaskStarted', `${namespace}.TaskStarted`, 'foo');
  plan.Subscribe('TaskCompleted', `${namespace}.TaskCompleted`, 'foo');
  // 订阅共享空间的变化
  plan.Subscribe('some-key', `${namespace}.SomeKey`, 'bar');

  plan.Add('task-1', 1, `${namespace}.Task1`, 'foo1');
  plan.Add('task-2', 1, `${namespace}.Task2`, 'foo2');
  plan.Add('task-3', 2, `${namespace}.Task3`, 'foo3');
  plan.Add('task-4', 2, `${namespace}.Task4`, 'foo4');
  // 运行计划
  plan.Run();
  // 释放计划,资源，也会触发subscribe事件。
  plan.Release();
  return 'Done';
}

function Task1(plan_id: string, task_id: string, foo: string) {
  const plan = new Plan(plan_id);

  // 更新共享数据，will trigger the SomeKey signal
  plan.Set('some-key', `foo-${foo}`);
  time.Sleep(200);
  const ts = new Date().getTime();
  return ts;
}

function Task2(plan_id: string, task_id: string, foo: string) {
  time.Sleep(300);
  const ts = new Date().getTime();
  return ts;
}

function Task3(plan_id: string, task_id: string, foo: string) {
  const plan = new Plan(plan_id);
  const some = plan.Get('some-key');

  // 更新共享数据
  plan.Set('some-key', `bar-${foo}`);
  time.Sleep(400);
  const ts = new Date().getTime();
  return { ts: ts, shared: some };
}

function Task4(plan_id: string, task_id: string, foo: string) {
  const plan = new Plan(plan_id);
  time.Sleep(500);
  const some = plan.Get('some-key');
  const ts = new Date().getTime();
  return { ts: ts, shared: some };
}

function SomeKey(plan_id: string, key: string, data: any, foo: string) {
  const plan = new Plan(plan_id);
  const ts = new Date().getTime();
  console.log(`SomeKey ${plan_id} ${key} ${JSON.stringify(data)} ${foo} ${ts}`);
  console.log(plan.Status());
}

function TaskStarted(plan_id: string, key: string, data: any, foo: string) {
  const ts = new Date().getTime();
  console.log(
    `TaskStarted ${plan_id} ${key} ${JSON.stringify(data)} ${foo} ${ts}`
  );
}

function TaskCompleted(plan_id: string, key: string, data: any, foo: string) {
  const ts = new Date().getTime();
  console.log(
    `TaskCompleted ${plan_id} ${key} ${JSON.stringify(data)} ${foo} ${ts}`
  );
}
```

## 事件触发

内置事件，会在任务状态发生变化时自动触发。在使用Plan时，不要在Set函数中使用以下Key参数。

- TaskCompleted：当任务完成时触发
- TaskError：当任务发生错误时触发
- TaskStarted：当任务被添加到计划时触发
- Released：当共享空间中的所有数据被删除时触发

## 业务场景应用

### 1. 数据处理管道

适合需要按顺序处理数据的场景，如ETL流程、数据清洗等。

```typescript
// 数据处理管道示例
function DataPipeline() {
  const plan = new Plan('data-etl-pipeline');

  // 阶段1: 数据提取 (并行从多个源提取)
  plan.Add('extract-mysql', 1, 'extractors.mysql', 'users');
  plan.Add('extract-api', 1, 'extractors.api', 'https://api.example.com/users');
  plan.Add('extract-file', 1, 'extractors.csv', '/data/users.csv');

  // 阶段2: 数据清洗和转换 (并行处理不同类型的数据)
  plan.Add('clean-user-data', 2, 'cleaners.user', plan);
  plan.Add('transform-format', 2, 'transformers.json-to-xml', plan);

  // 阶段3: 数据加载
  plan.Add('load-warehouse', 3, 'loaders.warehouse', plan);

  plan.Run();
  plan.Release();
}
```

### 2. 微服务编排

适合需要协调多个微服务调用的复杂业务流程。

```typescript
// 订单处理流程
function OrderProcessing() {
  const plan = new Plan(`order-${order_id}`);

  // 阶段1: 并行验证
  plan.Add('validate-inventory', 1, 'services.inventory.check', order_id);
  plan.Add('validate-customer', 1, 'services.customer.validate', customer_id);
  plan.Add('validate-payment', 1, 'services.payment.validate', payment_info);

  // 阶段2: 预处理 (依赖验证结果)
  plan.Add('reserve-inventory', 2, 'services.inventory.reserve', order_id);
  plan.Add('calculate-shipping', 2, 'services.shipping.calculate', address);

  // 阶段3: 执行操作
  plan.Add('process-payment', 3, 'services.payment.process', order_id);
  plan.Add('create-shipment', 3, 'services.shipment.create', order_id);

  // 阶段4: 后续处理
  plan.Add('send-confirmation', 4, 'services.notification.email', order_id);
  plan.Add('update-analytics', 4, 'services.analytics.track', order_id);

  plan.Run();
  plan.Release();
}
```

### 3. 批处理作业

适合需要分批处理大量数据的场景。

```typescript
// 批处理图片处理
function BatchImageProcessing() {
  const plan = new Plan('batch-image-process');

  // 获取待处理图片列表
  const images = getPendingImages();

  // 阶段1: 并行上传到临时存储
  images.forEach((image, index) => {
    plan.Add(`upload-${index}`, 1, 'storage.upload.temp', image.path);
  });

  // 阶段2: 并行图片处理
  images.forEach((image, index) => {
    plan.Add(`resize-${index}`, 2, 'image.resize', image.id, '800x600');
    plan.Add(`compress-${index}`, 2, 'image.compress', image.id, 'quality:80');
  });

  // 阶段3: 移动到正式存储
  images.forEach((image, index) => {
    plan.Add(`move-storage-${index}`, 3, 'storage.move.permanent', image.id);
  });

  // 阶段4: 更新数据库
  images.forEach((image, index) => {
    plan.Add(`update-db-${index}`, 4, 'database.images.update', image.id);
  });

  plan.Run();
  plan.Release();
}
```

### 4. 复杂报表生成

适合需要多步骤数据聚合和报表生成的场景。

```typescript
// 月度销售报表生成
function MonthlyReportGeneration() {
  const plan = new Plan(`monthly-report-${year}-${month}`);

  // 阶段1: 并行数据收集
  plan.Add('collect-sales-data', 1, 'reports.collect.sales', year, month);
  plan.Add(
    'collect-customer-data',
    1,
    'reports.collect.customers',
    year,
    month
  );
  plan.Add('collect-product-data', 1, 'reports.collect.products', year, month);
  plan.Add(
    'collect-marketing-data',
    1,
    'reports.collect.marketing',
    year,
    month
  );

  // 阶段2: 并行数据处理
  plan.Add('process-sales-metrics', 2, 'reports.process.sales', plan);
  plan.Add('process-customer-analysis', 2, 'reports.process.customers', plan);
  plan.Add('process-product-performance', 2, 'reports.process.products', plan);

  // 阶段3: 数据聚合
  plan.Add('aggregate-summary', 3, 'reports.aggregate.summary', plan);
  plan.Add('generate-charts', 3, 'reports.generate.charts', plan);

  // 阶段4: 报表生成和分发
  plan.Add('generate-pdf', 4, 'reports.generate.pdf', plan);
  plan.Add('send-stakeholders', 4, 'reports.distribute.email', plan);

  plan.Run();
  plan.Release();
}
```

### 5. 系统初始化和部署

适合需要按顺序初始化系统组件的场景。

```typescript
// 系统初始化流程
function SystemInitialization() {
  const plan = new Plan('system-init');

  // 阶段1: 基础设施检查
  plan.Add('check-database', 1, 'system.database.health');
  plan.Add('check-redis', 1, 'system.redis.health');
  plan.Add('check-storage', 1, 'system.storage.health');

  // 阶段2: 数据库初始化
  plan.Add('migrate-database', 2, 'system.database.migrate');
  plan.Add('seed-data', 2, 'system.database.seed');

  // 阶段3: 服务初始化
  plan.Add('init-cache', 3, 'system.cache.warmup');
  plan.Add('init-search-index', 3, 'system.search.rebuild');

  // 阶段4: 验证和通知
  plan.Add('health-check', 4, 'system.health.full');
  plan.Add('notify-ready', 4, 'system.notify.ready');

  plan.Run();
  plan.Release();
}
```

### 6. 内容发布流程

适合需要多步骤内容审核和发布的场景。

```typescript
// 文章发布流程
function ContentPublishing() {
  const plan = new Plan(`content-${content_id}`);

  // 阶段1: 内容检查
  plan.Add('spell-check', 1, 'content.spell.check', content_id);
  plan.Add('plagiarism-check', 1, 'content.plagiarism.check', content_id);
  plan.Add('content-validation', 1, 'content.validation.rules', content_id);

  // 阶段2: 并行处理
  plan.Add('generate-excerpt', 2, 'content.process.excerpt', content_id);
  plan.Add('extract-tags', 2, 'content.process.tags', content_id);
  plan.Add('optimize-seo', 2, 'content.seo.optimize', content_id);

  // 阶段3: 质量审核
  plan.Add('moderator-review', 3, 'content.moderator.review', content_id);
  plan.Add('ai-quality-check', 3, 'content.ai.quality', content_id);

  // 阶段4: 发布和分发
  plan.Add('publish-website', 4, 'content.publish.web', content_id);
  plan.Add('publish-mobile', 4, 'content.publish.mobile', content_id);
  plan.Add('notify-subscribers', 4, 'content.notify.subscribers', content_id);

  plan.Run();
  plan.Release();
}
```

### 7. 错误处理和重试机制

Plan可以通过订阅内置事件实现错误处理：

```typescript
function RobustDataProcessing() {
  const plan = new Plan('robust-processing');

  // 订阅错误事件
  plan.Subscribe('TaskError', 'error.handler', 'handle_task_error');
  plan.Subscribe('TaskCompleted', 'success.handler', 'handle_task_success');

  // 添加任务
  plan.Add('process-data', 1, 'data.process.main', data_source);

  plan.Run();
  plan.Release();
}

function handleTaskError(plan_id: string, task_id: string, error: string) {
  const plan = new Plan(plan_id);

  // 根据错误类型决定重试策略
  if (error.includes('timeout')) {
    // 超时错误，重新添加任务
    plan.Add(`${task_id}-retry`, 1, 'data.process.main', data_source);
  } else if (error.includes('connection')) {
    // 连接错误，等待后重试
    setTimeout(() => {
      plan.Add(`${task_id}-retry`, 1, 'data.process.main', data_source);
    }, 5000);
  }
}
```

## 最佳实践

### 1. 任务设计原则

- **幂等性**: 任务应该支持重复执行而不产生副作用
- **原子性**: 每个任务应该完成一个独立的业务逻辑单元
- **可测试性**: 任务应该易于单独测试

### 2. 错误处理策略

- 使用事件订阅机制处理错误
- 实现适当的重试逻辑
- 记录详细的错误日志用于调试

### 3. 性能优化

- 合理分配任务的Order，避免不必要的串行化
- 控制并发任务数量，避免系统过载
- 及时释放Plan资源

### 4. 监控和日志

- 使用共享空间记录执行状态
- 订阅关键事件进行监控
- 实现执行时间的跟踪

## 注意

计划组件在js环境中与golang环境暴露的接口不同：

- js环境，没有stop,pause,resume等方法,只能等待任务完成。
  - plan.Run() Run the plan
  - plan.Add() Add a task to the plan
  - plan.Status() Get the status of the plan and each task
  - plan.Release() Release the task and releases its resources
  - plan.TaskStatus() Get the status of a task
  - plan.TaskData() Get or set the data of a task
  - plan.Subscribe() Subscribe to a key in the shared space
  - plan.Get() Get a value from the shared space
  - plan.Set() Set a value in the shared space
  - plan.Del() Delete a value from the shared space
  - plan.Clear() Clear the shared space

- golang环境，更加丰富的功能，可以暂停，恢复，停止等。
  - plan.NewPlan() NewPlan creates a new Plan instance
  - plan.AddTask() AddTask adds a new task to the plan
  - plan.RemoveTask() RemoveTask removes a task from the plan
  - plan.Start() Start begins execution of the plan
  - plan.Pause() Pause temporarily halts execution of the plan
  - plan.Resume() Resume continues execution of a paused plan
  - plan.Stop() Stop terminates execution of the plan
  - plan.Rlease() Release the task and releases its resources
  - plan.GetStatus() GetStatus returns the current status of the plan and its tasks
  - plan.Trigger() Trigger triggers an event on the plan
  - plan.GetTaskStatus() GetTaskStatus returns the status of a specific task
  - plan.GetTaskData() GetTaskData returns the data associated with a specific task
  - share.Set stores a value in the shared space
  - share.Get retrieves a value from the shared space
  - share.Delete deletes a value from the shared space
  - share.ClearNotify ClearNotify removes all values from the shared space and notifies subscribers
  - share.Clear removes all values from the shared space
  - share.Subscribe subscribes to changes in the shared space
  - share.Unsubscribe unsubscribes from changes in the shared space
