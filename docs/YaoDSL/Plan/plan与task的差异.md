# Plan 与 Task 的差异分析

## 概述

通过分析 `plan` 和 `task` 两个目录的源代码，发现它们代表了两种不同层次的并发执行模型：

- **Plan**: 面向工作流的任务编排系统
- **Task**: 面向作业处理的并发执行引擎

## 核心设计理念差异

### Plan - 工作流编排

**设计目标**:

- 管理有依赖关系的任务集合
- 支持任务间共享状态
- 提供工作流级别的生命周期管理

**核心特性**:

```go
// 任务依赖管理 - 通过Order字段实现顺序执行
type Task struct {
    ID         string
    Order      int           // 执行顺序，支持并行和串行
    Fn         TaskFunc      // 任务执行函数
    Status     Status        // 任务状态
    Context    context.Context
    SignalChan chan Signal   // 信号控制（暂停/恢复/停止）
}

// 共享空间 - 任务间数据交换
type SharedSpace interface {
    Set(key string, value interface{}) error
    Get(key string) (interface{}, error)
    Subscribe(key string, callback func(key string, value interface{})) error
    // ...
}
```

### Task - 作业处理引擎

**设计目标**:

- 高并发处理独立作业
- 提供工作池模式
- 支持作业生命周期回调

**核心特性**:

```go
// 工作池模型
type Pool struct {
    size      int              // 工作者数量
    max       int              // 队列最大长度
    jobque    chan *Job        // 作业队列
    workerque chan *Worker     // 工作者队列
}

// 作业单元
type Job struct {
    id       int
    args     []interface{}    // 作业参数
    timeout  time.Duration     // 超时控制
    status   int              // 作业状态
    response interface{}       // 执行结果
}
```

## 架构差异对比

### 1. 执行模式

| 特性         | Plan                            | Task                     |
| ------------ | ------------------------------- | ------------------------ |
| **执行单位** | Task (工作流任务)               | Job (独立作业)           |
| **执行模式** | 按Order分组，组内并行，组间串行 | 完全并行，基于工作池     |
| **依赖关系** | 通过Order字段显式管理           | 无依赖关系，作业完全独立 |
| **共享状态** | 通过SharedSpace实现             | 无内置共享机制           |

### 2. 生命周期管理

**Plan 状态管理**:

```go
const (
    StatusCreated   // 已创建
    StatusRunning   // 运行中
    StatusPaused    // 已暂停
    StatusCompleted // 已完成
    StatusFailed    // 失败
    StatusDestroyed // 已销毁
)
```

**Task 状态管理**:

```go
const (
    WAITING // 等待执行
    RUNNING // 执行中
    SUCCESS // 执行成功
    FAILURE // 执行失败
)
```

### 3. 控制机制

**Plan 控制方式**:

- **信号驱动**: 通过 `SignalChan` 发送控制信号
- **上下文传播**: 使用 `context.Context` 进行取消传播
- **状态同步**: 支持暂停/恢复/停止的细粒度控制

**Task 控制方式**:

- **事件回调**: 通过 `Handlers` 接口定义生命周期回调
- **超时控制**: 每个Job独立的超时机制
- **队列管理**: 通过通道缓冲控制并发量

## 实现原理深度分析

### Plan 实现原理

1. **任务编排算法**:

```go
// 按Order分组执行
for order := 0; order <= maxOrder; order++ {
    var tasksAtOrder []*Task
    for _, task := range p.Tasks {
        if task.Order == order {
            tasksAtOrder = append(tasksAtOrder, task)
        }
    }

    // 同一Order的任务并行执行
    var wg sync.WaitGroup
    for _, task := range tasksAtOrder {
        wg.Add(1)
        go func(t *Task) {
            defer wg.Done()
            t.Fn(t.Context, p.SharedSpace, t.SignalChan)
        }(task)
    }
    wg.Wait() // 等待当前Order完成，继续下一个Order
}
```

2. **共享空间实现**:

```go
type MemorySharedSpace struct {
    mu          sync.RWMutex
    data        map[string]interface{}
    subscribers map[string][]func(key string, value interface{})
    subMu       sync.RWMutex
}
```

### Task 实现原理

1. **工作池模式**:

```go
// 工作者池管理
func (t *Task) startWorker(w *Worker) {
    go func() {
        for {
            t.pool.workerque <- w  // 将工作者放入队列
            select {
            case job := <-w.job:   // 接收作业
                t.start(job)       // 执行作业
            case <-t.ctx.Done():   // 退出信号
                return
            }
        }
    }()
}
```

2. **作业分发机制**:

```go
for {
    select {
    case job := <-t.pool.jobque:    // 从队列取作业
        worker := <-t.pool.workerque // 获取空闲工作者
        worker.job <- job           // 分配作业
    case <-interrupt:              // 中断信号
        return
    case <-t.ctx.Done():           // 取消信号
        return
    }
}
```

## 使用场景差异

### Plan 适用场景

1. **工作流编排**: 需要按特定顺序执行的任务链
2. **状态共享**: 任务间需要传递数据
3. **细粒度控制**: 需要暂停/恢复等控制功能
4. **复杂业务流程**: 如数据处理管道、ETL流程等

**示例**:

```go
plan := NewPlan(ctx, "data-pipeline", sharedSpace)
plan.AddTask("extract", 1, extractData)    // 第1步：数据抽取
plan.AddTask("transform", 2, transformData) // 第2步：数据转换
plan.AddTask("load", 3, loadData)          // 第3步：数据加载
```

### Task 适用场景

1. **高并发作业处理**: 大量独立任务需要并行处理
2. **任务队列**: 异步处理用户请求
3. **后台作业**: 定时任务、批处理作业
4. **API限流**: 控制并发执行数量

**示例**:

```go
task := New(handlers, Option{
    Name:           "api-processor",
    WorkerNums:     10,    // 10个工作者
    JobQueueLength: 1024,   // 队列长度
    Timeout:        30,     // 30秒超时
})
```

## 性能特征对比

| 指标         | Plan                      | Task                     |
| ------------ | ------------------------- | ------------------------ |
| **并发模型** | 分阶段并发                | 完全并发                 |
| **内存开销** | 中等（共享空间+任务管理） | 较低（轻量级作业）       |
| **延迟**     | 较高（顺序等待）          | 较低（即时分发）         |
| **吞吐量**   | 中等（受限于最长任务）    | 较高（受限于工作者数量） |
| **资源控制** | 细粒度（任务级）          | 粗粒度（工作者级）       |

## 流程图对比

### Plan 执行流程图

```
┌─────────────────┐
│   Plan Start    │
└─────────┬───────┘
          │
          ▼
┌─────────────────┐
│  Find Max Order │
└─────────┬───────┘
          │
          ▼
┌─────────────────┐
│   Order = 0     │◄───────────────┐
└─────────┬───────┘               │
          │                       │
          ▼                       │
┌─────────────────┐               │
│ Get Tasks at    │               │
│ Current Order   │               │
└─────────┬───────┘               │
          │                       │
          ▼                       │
┌─────────────────┐               │
│ Parallel Execute │               │
│ (Goroutines)    │               │
└─────────┬───────┘               │
          │                       │
          ▼                       │
┌─────────────────┐               │
│ Wait for All    │               │
│ Tasks Complete  │               │
└─────────┬───────┘               │
          │                       │
          ▼                       │
┌─────────────────┐               │
│ Check Errors    │               │
└─────────┬───────┘               │
          │                       │
          ▼                       │
    ┌─────────┐        No          │
    │ Error?  ├────────────────────┘
    └─────┬───┘
          │ Yes
          ▼
┌─────────────────┐
│  Plan Failed    │
└─────────────────┘

          │
          ▼
┌─────────────────┐
│ Order++         │
└─────────┬───────┘
          │
          ▼
┌─────────────────┐
│ Order > Max?    │───Yes───┐
└─────────┬───────┘         │
          │ No              │
          ▼                 │
    ┌─────────┐             │
    │   Loop  │             │
    └─────┬───┘             │
          │                 │
          └─────────────────┘
```

### Task 执行流程图

```
┌─────────────────┐
│   Task Start    │
└─────────┬───────┘
          │
          ▼
┌─────────────────┐
│ Create Workers  │
│ (N Workers)     │
└─────────┬───────┘
          │
          ▼
┌─────────────────┐
│ Workers Ready   │
│ (workerque)     │
└─────────┬───────┘
          │
          ▼
┌─────────────────┐
│ Listen for:     │
│ • Job Queue     │
│ • Interrupt     │
│ • Context Done  │
└─────────┬───────┘
          │
          ▼
    ┌─────────┐
    │ Job in  │
    │ Queue?  │
    └─────┬───┘
          │ Yes
          ▼
┌─────────────────┐
│ Get Available   │
│ Worker          │
└─────────┬───────┘
          │
          ▼
┌─────────────────┐
│ Assign Job to   │
│ Worker          │
└─────────┬───────┘
          │
          ▼
┌─────────────────┐
│ Worker Execute  │
│ Job (Parallel)  │
└─────────┬───────┘
          │
          ▼
┌─────────────────┐
│ Call Handlers:  │
│ • Add           │
│ • Exec          │
│ • Success/Error │
│ • Progress      │
└─────────┬───────┘
          │
          ▼
┌─────────────────┐
│ Remove Job      │
│ from Memory     │
└─────────┬───────┘
          │
          └─────────┘
```

### 架构对比图

```
Plan Architecture:
┌─────────────────────────────────────────────────────────┐
│                        Plan                              │
├─────────────────────────────────────────────────────────┤
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐      │
│  │   Order 0   │  │   Order 1   │  │   Order 2   │      │
│  │ ┌─────────┐ │  │ ┌─────────┐ │  │ ┌─────────┐ │      │
│  │ │ Task A  │ │  │ │ Task C  │ │  │ │ Task E  │ │      │
│  │ └─────────┘ │  │ └─────────┘ │  │ └─────────┘ │      │
│  │ ┌─────────┐ │  │ ┌─────────┐ │  │ ┌─────────┐ │      │
│  │ │ Task B  │ │  │ │ Task D  │ │  │ │         │ │      │
│  │ └─────────┘ │  │ └─────────┘ │  │ └─────────┘ │      │
│  └─────────────┘  └─────────────┘  └─────────────┘      │
│           │                │                │             │
│           └────────────────┼────────────────┘             │
│                            │                             │
│  ┌─────────────────────────────────────────────────────┐ │
│  │              SharedSpace                             │ │
│  │  ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐         │ │
│  │  │ Key │ │ Key │ │ Key │ │ Key │ │ Key │         │ │
│  │  │  A  │ │  B  │ │  C  │ │  D  │ │  E  │         │ │
│  │  └─────┘ └─────┘ └─────┘ └─────┘ └─────┘         │ │
│  └─────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
            ↓ (串行执行Order，并行执行同Order任务)

Task Architecture:
┌─────────────────────────────────────────────────────────┐
│                        Task                              │
├─────────────────────────────────────────────────────────┤
│  ┌─────────────────────────────────────────────────────┐ │
│  │                 Job Queue                            │ │
│  │  ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐ ┌─────┐         │ │
│  │  │Job1 │ │Job2 │ │Job3 │ │Job4 │ │Job5 │ ...     │ │
│  │  └─────┘ └─────┘ └─────┘ └─────┘ └─────┘         │ │
│  └─────────────────────────────────────────────────────┘ │
│                            ▼                             │
│  ┌─────────────────────────────────────────────────────┐ │
│  │                Worker Pool                           │ │
│  │  ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐   │ │
│  │  │Worker 1 │ │Worker 2 │ │Worker 3 │ │Worker N │   │ │
│  │  │         │ │         │ │         │ │         │   │ │
│  │  │  Job    │ │  Job    │ │  Job    │ │  Job    │   │ │
│  │  │Handler  │ │Handler  │ │Handler  │ │Handler  │   │ │
│  │  └─────────┘ └─────────┘ └─────────┘ └─────────┘   │ │
│  └─────────────────────────────────────────────────────┘ │
│                            │                             │
│  ┌─────────────────────────────────────────────────────┐ │
│  │                 Event Handlers                      │ │
│  │  • Add      • Exec      • Success                   │ │
│  │  • Error    • Progress  • NextID                    │ │
│  └─────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────┘
            ↓ (完全并行，无依赖关系)
```

## 总结

**Plan** 和 **Task** 代表了两种不同的并发处理哲学：

1. **Plan** 强调**有序性**和**状态共享**，适合复杂的业务工作流
2. **Task** 强调**并发性**和**吞吐量**，适合高负载的作业处理

两者并非相互替代，而是互补的组件。在实际应用中，可以这样使用：

- 使用 **Task** 处理大量的独立作业（如用户请求、消息处理）
- 使用 **Plan** 编排复杂的业务流程（如数据处理管道、工作流自动化）

这种设计体现了单一职责原则，每个模块都专注于自己的核心功能，提供了灵活且高效的并发处理能力。

`plan` 与 `task` 模块分别承担了逻辑编排与异步任务处理的不同职责。`plan` 的核心实现原理是基于 **逻辑节点的有向执行流**。它允许开发者定义一组有序或依赖的步骤，通过 `Plan` 结构体管理上下文 `Context` 并顺序调用各节点的 `Execute` 方法。其设计重点在于同步的逻辑组织，确保一系列复杂操作能够按照预设的拓扑结构稳定运行，通常用于处理即时性要求高、逻辑分支复杂的业务编排。

相比之下，`task` 的实现原理侧重于 **基于队列的异步任务调度与生命周期管理**。它通过 `Task` 接口抽象了任务的执行逻辑，并结合 `Process` 机制实现了任务的注册、分发与状态追踪。`task` 模块通常会配合 `Job` 调度器或消息队列，利用 Goroutines 池来处理耗时操作，如邮件发送或数据同步。其内部维护了任务的 `Status`，支持任务的重试、超时控制及进度汇报，实现了与主业务流程的解耦。

总结其区别：`plan` 是一种 **同步编排模式**，关注“如何按序组织代码”；而 `task` 是一种 **异步处理模式**，关注“如何离线处理耗时工作”。实现上，`plan` 依赖深度的递归或循环遍历节点树，而 `task` 依赖任务队列与并发控制池。
