# Yao 的 MCP（Model Context Protocol）架构进行了深入分析。

Yao 的 MCP 实现是一个 **双向桥接架构**：它既作为 MCP Client 连接外部或内部工具，又可以通过 HTTP/SSE 将这些能力作为 MCP Server 暴露给外部 AI 客户端（如 Claude Desktop）。

以下是详细的架构分析、流程图及配置梳理。

### 1\. Yao MCP 核心架构设计

通过分析 `mcp/mcp.go` 和 `mcp/client/client.go`，Yao 的 MCP 架构主要由以下几个核心组件构成：

1.  **MCP Manager (`mcp.go`)**:

    - 作为全局入口，维护 `clients` (Map) 和 `servers` (Map)。
    - 负责 DSL 文件的加载 (`LoadClient`)、解析 (`application.Parse`) 和 环境变量处理 (`helper.EnvString`)。
    - 核心工厂方法 `LoadClientSource` 根据 `transport` 类型决定创建哪种客户端实例。

2.  **Transport Layer (传输层)**:
    代码中明确区分了两种主要的传输/处理模式：

    - **Process Transport (`mcp/process` package)**: 这是 Yao 特有的。它不走网络协议，而是直接在内存中映射 Yao 的内部处理器（如 `models.*`, `scripts.*`）。在 `LoadClientSource` 中可以看到，如果是 `types.TransportProcess`，它会额外加载 Mapping 数据。
    - **Standard Transports (`mcp/client` package)**: 遵循标准 MCP 协议，包括 `sse` (HTTP/Server-Sent Events) 和 `stdio` (标准输入输出进程通信)。由 `client.New` 处理初始化。

3.  **Proxy/Server Layer**:

    - 虽然代码主要展示了 Client SDK，但 README 提到如果配置了 `endpoint`，Yao 会在 `/v1/mcps/{endpoint}` 暴露服务。这充当了 **代理 (Proxy)** 的角色，将外部 AI 的请求转发给内部配置好的 MCP Client (无论是连接 GitHub 还是内部 Script)。

### 2\. 架构流程图

为了帮助理解 `LoadClient` 的初始化流程以及运行时的数据流向，我绘制了以下 Mermaid 流程图：

```mermaid
graph TB
    subgraph "Initialization Phase (mcp.go)"
        Start[LoadClient(file, id)] --> ReadFile[Read DSL File]
        ReadFile --> Parse[Parse DSL to ClientDSL]
        Parse --> CheckTransport{Check Transport Type}

        CheckTransport -->|process| LoadMapping[Load Mapping Data<br/>(Tools/Resources/Prompts)]
        LoadMapping --> ProcessNew[process.New()]

        CheckTransport -->|sse / stdio / http| ClientNew[client.New()]

        ProcessNew --> Store[Store in Global 'clients' Map]
        ClientNew --> Store
    end

    subgraph "Runtime Execution Phase"
        Request[External AI / Internal Code] -->|Select(id)| GetClient[Get Client from Map]
        GetClient --> Execute{Transport Type?}

        Execute -->|process| InternalCall[Direct Internal Call<br/>(Yao Process/Script)]

        Execute -->|sse| HTTPCall[HTTP/SSE Request<br/>(External MCP Server)]

        Execute -->|stdio| SubProcess[Spawn/Pipe Subprocess<br/>(Local Node/Python Script)]
    end

    style CheckTransport fill:#f96,stroke:#333,stroke-width:2px
    style Store fill:#9f9,stroke:#333,stroke-width:2px
    style InternalCall fill:#aaf,stroke:#333
```

### 3\. MCP 配置逻辑梳理

根据 `mcp/README.md` 和 `mcp/mcp.go` 中的逻辑，配置文件的核心字段决定了行为模式。

配置文件通常位于 `mcps/` 目录下，文件扩展名为 `.mcp.yao`。

#### A. 基础配置 (所有类型通用)

- **`name` / `id`**: 客户端唯一标识 (通常从文件名推断)。
- **`transport`**: 核心字段，决定连接方式 (`sse`, `stdio`, `process`, `http`)。
- **`endpoint`**: (可选) 如果设置，Yao 会启动一个 HTTP 服务暴露此 MCP。

#### B. 传输类型特定配置

| 传输类型 (`transport`) | 关键字段                 | 逻辑说明                                                                     | 适用场景                                                         |
| :--------------------- | :----------------------- | :--------------------------------------------------------------------------- | :--------------------------------------------------------------- |
| **`process`**          | `tools`, `resources`     | 将 Yao 内部的 `models.*`, `scripts.*` 映射为 MCP 的 Tool 或 Resource。       | **内部集成**：让 AI 直接操作数据库或调用业务逻辑。无需网络开销。 |
| **`sse` / `http`**     | `url`, `headers`         | `mcp.go` 会校验 `URL` 是否存在。用于连接远程 MCP 服务器。                    | **远程连接**：连接 GitHub、Slack 等提供标准 MCP 接口的服务。     |
| **`stdio`**            | `command`, `args`, `env` | `mcp.go` 会校验 `Command` 是否存在。Yao 启动子进程并通过 Stdin/Stdout 通信。 | **本地扩展**：运行本地 Python/Node.js 脚本作为 MCP 服务。        |

#### C. 示例代码分析

- **SSE 模式 (`mcps/github.mcp.yao`)**:

  ```json
  {
    "transport": "sse",
    "url": "https://github.com/mcp/api",
    "headers": { "Authorization": "Bearer $ENV.GITHUB_TOKEN" }
  }
  ```

  这里使用了 `$ENV.` 语法，`mcp.go` 在加载时会通过 `helper.EnvString` 解析环境变量，保证敏感信息不硬编码。

- **Process 模式 (`mcps/internal.mcp.yao`)**:

  ```json
  {
    "transport": "process",
    "tools": { "validate": "scripts.validator.Check" }
  }
  ```

  这种模式下，MCP 的 `CallTool("validate")` 请求会被直接转换为 Yao 的 `process.New("scripts.validator.Check", args...)` 调用。

### 总结

Yao 的 MCP 设计非常灵活，它本质上是一个 **MCP 路由器和适配器**。它不仅实现了标准的 MCP Client 协议，还利用 Go 的接口特性将自身业务逻辑虚拟化为 MCP Server。

如果您需要了解具体的 `process` 传输层是如何将 MCP 请求转换为 Yao 处理器调用的细节，或者想看 `sse` 客户端的重连机制，请随时告诉我。
