# 异步任务

## 概述

异步任务是一种用于处理耗时操作、消耗大量资源或容易出错的逻辑的机制。它可以将这些操作从请求主流程中剥离出来，异步执行，从而提高系统的响应速度和稳定性。

### 使用场景

- 耗时的数据处理操作
- 资源密集型任务（如图片处理）
- 第三方服务调用（如发送邮件）
- 批量数据导入导出
- 需要重试机制的操作

例如：新用户注册成功后发送欢迎邮件，可以将发送邮件的操作作为异步任务执行，这样可以让用户更快地得到注册响应，同时避免邮件发送失败影响主流程。

### 工作机制

异步任务的工作机制如下：

1. 在程序内部维护一个可重复调用的任务池
2. 当向任务池中加入新的任务时，任务会进入等待状态
3. 系统会根据配置的工作进程数（worker_nums）来并发处理任务
4. 任务执行过程中可以实时反馈进度
5. 支持失败重试机制

## 任务生命周期

### 状态转换图

```
    [添加任务]
        ↓
    [WAITING] ←───────────── [重试]
        ↓
    [RUNNING]
   ↙    ↓    ↘
[SUCCESS] [FAILURE] [超时/取消]
   ↓        ↓
[清理]    [清理]
   ↓        ↓
─────────────────
   [内存清理]
```

### 状态详细说明

#### 1. WAITING (等待状态)

- **触发时机**：任务被成功添加到任务队列后
- **状态特征**：
  - 任务在队列中等待worker处理
  - 占用队列位置
  - 可以通过Get方法查询到状态信息
- **持续时间**：从添加到被worker分配的等待时间
- **相关事件**：触发 `event.add` 回调

#### 2. RUNNING (运行状态)

- **触发时机**：任务被worker开始执行时
- **状态特征**：
  - 任务正在执行处理器逻辑
  - 可以通过Progress方法更新进度
  - 受超时时间限制
- **持续时间**：从开始执行到任务结束（成功/失败/超时）
- **相关操作**：
  - 支持进度更新
  - 支持超时取消
  - 可以被任务取消器中断

#### 3. SUCCESS (成功状态)

- **触发时机**：任务处理器正常执行完成
- **状态特征**：
  - 任务执行成功，有返回结果
  - 触发 `event.success` 回调
  - 任务完成后会被清理
- **生命周期**：短暂状态，随后任务会被从内存中移除
- **相关事件**：触发 `event.success` 回调

#### 4. FAILURE (失败状态)

- **触发时机**：
  - 任务执行过程中抛出异常
  - 任务执行超时
  - 达到最大重试次数仍然失败
- **状态特征**：
  - 任务执行失败，记录错误信息
  - 触发 `event.error` 回调
  - 可能会触发重试机制（如果配置了重试）
- **生命周期**：短暂状态，随后任务会被从内存中移除
- **相关事件**：触发 `event.error` 回调

### 任务时间线

```
时间轴: ──────────────────────────────────────────────────→
       │  添加   │   等待   │   执行   │   完成   │   清理
       │         │         │         │         │
状态:   │  -     │ WAITING │ RUNNING │ SUCCESS │   -
       │         │         │   ↘     │         │
事件:   │ add()  │         │ FAILURE │   ↘     │   -
       │         │ progress│         │ error() │   -
       │         │()       │ success()│         │   -
```

### 内存管理

#### 任务存储

- **活跃期间**：任务存储在内存的 `jobs` 映射中
- **索引机制**：通过任务ID快速定位任务信息
- **并发控制**：使用 `sync.Mutex` 保证线程安全

#### 清理机制

- **成功/失败后**：任务从内存中自动清理
- **清理触发**：`defer delete(t.jobs, job.id)` 在任务执行完成后触发
- **内存释放**：任务相关的所有资源都会被释放

#### 内存优化建议

```javascript
// 1. 及时查询任务状态，避免长时间持有引用
function monitorTask_check(taskId) {
  try {
    const info = Process('tasks.example.get', taskId);
    if (info.status === 'SUCCESS' || info.status === 'FAILURE') {
      console.log('任务完成，状态:', info.status);
      return { completed: true, status: info.status }; // 停止监控，让系统清理任务
    }
  } catch (err) {
    console.log('任务已清理');
    return { completed: true, status: 'cleaned' }; // 任务不存在，已被清理
  }

  // 还在运行中，需要继续监控
  return { running: true, message: '任务运行中' };
}

// 2. 避免大量任务同时存在
function addTasksBatch_prepare(tasks, batchSize = 10) {
  const batches = [];
  for (let i = 0; i < tasks.length; i += batchSize) {
    batches.push(tasks.slice(i, i + batchSize));
  }

  return batches; // 返回批次列表供外部分批执行
}

function addTasksBatch_execute(batches, batchIndex) {
  if (batchIndex >= batches.length) {
    return { completed: true, message: '所有批次执行完成' };
  }

  const batch = batches[batchIndex];
  console.log(`执行第 ${batchIndex + 1} 批，包含 ${batch.length} 个任务`);

  batch.forEach((task) => {
    Process('tasks.example.add', task.data);
  });

  return {
    batch_completed: true,
    batch_index: batchIndex,
    next_batch: batchIndex + 1,
    message: `批次 ${batchIndex + 1} 执行完成`
  };
}
```

## 核心数据类型

### 任务状态常量

```javascript
// 任务状态枚举
const TaskStatus = {
  WAITING: 1, // 等待执行
  RUNNING: 2, // 正在执行
  SUCCESS: 3, // 执行成功
  FAILURE: 4 // 执行失败
};
```

### 任务配置结构

```typescript
interface TaskConfig {
  name: string; // 任务名称
  worker_nums: number; // 工作进程数量
  attempts: number; // 失败重试次数
  attempt_after: number; // 重试间隔（毫秒）
  timeout: number; // 任务超时时间（秒）
  size: number; // 任务队列大小
  process: string; // 任务处理器
  event?: {
    // 事件处理器（可选）
    next?: string; // 生成任务ID的处理器
    add?: string; // 任务添加回调
    success?: string; // 任务成功回调
    error?: string; // 任务失败回调
    progress?: string; // 进度更新回调
  };
}
```

### 任务信息结构

```typescript
interface TaskInfo {
  id: number; // 任务ID
  status: string; // 任务状态: "WAITING" | "RUNNING" | "SUCCESS" | "FAILURE"
  current: number; // 当前进度
  total: number; // 总进度
  message: string; // 进度信息
  response: any; // 任务执行结果或错误信息
}
```

## 任务配置

在应用的 `tasks` 目录下创建任务定义配置文件（如：`tasks/example.yao`）：

```json
{
  "name": "示例任务",
  "worker_nums": 10,
  "attempts": 3,
  "attempt_after": 200,
  "timeout": 2,
  "size": 1000,
  "process": "scripts.task.Send",
  "event": {
    "next": "scripts.task.NextID",
    "add": "scripts.task.OnAdd",
    "success": "scripts.task.OnSuccess",
    "error": "scripts.task.OnError",
    "progress": "scripts.task.OnProgress"
  }
}
```

### 配置参数说明

| 参数           | 说明                     | 是否必填 |
| -------------- | ------------------------ | -------- |
| name           | 任务名称                 | 是       |
| worker_nums    | 任务池中工作进程数量     | 是       |
| attempts       | 失败重试次数             | 是       |
| attempt_after  | 重试间隔（毫秒）         | 是       |
| timeout        | 任务超时时间（秒）       | 是       |
| size           | 任务队列大小             | 是       |
| process        | 任务处理器               | 是       |
| event.next     | 生成任务唯一ID的处理器   | 否       |
| event.add      | 添加任务时的回调处理器   | 否       |
| event.success  | 任务成功时的回调处理器   | 否       |
| event.error    | 任务失败时的回调处理器   | 否       |
| event.progress | 任务进度更新的回调处理器 | 否       |

### 事件处理器说明

#### event.next

- **触发时机**：每次添加新任务时，用于生成任务的唯一标识
- **参数**：无
- **返回值**：number 类型，表示任务ID
- **使用场景**：
  - 需要自定义任务ID生成规则
  - 需要保证任务ID的全局唯一性
  - 需要使用特定格式的任务ID

#### event.add

- **触发时机**：任务被成功添加到任务池后
- **参数**：
  - id: number - 任务ID
- **使用场景**：
  - 记录任务创建日志
  - 更新任务相关的业务状态
  - 发送任务创建通知

#### event.success

- **触发时机**：任务执行成功后
- **参数**：
  - id: number - 任务ID
  - res: any - 任务执行结果
- **使用场景**：
  - 处理任务执行结果
  - 更新相关业务状态
  - 发送成功通知
  - 触发后续业务流程

#### event.error

- **触发时机**：任务执行失败时（包括重试后仍然失败）
- **参数**：
  - id: number - 任务ID
  - err: Error - 错误信息
- **使用场景**：
  - 记录错误日志
  - 发送失败告警
  - 执行补偿逻辑
  - 更新任务状态

#### event.progress

- **触发时机**：任务执行过程中调用 Progress 处理器时
- **参数**：
  - id: number - 任务ID
  - current: number - 当前进度
  - total: number - 总进度
  - message: string - 进度信息
- **使用场景**：
  - 更新任务进度显示
  - 记录执行过程日志
  - 实时反馈任务状态

### 事件处理器示例

```javascript
/**
 * 生成任务唯一ID
 * @returns {number} 任务ID
 */
function NextID() {
  // 使用时间戳和随机数生成唯一ID
  const timestamp = Date.now();
  const random = Math.floor(Math.random() * 1000);
  return parseInt(`${timestamp}${random}`);
}

/**
 * 任务添加时的回调
 * @param {number} id 任务ID
 */
function OnAdd(id) {
  // 记录任务创建日志
  console.log(`Task #${id} created at ${new Date().toISOString()}`);

  // 更新任务状态
  Process('models.task.save', {
    id: id,
    status: 'created',
    created_at: new Date().toISOString()
  });
}

/**
 * 任务成功回调
 * @param {number} id 任务ID
 * @param {any} res 任务结果
 */
function OnSuccess(id, res) {
  // 更新业务状态
  Process('models.task.save', {
    id: id,
    status: 'completed',
    result: res,
    completed_at: new Date().toISOString()
  });

  // 发送成功通知
  Process('scripts.notification.send', {
    type: 'task_complete',
    task_id: id,
    result: res
  });
}

/**
 * 任务失败回调
 * @param {number} id 任务ID
 * @param {Error} err 错误信息
 */
function OnError(id, err) {
  // 记录错误日志
  console.error(`Task #${id} failed: ${err.message}`);

  // 更新任务状态
  Process('models.task.save', {
    id: id,
    status: 'failed',
    error: err.message,
    failed_at: new Date().toISOString()
  });

  // 发送失败告警
  Process('scripts.notification.send', {
    type: 'task_error',
    task_id: id,
    error: err.message,
    level: 'error'
  });
}

/**
 * 任务进度更新回调
 * @param {number} id 任务ID
 * @param {number} current 当前进度
 * @param {number} total 总进度
 * @param {string} message 进度信息
 */
function OnProgress(id, current, total, message) {
  // 计算进度百分比
  const percentage = Math.floor((current / total) * 100);

  // 更新任务进度
  Process('models.task.save', {
    id: id,
    progress: percentage,
    progress_message: message,
    updated_at: new Date().toISOString()
  });

  // 记录进度日志
  if (percentage % 10 === 0) {
    // 每完成10%记录一次
    console.log(`Task #${id}: ${percentage}% completed - ${message}`);
  }
}
```

## 任务处理器

在 `scripts` 目录下创建任务处理脚本（如：`scripts/task.js`）：

```javascript
// 如果是在响应api请求时，不要在脚本里使用全局变量
// 可以考虑使用session保存全局唯一的id
var id = 1024;

/**
 * 生成任务唯一ID
 * @returns {number} 任务ID
 */
function NextID() {
  id = id + 1;
  console.log(`NextID: ${id}`);
  return id;
}

/**
 * 任务处理器
 * @param {number} task_id 任务ID
 * @param {...any} args 任务参数
 */
function Send(task_id, ...args) {
  console.log(args);

  // 任务处理逻辑
  const current = 1;
  const total = 100;

  // 更新任务进度
  Progress(
    'tasks.task.process',
    task_id,
    current,
    total,
    `Progress ${current}/${total}`
  );

  return { message: 'ok' };
}

/**
 * 任务添加时的回调
 * @param {number} id 任务ID
 */
function OnAdd(id) {
  console.log(`OnAdd: #${id}`);
}

/**
 * 任务进度更新回调
 * @param {number} id 任务ID
 * @param {number} current 当前进度
 * @param {number} total 总进度
 * @param {string} message 进度信息
 */
function OnProgress(id, current, total, message) {
  console.log(`OnProgress: #${id} ${message} ${current}/${total}`);
}

/**
 * 任务成功回调
 * @param {number} id 任务ID
 * @param {any} res 任务结果
 */
function OnSuccess(id, res) {
  console.log(`OnSuccess: #${id} ${JSON.stringify(res)}`);
}

/**
 * 任务失败回调
 * @param {number} id 任务ID
 * @param {Error} err 错误信息
 */
function OnError(id, err) {
  console.log(`OnError: #${id} ${err}`);
}
```

## 任务处理流程

1. 添加任务
   - 使用 `tasks.[task_id].add` 处理器添加任务
   - 可传入任务处理器所需的参数
   - 返回任务ID（成功）或0（失败）

2. 任务状态更新
   - 使用 `tasks.[task_id].progress` 处理器更新任务进度
   - 在任务处理器内部调用
   - 会触发 event.progress 回调

3. 查询任务状态
   - 使用 `tasks.[task_id].get` 处理器获取任务状态
   - 返回任务的详细信息：
     ```javascript
     {
       id: task_id,
       status: '', // "WAITING"/"RUNNING"/"SUCCESS"/"FAILURE"
       current: number, // 当前进度
       total: number, // 总进度
       message: string, // 进度信息
       response: any // 任务结果
     }
     ```

## 高级API使用方法

### 批量任务管理

```javascript
/**
 * 批量添加任务
 */
function batchTaskManagement() {
  const taskIds = [];
  const batchSize = 50;

  // 批量添加任务
  for (let i = 1; i <= batchSize; i++) {
    const taskId = Process('tasks.data_process.add', `batch_${i}`, i);
    if (taskId > 0) {
      taskIds.push(taskId);
    } else {
      console.error(`任务 ${i} 添加失败`);
    }
  }

  console.log(`成功添加 ${taskIds.length} 个任务`);
  return taskIds; // 返回任务ID列表供后续查询
}

/**
 * 查询批量任务状态（需要外部定时调用）
 */
function checkBatchTaskStatus(taskIds) {
  let completedCount = 0;
  let successCount = 0;
  let failedCount = 0;
  const results = [];

  taskIds.forEach((taskId) => {
    try {
      const taskInfo = Process('tasks.data_process.get', taskId);
      if (taskInfo) {
        if (taskInfo.status === 'SUCCESS') {
          successCount++;
          results.push({
            id: taskId,
            status: 'success',
            result: taskInfo.response
          });
        } else if (taskInfo.status === 'FAILURE') {
          failedCount++;
          results.push({
            id: taskId,
            status: 'failed',
            error: taskInfo.response
          });
        } else {
          // 还在执行中
          results.push({
            id: taskId,
            status: taskInfo.status,
            progress: `${taskInfo.current}/${taskInfo.total}`
          });
        }
      } else {
        completedCount++; // 任务已完成并从内存清理
        results.push({ id: taskId, status: 'completed' });
      }
    } catch (err) {
      completedCount++; // 任务不存在说明已完成
      results.push({ id: taskId, status: 'completed' });
    }
  });

  const totalCompleted = completedCount + successCount + failedCount;
  const progress = Math.round((totalCompleted / taskIds.length) * 100);

  return {
    total: taskIds.length,
    completed: totalCompleted,
    success: successCount,
    failed: failedCount,
    progress: progress,
    results: results
  };
}
```

### 任务链式执行

```javascript
/**
 * 任务链执行器（需要外部定时调用）
 */
function createTaskChain(chainData) {
  return {
    data: chainData,
    currentIndex: 0,
    currentTaskId: null,
    status: 'ready'
  };
}

/**
 * 执行任务链的下一步
 */
function executeTaskChainStep(chain) {
  if (chain.currentIndex >= chain.data.length) {
    chain.status = 'completed';
    console.log('任务链执行完成');
    return { completed: true, message: '任务链执行完成' };
  }

  if (chain.status === 'running') {
    // 检查当前任务状态
    try {
      const taskInfo = Process('tasks.chain.get', chain.currentTaskId);
      if (taskInfo && taskInfo.status === 'SUCCESS') {
        chain.currentIndex++;
        chain.currentTaskId = null;
        chain.status = 'ready';
      } else if (taskInfo && taskInfo.status === 'FAILURE') {
        chain.status = 'failed';
        const task = chain.data[chain.currentIndex];
        return {
          error: true,
          message: `任务 ${task.type} 失败，停止任务链`,
          error_detail: taskInfo.response
        };
      } else {
        // 还在运行中
        return {
          running: true,
          message: `任务 ${chain.data[chain.currentIndex].type} 执行中...`
        };
      }
    } catch (err) {
      // 任务不存在，说明已完成
      chain.currentIndex++;
      chain.currentTaskId = null;
      chain.status = 'ready';
    }
  }

  if (chain.status === 'ready' && chain.currentIndex < chain.data.length) {
    // 启动下一个任务
    const task = chain.data[chain.currentIndex];
    const taskId = Process('tasks.chain.add', task.type, task.data);

    if (taskId > 0) {
      chain.currentTaskId = taskId;
      chain.status = 'running';
      console.log(`启动任务 ${task.type}, ID: ${taskId}`);
      return { started: true, taskId: taskId, task: task };
    } else {
      chain.status = 'failed';
      return { error: true, message: `无法添加任务 ${task.type}` };
    }
  }

  return { status: chain.status };
}

/**
 * 使用示例
 */
function taskChainExample() {
  const chainData = [
    { type: 'validate', data: 'user_data_001' },
    { type: 'process', data: 'processed_data_001' },
    { type: 'notify', data: 'notification_001' }
  ];

  const chain = createTaskChain(chainData);

  // 模拟外部定时调用
  const result = executeTaskChainStep(chain);
  console.log('任务链状态:', result);

  return chain;
}
```

### 任务超时和重试处理

```javascript
/**
 * 演示任务超时和重试机制
 */
function taskWithRetryAndTimeout() {
  // 配置具有重试机制的任务
  const taskConfig = {
    name: '重试任务示例',
    worker_nums: 5,
    attempts: 3, // 最多重试3次
    attempt_after: 1000, // 重试间隔1秒
    timeout: 10, // 超时时间10秒
    size: 100,
    process: 'scripts.unreliable_task.process',
    event: {
      error: 'scripts.unreliable_task.onError',
      success: 'scripts.unreliable_task.onSuccess'
    }
  };

  const taskId = Process('tasks.unreliable.add', 'test_data');
  console.log(`添加任务 ID: ${taskId}`);

  return taskId; // 返回任务ID供外部监控
}

/**
 * 检查任务重试状态（需要外部定时调用）
 */
function checkTaskRetryStatus(taskId) {
  try {
    const taskInfo = Process('tasks.unreliable.get', taskId);
    if (taskInfo) {
      console.log(`状态: ${taskInfo.status}, 消息: ${taskInfo.message}`);

      if (taskInfo.status === 'FAILURE') {
        return {
          completed: true,
          success: false,
          message: `任务最终失败: ${taskInfo.response}`
        };
      } else if (taskInfo.status === 'SUCCESS') {
        return {
          completed: true,
          success: true,
          message: `任务成功: ${taskInfo.response}`
        };
      } else {
        return {
          running: true,
          status: taskInfo.status,
          message: taskInfo.message
        };
      }
    } else {
      return { completed: true, message: '任务已清理' };
    }
  } catch (err) {
    return { completed: true, message: '任务不存在或已完成' };
  }
}
```

### 动态任务管理

```javascript
/**
 * 动态任务管理：根据系统负载动态调整任务执行
 */
function dynamicTaskManagement() {
  // 获取当前系统状态
  const systemStatus = Process('system.monitor.status');
  const activeTasks = systemStatus.active_tasks || 0;
  const maxTasks = systemStatus.max_tasks || 100;

  console.log(`当前活跃任务: ${activeTasks}, 最大任务数: ${maxTasks}`);

  // 根据负载情况决定是否添加新任务
  const pendingTasks = getPendingTasks(); // 获取待处理任务列表

  if (activeTasks < maxTasks * 0.8) {
    // 负载低于80%
    const tasksToAdd = Math.min(pendingTasks.length, maxTasks - activeTasks);

    for (let i = 0; i < tasksToAdd; i++) {
      const task = pendingTasks[i];
      const taskId = Process('tasks.dynamic.add', task.type, task.data);

      if (taskId > 0) {
        console.log(`添加动态任务 ${task.type}, ID: ${taskId}`);
        updateTaskStatus(task.id, 'queued', taskId);
      }
    }
  } else {
    console.log('系统负载过高，暂缓添加新任务');
  }
}

// 获取待处理任务
function getPendingTasks() {
  return Process('models.pending_tasks.list', { status: 'pending', limit: 20 });
}

// 更新任务状态
function updateTaskStatus(taskId, status, asyncTaskId = null) {
  Process('models.pending_tasks.update', taskId, {
    status: status,
    async_task_id: asyncTaskId,
    updated_at: new Date().toISOString()
  });
}
```

## 使用示例

### 基础示例

```javascript
function simpleTaskExample() {
  for (let i = 1; i < 100; i++) {
    const task_id = Process('tasks.test.add', '任务-' + i);
    if (task_id === 0) {
      console.log('添加任务失败');
      continue;
    }
    console.log(`添加任务成功：${task_id}`);
  }
}
```

### 完整的邮件发送示例

```javascript
/**
 * 邮件发送异步任务完整示例
 */

// 1. 添加邮件发送任务
function sendWelcomeEmail(userEmail, userName) {
  const taskId = Process('tasks.welcome_email.add', userEmail, userName);

  if (taskId > 0) {
    console.log(`欢迎邮件任务已添加，ID: ${taskId}`);

    // 返回任务ID供前端查询状态
    return {
      success: true,
      task_id: taskId,
      message: '邮件发送任务已添加到队列'
    };
  } else {
    return {
      success: false,
      message: '邮件发送任务添加失败，请稍后重试'
    };
  }
}

// 2. 查询邮件发送状态
function checkEmailStatus(taskId) {
  try {
    const taskInfo = Process('tasks.welcome_email.get', taskId);

    if (taskInfo) {
      return {
        success: true,
        status: taskInfo.status,
        progress: {
          current: taskInfo.current,
          total: taskInfo.total,
          percentage: Math.round((taskInfo.current / taskInfo.total) * 100)
        },
        message: taskInfo.message,
        result: taskInfo.response
      };
    } else {
      return {
        success: false,
        message: '任务不存在或已完成'
      };
    }
  } catch (err) {
    return {
      success: false,
      message: '查询任务状态失败: ' + err.message
    };
  }
}

// 3. API集成示例
function apiHandler(request) {
  const { action, task_id, email, name } = request;

  switch (action) {
    case 'send':
      return sendWelcomeEmail(email, name);

    case 'status':
      return checkEmailStatus(task_id);

    default:
      return { success: false, message: '无效的操作' };
  }
}
```

## 测试用例

### 基础功能测试

```javascript
/**
 * 基础任务添加和状态查询测试 - 启动测试
 */
function basicTaskTest_start() {
  console.log('开始基础任务测试...');

  // 1. 添加任务
  const taskId = Process('tasks.test.add', 'test_data', 123);
  console.log(`添加任务 ID: ${taskId}`);

  if (taskId === 0) {
    console.error('任务添加失败');
    return null;
  }

  // 2. 立即查询任务状态（应该是WAITING）
  let taskInfo = Process('tasks.test.get', taskId);
  console.log('初始状态:', taskInfo);
  // 预期: { status: "WAITING", current: 0, total: 0, message: "" }

  return taskId; // 返回任务ID供后续监控使用
}

/**
 * 基础功能测试 - 检查状态（需要外部定时调用）
 */
function basicTaskTest_check(taskId, checkPhase = 1) {
  try {
    const taskInfo = Process('tasks.test.get', taskId);

    if (taskInfo) {
      if (checkPhase === 1) {
        console.log('运行中状态:', taskInfo);
        // 预期: { status: "RUNNING", current: >0, total: >0, message: "Progress x/y" }
        return { running: true, phase: 1, info: taskInfo };
      } else if (checkPhase >= 2) {
        console.log('最终状态:', taskInfo);
        if (taskInfo.status === 'SUCCESS' || taskInfo.status === 'FAILURE') {
          return {
            completed: true,
            status: taskInfo.status,
            result: taskInfo.response
          };
        }
        return { running: true, phase: checkPhase, info: taskInfo };
      }
    }
  } catch (err) {
    console.log('任务已完成并清理');
    return { completed: true, status: 'cleaned' };
  }

  return { running: true, phase: checkPhase };
}
```

````

### 并发任务测试

```javascript
/**
 * 并发任务执行测试 - 添加任务阶段
 */
function concurrentTaskTest_add() {
  const taskCount = 20;
  console.log(`开始并发测试: ${taskCount} 个任务`);

  // 快速添加多个任务
  const taskIds = [];
  for (let i = 1; i <= taskCount; i++) {
    const taskId = Process('tasks.concurrent.add', `JOB_${i}`, i);
    if (taskId > 0) {
      taskIds.push(taskId);
      console.log(`任务 ${i} 添加成功，ID: ${taskId}`);
    } else {
      console.error(`任务 ${i} 添加失败`);
    }
  }

  console.log(`成功添加 ${taskIds.length} 个任务`);
  return taskIds; // 返回任务ID列表供监控使用
}

/**
 * 并发任务执行测试 - 监控阶段（需要外部定时调用）
 */
function concurrentTaskTest_monitor(taskIds, checkCount = 0) {
  let completedCount = 0;
  let successCount = 0;
  let failedCount = 0;
  let runningCount = 0;
  let waitingCount = 0;
  const results = {};

  taskIds.forEach(taskId => {
    try {
      const taskInfo = Process('tasks.concurrent.get', taskId);
      if (taskInfo) {
        switch (taskInfo.status) {
          case 'SUCCESS':
            successCount++;
            completedCount++;
            break;
          case 'FAILURE':
            failedCount++;
            completedCount++;
            break;
          case 'RUNNING':
            runningCount++;
            break;
          case 'WAITING':
            waitingCount++;
            break;
        }

        // 记录详细结果（用于验证）
        if (taskInfo.status === 'SUCCESS' || taskInfo.status === 'FAILURE') {
          results[taskId] = {
            status: taskInfo.status,
            response: taskInfo.response,
            message: taskInfo.message
          };
        }
      }
    } catch (err) {
      // 任务不存在，说明已完成
      completedCount++;
    }
  });

  const newCheckCount = checkCount + 1;
  console.log(`检查 ${newCheckCount}: 等待 ${waitingCount}, 运行 ${runningCount}, 成功 ${successCount}, 失败 ${failedCount}, 完成 ${completedCount}/${taskIds.length}`);

  // 所有任务完成
  if (completedCount === taskIds.length) {
    // 输出测试结果
    const testResults = {
      total: taskIds.length,
      success: successCount,
      failed: failedCount,
      success_rate: Math.round((successCount / taskIds.length) * 100),
      details: results
    };

    console.log('\n=== 并发测试结果 ===');
    console.log(`总任务数: ${testResults.total}`);
    console.log(`成功任务: ${testResults.success}`);
    console.log(`失败任务: ${testResults.failed}`);
    console.log(`成功率: ${testResults.success_rate}%`);

    // 验证并发效果（应该看到任务同时运行）
    console.log('\n详细结果:');
    Object.keys(results).forEach(taskId => {
      const result = results[taskId];
      console.log(`任务 ${taskId}: ${result.status} - ${result.message}`);
    });

    return { completed: true, results: testResults };
  }

  // 超时保护
  if (newCheckCount > 30) { // 30秒超时
    console.error('测试超时');
    return { timeout: true, message: '测试超时' };
  }

  return {
    running: true,
    check_count: newCheckCount,
    waiting: waitingCount,
    running: runningCount,
    success: successCount,
    failed: failedCount,
    completed: completedCount
  };
}
````

### 进度更新测试

```javascript
/**
 * 任务进度更新功能测试 - 启动任务
 */
function progressUpdateTest_start() {
  const totalSteps = 5;
  const stepDelay = 800; // 每步800ms，总时间4秒

  console.log(`开始进度测试: ${totalSteps} 步，每步 ${stepDelay}ms`);

  // 添加模拟任务
  const taskId = Process('tasks.progress_test.add', totalSteps, stepDelay);
  console.log(`进度测试任务 ID: ${taskId}`);

  if (taskId === 0) {
    console.error('任务添加失败');
    return null;
  }

  return taskId; // 返回任务ID供监控使用
}

/**
 * 任务进度更新功能测试 - 监控阶段（需要外部定时调用）
 */
function progressUpdateTest_monitor(
  taskId,
  lastProgress = { current: 0, total: 0 }
) {
  try {
    const taskInfo = Process('tasks.progress_test.get', taskId);

    if (taskInfo) {
      console.log(
        `进度: ${taskInfo.current}/${taskInfo.total} (${Math.round((taskInfo.current / taskInfo.total) * 100)}%) - ${taskInfo.message}`
      );

      // 检查进度是否正常递增
      if (taskInfo.current < lastProgress.current) {
        console.error('进度异常：当前进度小于上次进度');
      }

      if (taskInfo.status === 'SUCCESS') {
        return {
          completed: true,
          success: true,
          message: '任务成功完成',
          result: taskInfo.response
        };
      } else if (taskInfo.status === 'FAILURE') {
        return {
          completed: true,
          success: false,
          message: '任务执行失败',
          error: taskInfo.response
        };
      }

      return {
        running: true,
        progress: {
          current: taskInfo.current,
          total: taskInfo.total,
          percentage: Math.round((taskInfo.current / taskInfo.total) * 100),
          message: taskInfo.message
        }
      };
    } else {
      return { completed: true, message: '任务已完成并清理' };
    }
  } catch (err) {
    return { completed: true, message: '任务已清理: ' + err.message };
  }
}
```

### 错误处理测试

```javascript
/**
 * 错误处理和重试机制测试 - 启动任务
 */
function errorHandlingTest_start() {
  console.log('开始错误处理测试...');

  const testTasks = {};

  // 测试1: 添加无效参数的任务
  console.log('\n=== 测试1: 无效参数 ===');
  const invalidTaskId = Process('tasks.error_test.add', null, undefined);
  console.log(`无效任务 ID: ${invalidTaskId}`);
  if (invalidTaskId > 0)
    testTasks.invalid = { id: invalidTaskId, name: '无效任务' };

  // 测试2: 添加会抛出异常的任务
  console.log('\n=== 测试2: 执行时异常 ===');
  const errorTaskId = Process(
    'tasks.error_test.add',
    'throw_error',
    'test data'
  );
  console.log(`异常任务 ID: ${errorTaskId}`);
  if (errorTaskId > 0) testTasks.error = { id: errorTaskId, name: '异常任务' };

  // 测试3: 超时任务
  console.log('\n=== 测试3: 任务超时 ===');
  const timeoutTaskId = Process('tasks.timeout_test.add', 15); // 15秒任务，但超时设置为5秒
  console.log(`超时任务 ID: ${timeoutTaskId}`);
  if (timeoutTaskId > 0)
    testTasks.timeout = { id: timeoutTaskId, name: '超时任务' };

  return testTasks; // 返回测试任务列表供监控使用
}

/**
 * 错误处理测试 - 监控阶段（需要外部定时调用）
 */
function errorHandlingTest_monitor(testTasks, checkCounts = {}) {
  const results = {};
  let allCompleted = true;

  Object.keys(testTasks).forEach((testType) => {
    const task = testTasks[testType];
    const checkCount = (checkCounts[testType] || 0) + 1;
    checkCounts[testType] = checkCount;

    try {
      const taskInfo = Process('tasks.error_test.get', task.id);

      if (taskInfo) {
        console.log(
          `${task.name} - 状态: ${taskInfo.status}, 消息: ${taskInfo.message}`
        );

        if (taskInfo.status === 'FAILURE') {
          console.log(`${task.name} 失败原因: ${taskInfo.response}`);
          results[testType] = {
            completed: true,
            status: 'failed',
            reason: taskInfo.response
          };
        } else if (taskInfo.status === 'SUCCESS') {
          console.log(`${task.name} 意外成功: ${taskInfo.response}`);
          results[testType] = {
            completed: true,
            status: 'success',
            result: taskInfo.response
          };
        } else {
          allCompleted = false;
          results[testType] = {
            running: true,
            status: taskInfo.status,
            message: taskInfo.message
          };
        }
      }
    } catch (err) {
      console.log(`${task.name} 已清理`);
      results[testType] = {
        completed: true,
        status: 'cleaned',
        message: '任务已清理'
      };
    }

    // 超时保护
    if (checkCount > 20) {
      console.log(`${task.name} 监控超时`);
      results[testType] = {
        completed: true,
        status: 'timeout',
        message: '监控超时'
      };
    }
  });

  return {
    all_completed: allCompleted,
    results: results,
    check_counts: checkCounts
  };
}
```

### 性能压力测试

```javascript
/**
 * 任务系统性能压力测试 - 初始化
 */
function performanceStressTest_init() {
  const config = {
    taskCount: 1000, // 总任务数
    batchSize: 50, // 每批添加任务数
    batchInterval: 100, // 批次间隔（ms）
    workerNums: 20, // 工作进程数
    checkInterval: 2000, // 状态检查间隔
    maxWaitTime: 60000 // 最大等待时间
  };

  console.log(
    `开始性能测试: ${config.taskCount} 个任务，${config.workerNums} 个工作进程`
  );
  console.log(
    `配置: 批次大小 ${config.batchSize}，批次间隔 ${config.batchInterval}ms`
  );

  return {
    config: config,
    startTime: Date.now(),
    taskIds: [],
    batchesAdded: 0,
    lastCompleted: 0,
    status: 'adding'
  };
}

/**
 * 性能压力测试 - 添加批次任务
 */
function performanceStressTest_addBatch(testState) {
  const config = testState.config;
  const startIdx = testState.batchesAdded * config.batchSize;
  const endIdx = Math.min(startIdx + config.batchSize, config.taskCount);

  if (startIdx >= config.taskCount) {
    console.log(`所有 ${config.taskCount} 个任务添加完成，开始监控`);
    testState.status = 'monitoring';
    return testState;
  }

  console.log(
    `添加第 ${testState.batchesAdded + 1} 批任务 (${startIdx + 1}-${endIdx})`
  );

  for (let i = startIdx; i < endIdx; i++) {
    const taskId = Process('tasks.stress.add', `stress_task_${i}`, i);
    if (taskId > 0) {
      testState.taskIds.push(taskId);
    }
  }

  testState.batchesAdded++;
  return testState;
}

/**
 * 性能压力测试 - 监控阶段（需要外部定时调用）
 */
function performanceStressTest_monitor(testState) {
  const config = testState.config;
  let completedCount = 0;
  let successCount = 0;
  let failedCount = 0;
  let currentActive = 0;

  testState.taskIds.forEach((taskId) => {
    try {
      const taskInfo = Process('tasks.stress.get', taskId);
      if (taskInfo) {
        if (taskInfo.status === 'SUCCESS') successCount++;
        else if (taskInfo.status === 'FAILURE') failedCount++;
        else currentActive++;
      }
    } catch (err) {
      completedCount++;
    }
  });

  completedCount += successCount + failedCount;
  const completionRate = Math.round((completedCount / config.taskCount) * 100);
  const throughput = completedCount - testState.lastCompleted;
  const elapsedTime = (Date.now() - testState.startTime) / 1000;
  const avgThroughput = Math.round(completedCount / elapsedTime);

  console.log(
    `进度: ${completionRate}% (${completedCount}/${config.taskCount}) ` +
      `成功: ${successCount} 失败: ${failedCount} 活跃: ${currentActive} ` +
      `吞吐量: ${throughput}/${config.checkInterval / 1000}s 平均: ${avgThroughput}/s`
  );

  testState.lastCompleted = completedCount;

  if (completedCount === config.taskCount) {
    const totalTime = (Date.now() - testState.startTime) / 1000;
    const results = {
      status: 'completed',
      total_tasks: config.taskCount,
      success_tasks: successCount,
      failed_tasks: failedCount,
      success_rate: Math.round((successCount / config.taskCount) * 100),
      total_time: totalTime,
      avg_throughput: Math.round(config.taskCount / totalTime)
    };

    console.log(`\n=== 性能测试完成 ===`);
    console.log(`总任务数: ${results.total_tasks}`);
    console.log(`成功任务: ${results.success_tasks}`);
    console.log(`失败任务: ${results.failed_tasks}`);
    console.log(`成功率: ${results.success_rate}%`);
    console.log(`总耗时: ${results.total_time}s`);
    console.log(`平均吞吐量: ${results.avg_throughput} 任务/秒`);

    return { completed: true, results: results };
  }

  if (Date.now() - testState.startTime > config.maxWaitTime) {
    console.error('性能测试超时');
    return { timeout: true, message: '性能测试超时' };
  }

  return {
    running: true,
    completion_rate: completionRate,
    success: successCount,
    failed: failedCount,
    active: currentActive,
    throughput: throughput,
    avg_throughput: avgThroughput
  };
}
```

### 综合测试套件

```javascript
/**
 * 完整的任务系统测试套件 - 初始化
 */
function runTestSuite_init() {
  console.log('=== 开始任务系统测试套件 ===\n');

  const tests = [
    { name: '基础功能测试', type: 'basic', status: 'pending' },
    { name: '并发任务测试', type: 'concurrent', status: 'pending' },
    { name: '进度更新测试', type: 'progress', status: 'pending' },
    { name: '错误处理测试', type: 'error', status: 'pending' },
    { name: '性能压力测试', type: 'stress', status: 'pending' }
  ];

  return {
    tests: tests,
    current_test: 0,
    test_data: {},
    status: 'running'
  };
}

/**
 * 运行指定测试
 */
function runTestSuite_run(suite, testIndex) {
  const test = suite.tests[testIndex];
  if (!test) return { completed: true, message: '所有测试完成' };

  console.log(`\n${'='.repeat(50)}`);
  console.log(`测试 ${testIndex + 1}/${suite.tests.length}: ${test.name}`);
  console.log(`${'='.repeat(50)}\n`);

  let result;

  try {
    switch (test.type) {
      case 'basic':
        result = basicTaskTest();
        break;
      case 'concurrent':
        result = concurrentTaskTest_add();
        suite.test_data.concurrent_taskIds = result;
        break;
      case 'progress':
        result = progressUpdateTest_start();
        suite.test_data.progress_taskId = result;
        break;
      case 'error':
        result = errorHandlingTest_start();
        suite.test_data.error_tasks = result;
        break;
      case 'stress':
        result = performanceStressTest_init();
        suite.test_data.stress_state = result;
        break;
      default:
        result = { error: true, message: '未知测试类型' };
    }

    test.status = 'running';
    return { started: true, test: test, result: result };
  } catch (err) {
    console.error(`测试 ${test.name} 执行失败:`, err);
    test.status = 'failed';
    return {
      error: true,
      message: `测试 ${test.name} 执行失败: ${err.message}`
    };
  }
}

/**
 * 检查测试状态
 */
function runTestSuite_check(suite, testIndex) {
  const test = suite.tests[testIndex];
  if (!test) return { completed: true, message: '所有测试完成' };

  let result;

  try {
    switch (test.type) {
      case 'concurrent':
        result = concurrentTaskTest_monitor(suite.test_data.concurrent_taskIds);
        if (result.completed || result.timeout) {
          test.status = result.completed ? 'completed' : 'timeout';
        }
        break;
      case 'progress':
        result = progressUpdateTest_monitor(suite.test_data.progress_taskId);
        if (result.completed) {
          test.status = result.success ? 'completed' : 'failed';
        }
        break;
      case 'error':
        result = errorHandlingTest_monitor(
          suite.test_data.error_tasks,
          suite.test_data.error_check_counts || {}
        );
        if (result.all_completed) {
          test.status = 'completed';
          suite.test_data.error_results = result.results;
        }
        suite.test_data.error_check_counts = result.check_counts;
        break;
      case 'stress':
        if (suite.test_data.stress_state.status === 'adding') {
          suite.test_data.stress_state = performanceStressTest_addBatch(
            suite.test_data.stress_state
          );
        } else {
          result = performanceStressTest_monitor(suite.test_data.stress_state);
          if (result.completed || result.timeout) {
            test.status = result.completed ? 'completed' : 'timeout';
          }
        }
        break;
      default:
        test.status = 'completed';
    }

    return result;
  } catch (err) {
    console.error(`检查测试 ${test.name} 状态失败:`, err);
    test.status = 'failed';
    return { error: true, message: `检查测试状态失败: ${err.message}` };
  }
}

/**
 * 导出测试函数
 */
const TestSuite = {
  basicTaskTest: basicTaskTest,
  concurrentTaskTest_add: concurrentTaskTest_add,
  concurrentTaskTest_monitor: concurrentTaskTest_monitor,
  progressUpdateTest_start: progressUpdateTest_start,
  progressUpdateTest_monitor: progressUpdateTest_monitor,
  errorHandlingTest_start: errorHandlingTest_start,
  errorHandlingTest_monitor: errorHandlingTest_monitor,
  performanceStressTest_init: performanceStressTest_init,
  performanceStressTest_addBatch: performanceStressTest_addBatch,
  performanceStressTest_monitor: performanceStressTest_monitor,
  runTestSuite_init: runTestSuite_init,
  runTestSuite_run: runTestSuite_run,
  runTestSuite_check: runTestSuite_check
};
```

## 最佳实践

1. 任务设计
   - 将耗时操作从主流程中剥离
   - 任务应该是独立且原子的
   - 考虑任务的幂等性

2. 资源管理
   - 根据服务器资源合理设置 worker_nums
   - 设置合适的任务超时时间
   - 控制任务队列大小

3. 错误处理
   - 实现完善的重试机制
   - 记录详细的错误日志
   - 设置合理的重试间隔

4. 监控告警
   - 监控任务队列大小
   - 监控任务执行时间
   - 监控失败率和重试情况

5. 性能优化
   - 合理配置批次大小和并发数
   - 使用分批处理避免内存峰值
   - 定期清理已完成任务的引用
   - 监控系统资源使用情况

## 技术实现细节

### 任务池架构

基于源代码分析，Yao的任务系统采用了经典的Producer-Consumer模式：

```
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│   任务添加者    │───→│    任务队列       │───→│    工作进程     │
│                │    │   (jobque)       │    │   (Worker)     │
│ Process().add  │    │                  │    │                │
└─────────────────┘    └──────────────────┘    └─────────────────┘
                              ↑                        ↓
                       ┌──────────────────┐    ┌─────────────────┐
                       │    工作队列       │←───│   任务执行器     │
                       │  (workerque)     │    │   Handler.Exec  │
                       └──────────────────┘    └─────────────────┘
```

### 核心组件详解

#### 1. 任务池 (Pool)

```go
type Pool struct {
    size      int           // 工作进程数量
    max       int           // 队列最大长度
    jobque    chan *Job     // 任务队列
    workerque chan *Worker  // 工作进程队列
}
```

**特性说明：**

- **双通道设计**: `jobque` 用于传递任务，`workerque` 用于管理空闲工作进程
- **缓冲机制**: 两个通道都有缓冲区，提高并发性能
- **容量限制**: `max` 参数控制任务队列的最大容量，防止内存溢出

#### 2. 工作进程 (Worker)

```go
type Worker struct {
    job chan *Job  // 接收任务的通道
}
```

**工作流程：**

1. 工作进程启动后，将自己放入 `workerque` 等待任务
2. 从 `jobque` 中获取任务
3. 在独立的 goroutine 中执行任务
4. 执行完成后，重新回到 `workerque` 等待下一个任务

#### 3. 任务 (Job)

```go
type Job struct {
    id       int              // 任务唯一标识
    ctx      context.Context  // 上下文，支持超时和取消
    cancel   context.CancelFunc // 取消函数
    timeout  time.Duration    // 超时时间
    curr     int              // 当前进度
    total    int              // 总进度
    status   int              // 任务状态
    message  string          // 进度信息
    response interface{}     // 执行结果
    args     []interface{}    // 任务参数
}
```

### 并发控制机制

#### 1. Goroutine 管理

```go
// 启动工作进程
for i := 0; i < t.pool.size; i++ {
    w := createWorker()
    t.startWorker(w)  // 每个工作进程一个 goroutine
}

// 任务调度循环
for {
    select {
    case job := <-t.pool.jobque:
        worker := <-t.pool.workerque
        worker.job <- job
    case <-interrupt:
        return  // 优雅关闭
    case <-t.ctx.Done():
        return  // 上下文取消
    }
}
```

**并发特点：**

- **固定工作进程数**: 最多同时执行 `worker_nums` 个任务
- **任务队列缓冲**: 未执行的任务在队列中等待
- **非阻塞调度**: 使用 `select` 实现多路复用

#### 2. 上下文管理

```go
// 任务超时控制
timeout := time.Duration(t.timeout) * time.Second
ctx, cancel := context.WithTimeout(context.Background(), timeout)
job := &Job{
    id:      id,
    args:    args,
    timeout: timeout,
    ctx:     ctx,
    cancel:  cancel,
}
```

**超时机制：**

- **全局超时**: 每个任务都有独立的超时时间
- **自动取消**: 超时后自动调用 `cancel()` 清理资源
- **级联取消**: 任务取消会触发工作进程重置

#### 3. 线程安全

```go
type Task struct {
    jobs  map[int]*Job
    mutex sync.Mutex  // 保护 jobs 映射
    // ...
}

// 添加任务时的锁保护
func (t *Task) Add(args ...interface{}) (int, error) {
    t.mutex.Lock()
    defer t.mutex.Unlock()
    // ...
}
```

**安全措施：**

- **互斥锁**: 保护共享数据结构（如 jobs 映射）
- **原子操作**: 任务ID生成使用原子递增
- **通道同步**: 使用 channel 进行 goroutine 间通信

### 性能优化策略

#### 1. 批量任务处理

```javascript
// 推荐：分批添加任务 - 准备阶段
function addBatchTasks_prepare(tasks, batchSize = 50, delay = 100) {
  const batches = [];
  for (let i = 0; i < tasks.length; i += batchSize) {
    batches.push({
      tasks: tasks.slice(i, i + batchSize),
      delay: Math.floor(i / batchSize) * delay
    });
  }
  return batches; // 返回批次列表供外部分批执行
}

// 执行指定批次
function addBatchTasks_execute(batches, batchIndex) {
  if (batchIndex >= batches.length) {
    return { completed: true, message: '所有批次执行完成' };
  }

  const batch = batches[batchIndex];
  console.log(
    `执行批次 ${batchIndex + 1}/${batches.length}，延迟 ${batch.delay}ms`
  );

  batch.tasks.forEach((task) => {
    Process('tasks.batch.add', task);
  });

  return {
    batch_completed: true,
    batch_index: batchIndex,
    next_batch: batchIndex + 1,
    delay: batch.delay
  };
}

// 避免：一次性添加大量任务
function badExample(tasks) {
  tasks.forEach((task) => {
    Process('tasks.batch.add', task); // 可能导致队列溢出
  });
}
```

#### 2. 内存优化

```javascript
// 及时清理任务引用 - 检查函数（需要外部定时调用）
function monitorTasks_check(taskIds, activeTasks) {
  if (!activeTasks) {
    activeTasks = new Set(taskIds);
  }

  const completedTasks = [];

  activeTasks.forEach((taskId) => {
    try {
      const info = Process('tasks.example.get', taskId);
      if (info && (info.status === 'SUCCESS' || info.status === 'FAILURE')) {
        completedTasks.push(taskId); // 标记为已完成
      }
    } catch (err) {
      completedTasks.push(taskId); // 任务不存在，已清理
    }
  });

  // 清理已完成任务
  completedTasks.forEach((taskId) => {
    activeTasks.delete(taskId);
  });

  return {
    active_tasks: Array.from(activeTasks),
    completed_count: completedTasks.length,
    remaining_count: activeTasks.size
  };
}
```

#### 3. 工作进程调优

```javascript
// 动态调整工作进程数（伪代码）
function optimizeWorkerNums() {
  const systemLoad = Process('system.monitor.load');
  const avgTaskTime = Process('tasks.statistics.avg_time');
  const queueLength = Process('tasks.queue.length');

  let optimalWorkers;

  if (queueLength > 100 && systemLoad < 0.7) {
    // 队列积压，系统负载低，增加工作进程
    optimalWorkers = Math.min(currentWorkers * 1.5, maxWorkers);
  } else if (systemLoad > 0.9) {
    // 系统负载高，减少工作进程
    optimalWorkers = Math.max(currentWorkers * 0.8, minWorkers);
  } else {
    // 保持当前配置
    optimalWorkers = currentWorkers;
  }

  return Math.round(optimalWorkers);
}
```

## Yao v8go 引擎限制

### ⚠️ 重要技术限制

Yao使用v8go作为JavaScript引擎，有以下重要限制需要特别注意：

#### 1. 不支持异步JavaScript

- **不支持** `setTimeout()`, `setInterval()` 等定时器函数
- **不支持** `Promise`, `async/await` 等异步语法
- **不支持** 原生的事件循环机制

#### 2. 同步执行模式

所有JavaScript代码都是同步执行的：

```javascript
// ❌ 错误写法
function badExample() {
  setTimeout(() => {
    console.log('这不会执行');
  }, 1000);
}

// ✅ 正确写法 - 需要外部定时调用
function goodExample() {
  console.log('立即执行');
  return { status: 'completed', message: '需要外部轮询检查状态' };
}
```

#### 3. 任务监控实现方式

由于不支持异步，任务监控需要通过以下方式实现：

**方案1：外部定时器轮询**

```javascript
// 在其他支持异步的环境中使用
function monitorTask(taskId) {
  const interval = setInterval(() => {
    const result = goodExample(taskId); // 调用同步检查函数
    if (result.completed) {
      clearInterval(interval);
    }
  }, 1000);
}
```

**方案2：分阶段执行**

```javascript
// 在Yao内部使用状态机模式
function taskStateMachine(taskId, phase) {
  switch (phase) {
    case 'start':
      return startTask(taskId);
    case 'check':
      return checkTaskStatus(taskId);
    case 'complete':
      return completeTask(taskId);
    default:
      return { error: 'Unknown phase' };
  }
}
```

#### 4. 设计原则

基于v8go限制，任务系统设计应遵循：

1. **状态驱动**：使用状态机模式管理任务生命周期
2. **外部协调**：依赖外部系统进行定时和异步协调
3. **分步执行**：将复杂操作分解为多个同步步骤
4. **轮询检查**：通过定期调用来检查任务状态

### 监控和诊断

#### 1. 关键指标监控

```javascript
function getTaskMetrics() {
  return {
    queue_length: Process('tasks.metrics.queue_length'),
    active_workers: Process('tasks.metrics.active_workers'),
    waiting_jobs: Process('tasks.metrics.waiting_jobs'),
    running_jobs: Process('tasks.metrics.running_jobs'),
    success_rate: Process('tasks.metrics.success_rate'),
    avg_execution_time: Process('tasks.metrics.avg_execution_time'),
    error_rate: Process('tasks.metrics.error_rate')
  };
}
```

#### 2. 性能分析

```javascript
function analyzePerformance() {
  const metrics = getTaskMetrics();
  const analysis = {
    status: 'healthy',
    warnings: [],
    recommendations: []
  };

  // 队列积压分析
  if (metrics.queue_length > metrics.active_workers * 10) {
    analysis.warnings.push('任务队列积压严重');
    analysis.recommendations.push('考虑增加工作进程数或优化任务处理逻辑');
  }

  // 成功率分析
  if (metrics.success_rate < 0.9) {
    analysis.warnings.push('任务成功率过低');
    analysis.recommendations.push('检查任务处理器逻辑，增加错误处理');
  }

  // 执行时间分析
  if (metrics.avg_execution_time > 30000) {
    // 30秒
    analysis.warnings.push('平均执行时间过长');
    analysis.recommendations.push('优化任务处理逻辑或检查外部依赖');
  }

  return analysis;
}
```

### 故障排查指南

#### 1. 常见问题诊断

```javascript
// 检查任务系统状态
function diagnoseTaskSystem() {
  const issues = [];

  // 检查任务配置
  try {
    const taskConfig = Process('tasks.example.config');
    if (!taskConfig.process) {
      issues.push('任务处理器未配置');
    }
    if (taskConfig.worker_nums < 1) {
      issues.push('工作进程数配置无效');
    }
  } catch (err) {
    issues.push('任务配置加载失败: ' + err.message);
  }

  // 检查任务处理器
  try {
    Process('scripts.task.handler.health_check');
  } catch (err) {
    issues.push('任务处理器不可用: ' + err.message);
  }

  // 检查系统资源
  const systemStatus = Process('system.monitor.status');
  if (systemStatus.memory_usage > 0.9) {
    issues.push('内存使用率过高');
  }
  if (systemStatus.cpu_usage > 0.9) {
    issues.push('CPU使用率过高');
  }

  return {
    healthy: issues.length === 0,
    issues: issues,
    suggestions: generateFixSuggestions(issues)
  };
}
```

#### 2. 调试工具

```javascript
// 任务调试工具
function debugTask(taskId) {
  console.log(`=== 调试任务 ${taskId} ===`);

  try {
    const info = Process('tasks.example.get', taskId);
    console.log('任务信息:', info);

    // 检查任务配置
    const config = Process('tasks.example.config');
    console.log('任务配置:', config);

    // 检查处理器状态
    const handlerStatus = Process('scripts.task.handler.status');
    console.log('处理器状态:', handlerStatus);
  } catch (err) {
    console.error('调试失败:', err.message);

    // 尝试从日志中获取信息
    const logs = Process('logs.search', {
      keyword: `task_${taskId}`,
      limit: 20
    });
    console.log('相关日志:', logs);
  }
}
```
