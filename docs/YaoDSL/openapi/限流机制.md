# 限流配置文件解析

Yao 引擎中 `openapi/limits` 目录下的限流（Rate Limiting）配置和原理。这是构建高可用、生产级 AI 应用的关键组件，用于保护后端服务不被滥用。

根据项目yao-dev-app中openapi/limits目录下的配置文件以及 Yao 引擎底层的相关源码。结合 `yao-dev-app` 中的配置示例和 `yao` 核心库中的 ACL（访问控制列表）及中间件逻辑，为你深入解析。

### 分析思路

1.  **配置文件解析 (`limits.yml` & `jobs.yml`)**：分析配置文件的结构，包括默认限制、特定接口限制以及基于角色的限制（如 guest, premium）。
2.  **加载机制 (`openapi/config.go` & `acl` 包)**：分析 Yao 引擎是如何读取这些 YAML 文件的。
3.  **运行原理 (`guard.go` & `enforce.go`)**：深入 `Guard` 中间件和 `Enforce` 逻辑，解释请求进来时是如何被拦截、计数和校验的。
4.  **实战指导**：基于分析，总结如何在实际项目中配置和调试限流策略。

根据这些核心代码为整理详细的技术分析报告。

### Yao 引擎 Limits 配置文件与原理解析

基于 `yao-dev-app` 的配置和 `yao` 源码，Yao 引擎的限流机制是集成在 **OpenAPI OAuth/ACL 子系统** 中的。它不仅支持简单的全局限流，还支持精细化的**基于路由**和**基于角色**的动态限流策略。

#### 1\. 配置文件结构与语义

在 `openapi/limits` 目录下，你通常会看到两种类型的配置文件：全局默认配置（如 `limits.yml`）和针对特定资源的配置（如 `job/jobs.yml`）。

**A. 全局/通用配置 (`limits.yml`)**
这是基础的限流规则，通常定义了默认策略和基于路径的覆盖策略。

```yaml
# 默认策略：如果没有命中特定规则，应用此策略
default:
  minutes:
    GET: 100 # 每分钟允许 100 次 GET 请求
    POST: 50 # 每分钟允许 50 次 POST 请求
    # ... 其他方法

# 路由特定策略：优先级高于默认策略
endpoints:
  # 支持通配符 *
  GET /kb/*: # 所有 /kb/ 开头的 GET 请求
    minutes: 150
    hours: 1500
    days: 15000

  GET /kb/search: # 精确匹配，优先级最高
    minutes: 60
    # ...
```

**B. 基于角色的资源配置 (`job/jobs.yml`)**
Yao 支持根据用户的\*\*角色（Identity/Role）\*\*应用不同的限流策略。这在 SaaS 应用中非常有用（例如区分免费用户和付费用户）。

```yaml
# 角色：guest (游客/未登录或特定低权限角色)
guest:
  minutes:
    GET /job/jobs: 10

# 角色：default (普通登录用户)
default:
  minutes:
    GET /job/jobs: 30

# 角色：premium (付费用户)
premium:
  minutes:
    GET /job/jobs: 100
```

#### 2\. 底层实现原理 (Golang & ACL)

Yao 的限流逻辑主要发生在请求进入 `Guard` 中间件之后的 ACL 检查阶段。

**核心流程图解：**

1.  **Request In** -\> `openapi/oauth/guard.go` (Guard Middleware)
2.  **Authentication** -\> 验证 Token，获取用户信息 (User/Role)。
3.  **ACL Enforcement** -\> `openapi/oauth/acl/enforce.go` (Enforce 方法)。
4.  **Rate Limit Check** -\> 检查该用户/客户端在当前时间窗口内的请求计数。
5.  **Pass/Block** -\> 如果未超限，计数器+1并放行；否则返回 `429 Too Many Requests`。

**关键代码分析：**

- **入口 (`Guard` 中间件)**:
  在 `openapi/oauth/guard.go` 中，`Guard` 函数首先验证 Token，然后调用 `acl.Global.Enforce(c)`。

  ```go
  // openapi/oauth/guard.go
  func (s *Service) Guard(c *gin.Context) {
      // ... Token 验证 ...
      // Check permissions and enforce rate limits when ACL is configured
      ok, err := acl.Global.Enforce(c)
      if err != nil {
          s.handleACLError(c, err) // 如果限流报错，会在这里处理
          return
      }
      // ...
  }
  ```

- **执行检查 (`Enforce` 逻辑)**:
  在 `openapi/oauth/acl/enforce.go` 中，`Enforce` 方法会根据当前上下文（Token 信息、用户角色）构建 `AccessRequest`。
  虽然直接的代码片段主要展示了权限检查（Permission Check），但在完整的 ACL 实现中（基于 `acl.ErrorTypeRateLimitExceeded` 的错误处理逻辑），限流检查通常作为策略的一部分嵌入在 `acl.Scope` 或 `acl.Feature` 的检查流程中，或者是作为 `Enforce` 链条中的一个独立环节（取决于具体的 ACL 加载逻辑）。

- **错误处理 (`handleACLError`)**:
  当限流被触发时，底层会返回一个特定的错误类型 `acl.ErrorTypeRateLimitExceeded`。

  ```go
  // openapi/oauth/guard.go
  case acl.ErrorTypeRateLimitExceeded:
      statusCode = http.StatusTooManyRequests
      errResponse = types.ErrRateLimitExceeded
      // 会设置 Retry-After 头，告诉客户端多久后重试
      if aclErr.RetryAfter > 0 {
          c.Header("Retry-After", fmt.Sprintf("%d", aclErr.RetryAfter))
      }
  ```

#### 3\. 存储与计数

Yao 的限流状态是无状态服务中的关键。从代码结构看（引用 `openapi/config.go`），ACL 模块配置了 `Cache` 和 `Store`。

- **Redis/Cache**: 限流计数器（Counter）通常存储在 Redis 中（通过 `store.Get(config.Cache)` 获取）。
- **Key 的生成**: 计数器的 Key 通常由 `Prefix + UserID/IP + Endpoint + Window` 组成。这确保了限制是针对特定用户在特定接口上的。

#### 4\. 如何配置与调试

**使用建议：**

1.  **目录结构**：确保你的配置文件放在 `openapi/limits/` 目录下。Yao 启动时会递归扫描该目录。
2.  **优先级**：
    - **精确匹配** (`GET /kb/search`) 高于 **通配符匹配** (`GET /kb/*`)。
    - **角色配置** (`jobs.yml` 中的 `premium`) 往往结合用户的 Role 动态生效。确保你的用户模型和鉴权逻辑能正确返回 Role 字段。
3.  **调试**：
    - 如果遇到 `429` 错误，检查响应头中的 `Retry-After`。
    - 查看 `logs/yao.log`，搜索 `[ACL]` 相关的 Trace 日志（如代码中所示 `log.Trace("[ACL] ...")`），这能帮你看到请求具体匹配到了哪条规则。

**代码片段示例（模拟限流配置加载）：**

虽然具体的加载代码（`LoadLimits`）可能封装在 `acl` 包的初始化过程中，但你可以通过以下方式验证配置是否生效：

```yaml
# 在 limits.yml 中添加一个极低的限制进行测试
endpoints:
  GET /test/limit:
    minutes: 1 # 每分钟只允许 1 次
```

发起两次请求到 `/api/v1/test/limit`，第二次应收到 `429` 状态码。

## 关于特定限流算法（如滑动窗口 vs 固定窗口）的深入讨论，如何自定义限流存储后端

关于 **Yao 引擎中限流（Rate Limiting）算法的实现**，基于配置文件 (`limits.yml`) 和 Yao 引擎的底层架构 (`acl` 包及配置结构)，可以得出以下技术结论：

### 1\. 限流算法分析：固定窗口 (Fixed Window)

从 `limits.yml` 的配置结构来看，Yao 采用的是典型的 **基于时间窗口的计数器算法 (Fixed Window Counter)**，而非滑动窗口 (Sliding Window) 或漏桶/令牌桶算法。

**证据与原理：**

- **配置语义**：配置文件中明确使用了 `minutes`、`hours`、`days` 作为键。

  ```yaml
  default:
    minutes:
      GET: 100 # 每分钟 100 次
  ```

  这种配置方式通常对应于后端存储（如 Redis）中的一个带有过期时间（TTL）的计数器键。例如，对于 `minutes` 维度，Key 可能是 `rate:limit:GET:/path:2023-10-27-10:01`。当时间跨过这一分钟时，Key 变更为 `...:10:02`，计数器归零。

- **算法特点**：

  - **优点**：实现简单，内存/存储占用极低（只需存储当前窗口的计数），性能极高（O(1) 复杂度）。
  - **缺点**：存在“临界突发”问题（Boundary Burst）。例如，在 10:00:59 发送 100 个请求，在 10:01:01 又发送 100 个请求，虽然每分钟都符合限制，但在 2 秒内系统承受了 200 个请求。

### 2\. 限流的层级与处理流程

Yao 的限流是在 **ACL (Access Control List)** 层级进行处理的，位于路由处理之前。

1.  **全局 OAuth 限流**：
    在 `openapi/config.go` 和 `openapi/oauth/types/types.go` 中，定义了 `SecurityConfig`，包含 `RateLimitWindow` 和 `RateLimitRequests`。

    - 这是针对 OAuth 认证接口（如获取 Token）的保护。
    - 这是一个简单的 **单一窗口限制**（例如：每分钟允许 N 次）。

2.  **API 资源限流 (`limits.yml`)**：
    这是你重点关注的部分。虽然具体的加载代码封装在 Yao 的闭源或未展示的组件中（通常是 `gou` 框架的 `Rate` 中间件），但其处理逻辑如下：

    - **拦截点**：请求进入 `Guard` (卫兵) 中间件。
    - **身份识别**：通过 JWT 解析出 `UserID` 或 `IP`。
    - **规则匹配**：
      - 优先匹配 **特定路由** (`GET /kb/search`)。
      - 其次匹配 **通配符路由** (`GET /kb/*`)。
      - 最后回退到 **Default** 规则。
    - **多维度检查**：系统会同时检查 `minutes`、`hours` 和 `days` 的计数器。**只要有任何一个维度的计数超过阈值，请求就会被拒绝**。

### 3\. 存储机制

根据 `openapi/config.go` 的代码，OAuth 和 ACL 系统依赖于 `Store` (存储接口)：

```go
cacheStore, err := store.Get(config.Cache)
```

限流计数器通常存储在配置的 **Cache Store** 中（默认为 Redis 或内存）。

- **Key 的设计**：Key 通常由 `Prefix + Method + Path + Identity + TimeWindow` 组成。
- **原子性**：使用 Redis 的 `INCR` 和 `EXPIRE` 操作保证计数的原子性。

### 总结

Yao 目前使用的是 **固定窗口 (Fixed Window)** 限流算法。

- **配置方法**：在 `openapi/limits/` 下通过 YAML 定义时间粒度（分/时/日）。
- **适用场景**：适合绝大多数 API 防护场景，能有效防止持续的高频攻击。
- **注意**：如果你对流量平滑度有极高要求（需要精准的滑动窗口以消除临界突发），目前的固定窗口实现可能需要结合更细粒度的配置（如缩小时间窗口）来缓解。
