在 Yao 项目的 `tui/layout` 渲染引擎中，当前的实现已经具备了基础的 Flex、Grid 和 Absolute 布局能力，但在处理**复杂布局依赖**、**属性继承**以及**高性能局部刷新**方面，仍有类似早期 GUI 框架的局限性。

为了实现类似于 CSS 的复杂布局处理，建议从以下四个维度进行重构：

### 1. 引入双阶段布局计算 (Measure & Layout)

当前的 `layoutNode` 在递归过程中直接进行计算和坐标分配。CSS 引擎（如 Yoga）通常分为两个阶段：

- **测量阶段 (Measure Pass):** 从叶子节点向上递归，计算每个组件所需的最小/理想尺寸（Intrinsic Size）。
- **排列阶段 (Layout Pass):** 从根节点向下递归，根据父容器的剩余空间分配最终的 `Bound`。

**代码重构建议：**

```go
// 在 LayoutNode 中增加状态
type LayoutNode struct {
    // ... 原有属性
    MeasuredWidth  int
    MeasuredHeight int
}

// Engine 增加两个方法
func (e *Engine) measure(node *LayoutNode, availableWidth, availableHeight int)
func (e *Engine) arrange(node *LayoutNode, finalRect Rect)

```

### 2. 增强 Flexbox 算法的完整性

当前 `layoutFlex` 的实现较为简单，对 `JustifyContent`（如 `space-between`）和 `AlignItems` 的处理分布在不同的逻辑中，且缺乏对 `flex-shrink` 和 `flex-basis` 的精确支持。

- **改进分配逻辑：** 引入 `flex-basis` 作为初始尺寸，先扣除固定尺寸，再按 `flex-grow` 比例分配剩余正空间，或按 `flex-shrink` 比例缩小溢出空间。
- **多轴支持：** 目前主要处理主轴，交叉轴（Cross Axis）的拉伸（Stretch）逻辑需要更严谨的对齐计算。

### 3. 实现样式盒模型与单位转换 (Box Model)

目前样式处理散落在各处，单位支持仅限于 `int`。

- **引入 Value 类型：** 支持 `Percent`, `Auto`, `Pixel`, `Flex` 等单位，类似于 CSS。
- **统一盒模型：** 明确 `Margin` -> `Border` -> `Padding` -> `Content` 的层级。目前的 `calculateMetrics` 已经有了雏形，但应将其作为布局计算的输入而非结果。

```go
type StyleUnit int
const (
    UnitPixel StyleUnit = iota
    UnitPercent
    UnitAuto
    UnitFlex
)

type StyleValue struct {
    Value float64
    Unit  StyleUnit
}

```

### 4. 渲染优化：层叠上下文与局部刷新 (Z-Index & Dirty Tracking)

目前的 `Renderer` 在 `LayoutAbsolute` 下使用 `buffer`（类似 Canvas），在其他模式下使用 `lipgloss` 递归拼接（类似 DOM 渲染）。

- **统一渲染后端：** 建议全面采用虚拟画布（Virtual Canvas/Buffer）模式，这样可以轻松实现 `Z-Index` 覆盖、局部透明度和绝对定位叠加。
- **脏矩形检查：** `LayoutResult` 中虽有 `Dirties` 字段，但在 `Render` 阶段并未充分利用。应记录节点的位置变化或属性变化，只重新计算和绘制受影响的区域。

### 5. 架构解耦建议

- **样式与结构分离：** 引入类似 CSS 的 `StyleSheet` 对象，允许通过类名（Class）或 ID 批量应用样式，而不是在每个 `LayoutNode` 上手动硬编码 `LayoutStyle`。
- **集成 Lipgloss：** 将 `lipgloss.Style` 作为布局引擎的**输出**（用于计算边框、填充所占空间），而不是在渲染阶段才动态创建，以减少渲染开销。

### 总结

通过引入**双阶段测量算法**、**多单位支持**以及**虚拟画布渲染**，Yao 的 TUI 引擎可以从简单的堆叠布局演变为能够承载复杂仪表盘、弹出层和自适应窗口的高级布局系统。

基于对 Yao 项目中 `tui/layout` 目录及其核心文件的分析，当前的布局引擎虽然支持 Flex、Grid 和 Absolute 定位，但在处理**计算顺序、渲染效率和样式抽象**方面仍处于初级阶段。

为了实现类似 CSS 的复杂布局能力，以下是更具体的重构详细方案：

### 1. 布局计算模型重构：从“边走边算”到“双 Pass”

目前的 `layoutNode` 递归过程中直接分配坐标，这导致无法处理例如“父容器高度由子元素撑开，但子元素宽度又依赖父容器百分比”这类循环依赖。

- **详细重构建议：**
- **Measure Pass（测量阶段）：** 引入 `Measure(availableWidth, availableHeight int) Size` 方法。节点根据子元素的 `Intrinsic Size`（固有尺寸）计算并存储自己的 `MeasuredSize`。
- **Layout Pass（排列阶段）：** 引入 `Arrange(finalRect Rect)` 方法。在已知父容器确切尺寸后，计算 `Offset`（偏移量）并递归设置子元素的 `Bound`。
- **缓存机制：** 在 `LayoutNode` 中引入 `layoutCache`，如果输入的 `availableSize` 未变，直接返回测量结果，避免 TUI 频繁重绘带来的 CPU 抖动。

### 2. 盒模型（Box Model）的标准化

当前 `calculateMetrics` 已经开始计算 Padding 和 Margin，但没有将其深度集成到 Flex/Grid 的空间分配逻辑中。

- **详细重构建议：**
- **统一尺寸单位：** 扩展 `Size` 结构，支持 `Auto`（由内容撑开）、`Percent`（相对于父容器）、`Flexible`（类似 `flex: 1`）和 `Pixel`。
- **几何计算抽象：** 创建 `BoxConstraints` 结构体，包含 `Min/Max` 的宽高约束。所有布局逻辑（Flex/Grid）应基于 `BoxConstraints` 进行收缩或拉伸计算。
- **Border 支持：** 目前结构中预留了 `BorderWidth` 但未实现逻辑。应在 `Renderer` 中根据样式绘制字符边框，并从可用内容区域中扣除边框占用的行/列。

### 3. 增强型 Flexbox 算法

目前的 `layoutFlex` 仅实现了基础的主轴分配，缺乏对交叉轴对齐（Cross-axis alignment）的严谨处理。

- **详细重构建议：**
- **Flex-Basis/Grow/Shrink：** 严格遵循 CSS 规范。第一轮遍历计算总 `Basis`；若空间剩余，按 `Grow` 比例分配；若空间溢出，按 `Shrink` 比例缩小。
- **主轴对齐（JustifyContent）：** 完善 `SpaceBetween`、`SpaceAround` 和 `SpaceEvenly` 的数学间隔计算。
- **交叉轴对齐（AlignItems/AlignSelf）：** 实现 `Baseline` 对齐（这对 TUI 中不同字号/样式的文本行非常重要）和 `Stretch` 逻辑。

### 4. 渲染架构重构：引入“分层绘制”与“虚拟画布”

目前的 `Renderer` 在 Flex 布局下使用行拼接（Recursive Line-based），而在 Absolute 下使用 Runic Buffer。这种不统一导致无法在 Flex 容器中嵌套一个 Absolute 弹出层。

- **详细重构建议：**
- **统一采用虚拟画布（Virtual Canvas）：** 所有的 `Render` 最终都输出到一个全局的 `[][]rune` 缓冲区或经过优化的 `CellBuffer`。
- **层叠上下文（Stacking Context）：** 在 `LayoutNode` 中引入 `ZIndex` 属性。渲染引擎按 Z-Index 从小到大依次“盖章”到缓冲区，解决弹出层、阴影和遮罩问题。
- **脏矩形优化（Dirty Rect）：** 利用现有的 `Dirty` 标志位。只有 `Dirty` 节点及其受影响的邻居节点才触发重绘，减少对 `lipgloss` 的调用次数。

### 5. 样式系统的解耦与 CSS 模拟

目前的样式直接硬编码在 `LayoutNode` 的 `Style` 字段中。

- **详细重构建议：**
- **样式计算引擎：** 模仿 CSS 的级联（Cascading）特性。引入 `Theme` 定义全局样式，`Class` 定义组件样式，`Node.Style` 定义内联样式。布局前进行样式合并计算。
- **与 Lipgloss 深度集成：** `Renderer` 不应在运行时频繁创建 `lipgloss.Style`。应将计算后的颜色、边框、字体样式预先转换为 `lipgloss.Style` 对象并缓存，绘制阶段仅调用其 `Render` 方法。

### 建议重构路径：

1. **第一步：** 统一 `Renderer` 的后端，全部改用 Runic Buffer 模式，以支持 `Z-Index`。
2. **第二步：** 实现 `Measure/Arrange` 双阶段接口，重构 `layoutFlex` 算法。
3. **第三步：** 引入 `Auto` 和 `Percent` 单位支持，解决自适应布局问题。

基于对姚（Yao）项目中 `tui/layout` 源代码的深入分析，当前的重构目标应聚焦于构建一个**声明式、高性能、且支持复杂约束**的引擎。

以下是针对实现“类 CSS 布局处理”的详细重构路线图：

### 1. 核心数据结构的升级

目前的 `LayoutStyle` 仅支持基础属性。为了支持复杂布局，需要引入更精确的单位系统。

- **引入 `UnitValue` 类型：**
  不要直接使用 `int`，而是定义一个结构体来处理多种度量单位：

```go
type UnitType int
const (
    UnitAuto UnitType = iota // 由内容决定
    UnitPixel                // 绝对像素（字符数）
    UnitPercent              // 父容器百分比
    UnitFlex                 // 剩余空间权重 (flex: 1)
)

type UnitValue struct {
    Value float64
    Type  UnitType
}

```

- **扩展 `LayoutStyle` 属性：** 增加 `FlexShrink`、`FlexBasis`、`AspectRatio`（宽高比）以及更细致的 `Overflow` 处理逻辑。

### 2. 实现三阶段布局算法

当前的布局是在一次递归中完成测量和定位的，这无法解决相互依赖的尺寸计算。建议改为以下阶段：

1. **准备阶段 (Compute Styles)：**

- 处理样式继承和主题计算。
- 将所有相对单位（如百分比）转换为初步的约束条件。

2. **测量阶段 (Measure Pass - 自底向上)：**

- 每个节点根据子节点的 `Intrinsic Size` 计算自己的理想大小。
- 对于文本组件，需根据给定宽度计算折行后的高度。

3. **排列阶段 (Layout Pass - 自顶向下)：**

- 父节点根据测量结果和自身的约束（Box Constraints），决定子节点的最终 `Bound`（Rect）。
- 在此阶段处理 `JustifyContent` 中的 `SpaceBetween` 或 `Center` 等对齐逻辑。

### 3. 增强型 Flexbox 引擎实现

当前的 `layoutFlex` 缺乏对溢出和收缩的处理。

- **双轮空间分配：**
- **第一轮：** 统计所有具有 `flex-grow` 或 `flex-shrink` 属性的子节点。
- **第二轮：** 如果空间有剩余，按 `grow` 比例分配；如果空间不足，按 `shrink` 比例压缩。

- **交叉轴对齐（Cross Axis）：** 完善 `AlignItems` 逻辑。目前代码中对 `AlignStretch` 的实现较为简单，应强制子节点在交叉轴上填满父容器空间。

### 4. 统一渲染管线：虚拟画布（Virtual Canvas）

当前的 `Renderer` 分为“行拼接”和“全量缓冲”两种模式，这限制了布局的嵌套能力。

- **重构建议：** 统一使用类似 `LayoutAbsolute` 的 `renderToBuffer` 逻辑。
- **层叠上下文 (Stacking Context)：**
- 在 `LayoutNode` 中显式支持 `ZIndex`。
- 渲染顺序：背景 -> 边框 -> 内容 -> 子节点 -> 绝对定位覆盖层（如弹出菜单）。

- **字符级合成：** 使用一个全局的二维 `Cell` 数组，每个 `Cell` 包含字符、前景颜色、背景颜色和样式属性（如加粗、闪烁）。

### 5. 性能优化：局部更新与缓存

TUI 的性能瓶颈通常在于频繁的字符串操作和 ANSI 码计算。

- **布局缓存：** 在 `LayoutNode` 中存储上一次计算的约束和结果。如果父容器传入的可用宽高未变，直接跳过测量阶段。
- **脏矩形 (Dirty Rects)：**
- 利用现有的 `Dirty` 标志位。
- 只对 `Dirty` 节点对应的屏幕区域进行重新合成。
- 如果只有某个组件的数据更新（例如进度条），只重绘该组件的 `Bound` 区域。

### 6. 组件交互的解耦

目前的 `renderLayoutNode` 直接依赖于组件注册表。

- **解耦建议：** `LayoutEngine` 应只负责计算位置，它不应该知道组件是如何渲染的。它只需要知道组件的 `Min/Max` 尺寸。
- **渲染代理：** 定义一个 `Painter` 接口，布局结束后，由 `Renderer` 调用各组件的绘制方法将内容填入虚拟画布。

通过这些重构，姚项目的 TUI 将能够支持如**自适应侧边栏、流式响应布局、重叠弹出层**等高级视觉效果，性能也将足以应对大规模实时数据刷新的场景。

基于对 `tui/layout` 源代码的深度分析，当前的布局引擎在处理**动态内容（Dynamic Content）**、**约束传递（Constraint Propagation）**和**渲染隔离（Render Isolation）**方面仍有较大的提升空间。

以下是进一步深入的重构建议，侧重于底层机制的实现细节：

### 1. 引入严格的约束传递系统 (Constraints System)

当前的 `measureChildWidth/Height` 仅支持单一维度的计算。在处理复杂布局时，宽和高往往是耦合的（例如：文本组件的高度取决于分配给它的宽度）。

- **重构方案：** 借鉴 Flutter 的 `BoxConstraints` 模型。
- 定义 `Constraints` 结构体，包含 `minWidth, maxWidth, minHeight, maxHeight`。
- `Measure` 过程不再返回单一的 `Size`，而是接收父节点的 `Constraints` 并返回一个满足条件的 `Size`。
- **深度细节：** 这样可以解决类似“侧边栏固定宽度，右侧区域占据剩余所有空间，且内部文本根据剩余宽度自动折行”的经典 CSS 场景。

### 2. 样式计算的“层叠”逻辑重构 (Cascading Rules)

目前 `LayoutStyle` 属性散落在各处，缺乏继承和默认值的统一管理。

- **重构方案：** 实现真正的 `ComputedStyle`。
- **样式源优先级：** `内置默认值 < 外部 DSL 配置 < 组件私有样式 < 动画/交互态覆盖 (Hover/Focus)`。
- **解耦：** `LayoutNode` 不应直接持有可变的 `LayoutStyle`，而应持有 `StyleRules` 列表。在布局开始前的 **Compute Pass** 中，将所有的 Rule 合并为一份不可变的 `ComputedStyle`。
- **效益：** 这样可以轻松实现类似于 `body { color: white }` 的全局样式继承。

### 3. 基于单元格的虚拟画布渲染器 (Cell-based Virtual Canvas)

当前的渲染器在处理 `LayoutAbsolute` 时使用 `[][]rune` 缓冲区，但在处理 Flex 时却退化到了字符串拼接。这种不一致性导致无法实现复杂的 Z-Order 覆盖（如悬浮通知栏遮挡背景内容）。

- **重构方案：**
- 定义 `Cell` 结构：

```go
type Cell struct {
    Content  rune
    Style    lipgloss.Style // 包含前景色、背景色、属性
    NodeID   string         // 用于鼠标点击追踪
}

```

- **统一绘制后端：** 无论什么布局类型，所有组件最终都向这个 `[][]Cell` 的全局画布上“盖章”。
- **重叠逻辑：** 渲染循环按 `ZIndex` 遍历节点。如果位置冲突，高 `ZIndex` 的 `Cell` 直接替换低 `ZIndex` 的。

### 4. 引入生命周期钩子 (Layout Lifecycle)

目前的引擎是即时计算即时输出。为了支持类 CSS 的动画或动态交互，需要明确节点的生命周期。

- **重构方案：**
- `OnInit`: 组件初次加入布局树，进行数据初始化。
- `OnResize`: 窗口大小变化时触发。
- `OnUpdate`: 当 `Props` 或 `State` 改变时，仅标记该节点及其父节点为 `Dirty`。
- `OnLayout`: 布局位置确定后的回调，适合处理滚动偏移（Scroll Offset）。

### 5. 性能与脏区域检查 (Dirty Rect Optimization)

目前代码中虽有 `Dirty` 标志位和 `Dirties` 列表，但在 `Renderer` 中并未有效利用，依然是全量渲染。

- **重构方案：**
- **布局缓存：** `LayoutNode` 存储 `LastConstraints` 和 `LastResult`。如果约束未变，直接跳过子树计算。
- **增量渲染：** 在 `Renderer` 中维护两份 `CellBuffer`（当前的和上一帧的）。
- **终端指令优化：** 仅对比两个 Buffer 之间有差异的 `Cell`，并生成最小的终端光标移动指令（ANSI Escape Codes）。这能极大缓解在 SSH 远程连接下渲染大屏 TUI 的卡顿问题。

### 6. 逻辑与渲染的彻底分离 (Painter Pattern)

目前的 `layoutNode` 还在处理 `getProps` 和测量组件内容的逻辑。

- **建议：** 采用 Painter 模式。
- `Engine` 只管矩形算法（数学计算）。
- `Renderer` 接收 `Engine` 计算出的 `LayoutResult`。
- 每个组件实现一个 `Paint(ctx PainterContext)` 接口，将自己的内容填入 `ctx` 提供的 `Bound` 内。

通过这些深度重构，Yao 的 TUI 布局引擎将从简单的“盒子叠加”进化为类似现代 Web 浏览器内核的“声明式布局合成系统”。

基于对 `tui/layout` 和 `tui/render_engine.go` 源码的进一步深入分析，当前的实现主要面临**布局计算与组件渲染深度耦合**、**缺乏标准化的盒子模型约束**以及**全局重绘性能瓶颈**的问题。

为了实现真正类似 CSS 的复杂布局处理，以下是针对底层机制的深度重构建议：

### 1. 建立「约束传递模型」（Constraints-based Layout）

当前 `measureChildWidth/Height` 采用的是简单请求模式，即父节点询问子节点大小。在 CSS 中，布局是基于约束的。

- **重构建议**：引入 `BoxConstraints` 结构，包含 `minWidth`, `maxWidth`, `minHeight`, `maxHeight`。
- **实现细节**：
- 父节点不再询问“你要多大？”，而是告知子节点“你必须在这个范围内（Constraints）决定你的尺寸”。
- 这能解决复杂的**自动折行（Word Wrap）依赖**：文本组件的高度取决于父级分配给它的宽度约束。

### 2. 引入「多阶段布局流水线」（Multi-pass Pipeline）

目前 `Engine.Layout()` 在单次递归中尝试解决所有问题，这会导致 `Absolute` 定位与 `Flex` 容器嵌套时的计算冲突。

- **第一阶段：样式计算（Style Pass）**。合并内联样式、主题样式和继承属性（如 `color`, `font-family`），生成 `ComputedStyle`。
- **第二阶段：尺寸测量（Measure Pass）**。自底向上递归，子节点根据 `Constraints` 返回其理想尺寸（Intrinsic Size）并缓存。
- **第三阶段：位置排列（Layout Pass）**。自顶向下递归，父节点根据测量结果确立子节点的 `Bound.X` 和 `Bound.Y`。

### 3. 实现「盒模型标准化」与单位系统

当前的 `Size` 类型虽然支持 `interface{}`，但逻辑分散在 `measureChild` 中，且单位支持不全。

- **重构建议**：统一支持 `Pixel` (ch), `Percent` (%), `Auto`, `Flex` (fr/flex-grow) 单位。
- **空间分配公式**：
- `TotalSpace = Content + Padding + Border + Margin`。
- 布局计算应先扣除所有的固定值（Pixel），再按比例分配 `Flex` 或 `Percent` 空间。

### 4. 渲染后端：从「字符串拼接」转向「单元格缓冲区」

`Renderer` 目前在 `LayoutAbsolute` 之外大量使用 `lipgloss` 的 `JoinHorizontal/Vertical` 进行字符串拼接，这无法处理 z-index 覆盖和遮挡逻辑。

- **重构建议**：构建 `CellBuffer`（二维数组），每个 `Cell` 存储 `rune` 及其对应的样式属性。
- **层叠上下文（Stacking Context）**：
- 引入 `ZIndex` 属性。
- 按照 `Background -> Content -> Borders -> Children -> Absolute Overlays` 的顺序将内容“绘制”到缓冲区，解决弹出层挡住背景的问题。

### 5. 性能优化：增量更新与脏矩形检查

虽然 `LayoutResult` 已经有了 `Dirties` 字段，但渲染时仍是全量重绘。

- **重构建议**：
- **布局缓存**：在 `LayoutNode` 中存储 `LastConstraints`。如果窗口未缩放且 `Props` 未变，直接跳过子树计算。
- **终端差分刷新**：对比“当前帧”和“前一帧”的 `CellBuffer`，仅生成发生变化的单元格的 ANSI 移动和写入指令。这对于大型仪表盘（Dashboard）在高延迟 SSH 下的流畅度至关重要。

### 6. 解耦布局算法与组件逻辑

目前的布局引擎需要知道组件是否是 `text` 或 `list` 来猜测高度，这违背了开闭原则。

- **重构建议**：组件应通过 `Measure(Constraints) Size` 接口自行报告大小。
- **优势**：`LayoutEngine` 只处理通用的 `LayoutStyle`（类似 CSS 引擎），而具体的渲染逻辑由 `Renderer` 和组件的 `Render` 方法配合完成。

通过这些深入的重构，Yao 的 TUI 布局引擎将具备处理**流式布局、重叠定位以及高性能实时更新**的能力，从一个简单的组件排列器进化为一个标准化的图形系统。

基于对姚（Yao）项目中 `tui/layout` 和 `tui/render_engine.go` 源代码的持续分析，当前的布局系统在处理复杂界面时存在三个核心瓶颈：**计算逻辑的线性限制**（无法处理宽/高相互依赖）、**渲染策略的不一致**（字符串拼接 vs 缓冲区）以及**缺乏组件级的尺寸感知**。

为了实现真正类似 CSS 的现代化布局引擎，以下是更深层次的架构设计建议：

### 1. 建立「三 Pass」布局流水线

目前的单次递归布局无法解决如“自适应文本高度”这类 CSS 核心场景。建议重构为以下三个独立阶段：

- **Pass 1: 约束传递 (Constraint Pass)**
- 父节点向子节点传递 `BoxConstraints`（包含 min/max 宽高）。
- 子节点根据约束和自身 `LayoutStyle`（如 `Width: "50%"`）计算出初步意图。

- **Pass 2: 尺寸测量 (Measure Pass)**
- 子节点返回确定的 `Size` 给父节点。
- **深度优化**：对于文本组件，此阶段会根据 Pass 1 分配的宽度，计算折行后的高度，实现真正的“高度自适应内容”。

- **Pass 3: 几何排列 (Layout Pass)**
- 父节点根据收集到的子节点尺寸，确立最终的 `Rect` (X, Y, W, H) 并注入到 `LayoutNode.Bound` 中。

### 2. 标准化盒模型与坐标系统

当前的 `calculateMetrics` 虽然考虑了 Padding，但逻辑并未覆盖 Margin 的塌陷处理或 Border 的物理占位。

- **物理边框占位**：在布局计算阶段，`Border` 必须被视为物理占位空间（即使不渲染），否则 Flex 分配会产生 1-2 字符的偏移。
- **坐标绝对化**：将 `Bound` 统一为相对于根节点的绝对坐标，而不是相对于父节点的偏移。这使得渲染引擎在处理 `Absolute` 嵌套布局时无需动态累加偏移量。

### 3. 统一渲染后端：引入「深度合成器 (Compositor)」

目前的 `Renderer` 在 Flex 布局下依赖 `lipgloss` 的字符串拼接，这导致 Z-index 和 Overlap（重叠）几乎无法实现。

- **虚拟画布架构**：所有组件不再返回 `string`，而是调用 `Painter.Draw(buffer)` 接口。
- **Cell 单元格存储**：缓冲区应存储 `Cell` 结构（包含 rune、颜色、背景、样式位、以及 NodeID）。
- **层叠上下文**：渲染时按 `ZIndex` 排序。这允许在 `tui-list` 上方直接覆盖一个 `absolute` 定位的弹出对话框，而不会破坏背景布局。

### 4. 样式系统与状态的解耦 (Cascading Rules)

当前样式直接硬编码在 `LayoutNode` 中，缺乏 CSS 的级联特性。

- **Computed Style**：引入一个“样式合并层”。在布局开始前，合并 `Global Theme` -> `Component Default` -> `DSL Class` -> `Inline Style` 产生一份最终的不可变样式。
- **伪类支持**：在引擎层模拟 `:focus` 状态。当 `FocusManager` 切换焦点时，触发该节点样式的重新合并，并标记为 `Dirty`。

### 5. 极致性能：脏矩形与终端差分

目前的 TUI 在每次 `Update` 后几乎都会触发大面积重绘，这在 SSH 环境下会导致闪烁。

- **增量绘制 (Incremental Rendering)**：利用现有的 `result.Dirties`。合成器只计算受影响节点的 Bound 区域。
- **终端光标优化**：Renderer 对比“当前帧”与“上一帧”的 `CellBuffer`，仅对有差异的坐标发送 ANSI 移动指令。这能减少 80% 以上的字符发送量。

### 总结重构方向

姚项目的布局引擎应从**“字符串生成器”**转向**“基于约束的图形合成系统”**。重点是实现 **Measure/Layout 双阶段分离** 和 **统一的 Cell 缓冲区渲染**，这将赋予 Yao TUI 接近现代 Web 端 Flexbox 的布局灵活性和稳定性。

基于对 `tui/layout` 和 `tui/render_engine.go` 的持续深度分析，现在的重构重点应转向**布局计算的数学模型标准化**和**跨组件状态一致性**。

以下是针对实现 CSS 级别复杂布局处理的更深层细节分析：

### 1. 引入「内在尺寸」与「外在尺寸」 (Intrinsic vs Extrinsic Sizing)

当前引擎在测量（Measure）时，往往只能通过预测组件类型（如 `header`, `text`）来硬编码尺寸。

- **重构建议**：实现 `ComputeIntrinsicSize` 接口。
- **内在最小尺寸 (Min-Intrinsic)**：组件在不溢出的情况下的最小宽度。
- **内在理想尺寸 (Max-Intrinsic)**：组件在不换行情况下的理想宽度。

- **效益**：这能支持 CSS 中的 `width: min-content` 和 `width: max-content`，允许父容器根据子内容的实际文本长度精确收缩。

### 2. 实现「约束解耦」的弹性算法 (Unconstrained Measurement)

目前的 `layoutFlex` 直接根据父容器宽度计算子项。当处理嵌套滚动（Viewports）或自动伸缩列时，这会导致计算死循环。

- **重构方案**：在测量阶段允许传递 `Infinity` 约束。
- 当组件收到 `maxWidth: Infinity` 时，它会报告其最大可能的宽度（不换行）。
- 布局引擎收集所有子项的 `Max-Intrinsic` 宽度，如果总和小于可用空间，则按 `flex-grow` 分配；如果大于空间且允许换行，则启动第二次换行测量 Pass。

### 3. 盒模型的「几何隔离」 (Geometry Isolation)

当前 `calculateMetrics` 计算的结果存储在 `node.Metrics` 中，但在排列阶段并没有完全强制执行隔离。

- **重构方案**：引入 `ContentBox` 和 `LayoutBox` 的概念。
- **LayoutBox**：包含 Margin，用于父容器计算间距。
- **ContentBox**：扣除 Padding 和 Border 后的区域，作为子组件渲染的绝对限制（Clip Area）。

- **深度实现**：在 `Renderer` 合成时，如果组件内容超出了 `ContentBox`，渲染引擎应自动执行字符级裁剪（Clipping），防止子组件绘制溢出到父组件的边框之外。

### 4. 样式属性的「层叠计算引擎」 (Cascading Engine)

目前 `LayoutStyle` 缺乏级联能力。

- **重构方案**：实现 `StyleResolver`。
- **继承属性 (Inherited)**：如 `color`, `visibility` 应自动从父节点向下传递。
- **计算值 (Computed Value)**：将百分比、`vh/vw`（在 TUI 中对应窗口宽高比）在布局开始前解析为具体的整数。

- **优势**：这允许你在根节点设置一次颜色主题，全局自动生效，且能处理类似 `calc(100% - 20px)` 的复杂表达式。

### 5. 高性能绘制：引入「显示列表」 (Display Lists)

目前的 `renderToBuffer` 直接通过二维数组操作 rune。

- **重构方案**：仿照现代渲染器引入 `DisplayList`（或绘图指令序列）。
- 布局引擎输出 `LayoutResult`。
- 每个节点生成一组指令：`DrawRect(bound, style)`, `DrawText(text, offset, style)`, `ApplyLayer(zIndex)`。
- **Compositor（合成器）**：最后统一处理显示列表，按 `ZIndex` 排序并合并到最终的 `CellBuffer`。

- **效益**：这能极大简化交互（如点击测试），只需检查鼠标坐标落在哪个 DisplayList 元素的 `Bound` 内即可实现精确的点击反馈。

### 6. 异步布局计算 (Async Layout)

在处理大型表格（CRUD）或复杂列表时，同步布局会阻塞 TUI 主循环。

- **重构建议**：将布局计算移动到独立的 Goroutine。
- 当数据更新时，后台计算新的 `LayoutResult`。
- 计算完成后发送 `LayoutReadyMsg` 给 `Model.Update`。
- 主循环仅在 `View()` 方法中读取最新的快照进行绘制。

通过以上深度重构，Yao 的 TUI 引擎将不再是一个简单的“组件堆叠器”，而是一个具有**几何隔离、层叠样式、以及高性能合成能力**的工业级 TUI 图形系统。

基于对 `yao/tui` 现有代码库的深入分析，特别是 `tui/layout/engine.go` 和 `tui/layout/renderer.go`，目前的实现是一个混合体：它试图模仿 Web 布局，但底层依赖于 `lipgloss` 的字符串拼接模型，这导致了布局计算和渲染之间的循环依赖。

为了实现真正的类 CSS 复杂布局，我们需要打破这种依赖，采用**严格的几何约束协议**。以下是针对代码层面的具体实施分析和重构方案：

### 1. 核心数据结构的重构 (`tui/layout/types.go`)

目前的 `LayoutStyle` 和 `LayoutNode` 结构缺乏对“约束”的描述，导致 `engine.go` 中必须通过猜测或预渲染来确定尺寸。

**现状分析：**
`Size` 结构体使用 `interface{}` 存储 Value，这需要在运行时频繁断言类型，且无法表达 "父容器宽度减去 20px" 这种动态约束。

**重构建议：**
引入 `BoxConstraint` 和 `Geometry`，这是实现 CSS 盒模型的基石。

```go
// tui/layout/geometry.go (新建)

// BoxConstraint 定义组件尺寸的允许范围
// 类似于 Flutter 的约束模型
type BoxConstraints struct {
    MinWidth, MaxWidth   int
    MinHeight, MaxHeight int
}

// Geometry 定义计算后的几何信息
type Geometry struct {
    X, Y, Width, Height int
    ContentWidth, ContentHeight int
}

// 在 types.go 中更新 LayoutNode
type LayoutNode struct {
    // ... 原有字段

    // 输入：父级传递的约束
    Constraints BoxConstraints

    // 输出：测量阶段计算出的期望尺寸
    MeasuredSize Size

    // 最终：布局阶段确定的几何位置
    Geometry Geometry

    // 缓存：避免重复计算
    layoutCache *LayoutCache
}

```

### 2. 测量协议的实现 (`tui/layout/engine.go`)

`engine.go` 中的 `measureChildWidth` 和 `measureChildHeight` 目前包含大量针对特定组件（如 `text`, `list`）的硬编码 `switch-case` 逻辑。这不仅违反了开闭原则，而且效率低下（通过预渲染来测量）。

**重构建议：**
将测量逻辑下放给组件本身，Engine 只负责传递约束。

**Step 1: 定义测量接口**

```go
// tui/core/interfaces.go
type Measurable interface {
    // 组件根据约束计算自己的理想大小
    Measure(constraints layout.BoxConstraints) layout.Size
}

```

**Step 2: 重构 Engine 的 Measure 过程**
删除 `measureChildWidth/Height` 中的硬编码，改为通用调用：

```go
// tui/layout/engine.go

func (e *Engine) measureNode(node *LayoutNode, constraints BoxConstraints) {
    // 1. 处理 CSS 样式对约束的修正 (例如 style.width="50%" 会修改传入的 constraints)
    styledConstraints := e.applyStyleConstraints(node, constraints)

    var size Size

    // 2. 如果是叶子节点（组件），调用组件的 Measure 方法
    if node.IsLeaf() && node.Component != nil {
        if measurable, ok := node.Component.Instance.(core.Measurable); ok {
            size = measurable.Measure(styledConstraints)
        } else {
            // 回退逻辑：没有实现 Measure 接口的组件
            size = Size{Width: styledConstraints.MinWidth, Height: styledConstraints.MinHeight}
        }
    } else {
        // 3. 如果是容器节点（Flex/Grid），递归测量子节点
        size = e.measureContainer(node, styledConstraints)
    }

    // 4. 存储测量结果
    node.MeasuredSize = size
}

```

### 3. 统一渲染后端：虚拟缓冲区 (`tui/layout/renderer.go`)

目前的 `Renderer` 存在严重的逻辑分裂：

- `renderRow/renderColumn` 使用 `lipgloss.JoinHorizontal/Vertical` 进行字符串拼接。
- `renderToBuffer` 使用 `[][]rune` 处理 `Absolute` 布局。

这种分裂导致无法在 Flex 布局中正确处理 Z-index（例如，Dropdown 菜单无法覆盖下方的 List）。

**重构建议：**
废弃字符串拼接模式，全量采用并优化 `Buffer` 模式。

```go
// tui/layout/buffer.go (新建)

type Cell struct {
    Char   rune
    Style  lipgloss.Style
    ZIndex int
}

type Buffer struct {
    Cells  [][]Cell
    Width  int
    Height int
}

func (b *Buffer) SetCell(x, y int, cell Cell) {
    if x < 0 || y < 0 || x >= b.Width || y >= b.Height {
        return
    }
    // Z-Index 检查，实现层叠上下文
    if cell.ZIndex >= b.Cells[y][x].ZIndex {
        b.Cells[y][x] = cell
    }
}

```

**修改 Renderer：**

```go
// tui/layout/renderer.go

func (r *Renderer) Render() string {
    // 1. 创建画布
    buffer := NewBuffer(r.engine.window.Width, r.engine.window.Height)

    // 2. 递归绘制（不再返回 string，而是操作 buffer）
    r.drawNode(r.engine.root, buffer)

    // 3. 序列化为最终字符串
    return buffer.String()
}

func (r *Renderer) drawNode(node *LayoutNode, buffer *Buffer) {
    // 计算绝对坐标
    absX, absY := node.GetAbsolutePosition()

    // 绘制组件内容到 Buffer
    if node.Component != nil {
        // 组件需要实现 Draw 接口，或者这里处理 Render 返回的 string 并填入 Buffer
        content := node.Component.Instance.Render(...)
        buffer.WriteAt(absX, absY, content, node.Style.ZIndex)
    }

    // 递归绘制子节点（顺序决定了默认的层叠关系）
    for _, child := range node.Children {
        r.drawNode(child, buffer)
    }
}

```

### 4. 关键路径优化：Dirty Rects (脏矩形)

在 `tui/layout/engine.go` 中，`MarkDirty` 逻辑已经存在，但在渲染时未被充分利用。

**深入实现：**

1. **Partial Layout (局部布局)**: 当一个节点的 `Dirty` 标记为真时，只重新执行该节点及其子树的 `Measure` 和 `Layout`。但要注意，如果尺寸发生变化，必须向上传播 Dirty 标记直到根节点或固定尺寸的容器。
2. **Partial Paint (局部重绘)**: 维护上一帧的 `Buffer`。当前帧渲染时，只重绘 Dirty 节点区域的 Cell。
3. **Diff Output**: 最后输出到终端时，比较 `CurrentBuffer` 和 `PrevBuffer`，只生成有差异的 ANSI 序列。

### 总结重构路线图

1. **Types 升级**: 在 `types.go` 中引入 `BoxConstraints` 和 `Geometry`。
2. **Protocol 定义**: 定义 `Measurable` 和 `Drawable` 接口。
3. **Buffer 统一**: 将 `renderer.go` 重写为纯 Buffer 操作，支持 Z-Index。
4. **Engine 改造**: 将 `engine.go` 拆分为 `Measure` (自底向上) 和 `Arrange` (自顶向下) 两个明确阶段。

这种架构将使 `yao/tui` 具备处理复杂仪表盘、多层弹窗和自适应布局的能力，不仅类似于 CSS，而且在性能上更适应 TUI 的刷新机制。

基于对 `yao/tui` 现有代码架构的持续深入剖析，为了将当前的布局引擎从“初级 Flex 模拟”提升为“工业级 UI 渲染管线”，我们需要在**数据结构**、**算法流程**和**组件桥接**三个核心层面进行外科手术式的重构。

以下是针对具体代码文件的深度实施分析：

### 1. 数据结构升级：类型系统的严谨化 (`tui/layout/types.go`)

目前的 `Size` 结构体使用 `interface{}` 存储值，这在运行时需要大量的类型断言，且难以表达复合约束（如 `min(100px, 50%)`）。

**重构方案：引入强类型的单位系统**

建议废弃 `interface{}`，改用明确的单位枚举和值结构，以便于计算引擎快速处理。

```go
// tui/layout/types.go

type Unit uint8

const (
    UnitAuto    Unit = iota // 自动，由内容决定
    UnitPoint               // 具体的字符数 (px)
    UnitPercent             // 相对于父容器的百分比 (%)
    UnitFr                  // 剩余空间权重 (flex-grow)
)

type Value struct {
    Val  float64
    Unit Unit
}

// 示例构造函数
func Px(v int) Value        { return Value{Val: float64(v), Unit: UnitPoint} }
func Pct(v float64) Value   { return Value{Val: v, Unit: UnitPercent} }
func Fr(v float64) Value    { return Value{Val: v, Unit: UnitFr} }
func Auto() Value           { return Value{Unit: UnitAuto} }

// 扩展 LayoutStyle 以支持更丰富的 CSS 属性
type LayoutStyle struct {
    // ... 原有字段

    // 尺寸约束
    Width, Height     Value
    MinWidth, MinHeight Value
    MaxWidth, MaxHeight Value

    // Flex 增强
    FlexBasis Value
    FlexGrow  float64
    FlexShrink float64

    // 边框与间距
    BorderWidth Padding // 复用 Padding 结构表示四边
    BoxSizing   BoxSizingType // ContentBox 或 BorderBox

    // 层叠上下文
    ZIndex int
    Opacity float64 // 0.0 - 1.0 (虽然终端很难实现真透明，但可用于显隐控制)
}

```

### 2. 算法核心：Flex 布局的标准化实现 (`tui/layout/engine.go`)

当前的 `layoutFlex` 逻辑较为线性，无法处理 `Wrap` 换行后的多轴对齐，也缺乏 `Shrink` 收缩处理。

**重构方案：标准的 Flex 算法流程**

将 `layoutFlex` 重写为以下步骤：

1. **Resolve Flexible Lengths (解析弹性长度)**:

- 确定主轴（Main Axis）和交叉轴（Cross Axis）。
- 首先计算所有 `Pixel` 和 `Percent` 定义的子节点尺寸。

2. **Determine Available Space (确定剩余空间)**:

- `Available = ContainerSize - Sum(FixedChildren) - Sum(Gaps) - Padding - Border`。

3. **Distribution Loop (分配循环)**:

- **Grow**: 若 `Available > 0`，根据 `FlexGrow` 权重分配剩余空间。
- **Shrink**: 若 `Available < 0` (溢出)，根据 `FlexShrink` 权重 \* 基础尺寸 (Basis) 的比例进行压缩。

4. **Cross Axis Alignment (交叉轴对齐)**:

- 在确定了每个子元素的主轴尺寸后，递归测量其交叉轴尺寸。
- 应用 `AlignItems` (如 `Center`, `Stretch`) 调整子元素在交叉轴上的位置。

**代码逻辑示例 (engine.go):**

```go
func (e *Engine) layoutFlex(node *LayoutNode, constraints BoxConstraints) Size {
    // 1. 初始化主轴/交叉轴变量
    var mainUsed, crossUsed int
    // ...

    // 2. 第一次遍历：测量非 Flex 子元素
    for _, child := range node.Children {
        if child.Style.FlexGrow == 0 {
            // 给定宽松约束进行测量
            childSize := e.measureNode(child, constraints.Loosen())
            mainUsed += childSize.Main
        }
    }

    // 3. 计算剩余空间
    freeSpace := constraints.MaxWidth - mainUsed

    // 4. 第二次遍历：分配 Flex 空间并测量 Flex 子元素
    if freeSpace > 0 {
        distributeGrow(node.Children, freeSpace)
    } else if freeSpace < 0 {
        distributeShrink(node.Children, freeSpace) // 关键缺失逻辑
    }

    // 5. 第三次遍历：确定最终位置 (JustifyContent & AlignItems)
    // ...

    return Size{Width: ..., Height: ...}
}

```

### 3. 渲染层：从 `string` 到 `CellBuffer` (`tui/layout/renderer.go`)

`Renderer` 目前混合了 `lipgloss` 的字符串拼接和 buffer 写入。为了支持 `Z-Index` 和复杂的图层叠加，必须统一到底层 buffer。

**重构方案：构建高性能渲染缓冲区**

```go
// tui/layout/buffer.go

// Cell 代表终端屏幕上的一个网格
type Cell struct {
    Rune  rune
    Style lipgloss.Style // 存储样式引用，而非渲染后的 ANSI 字符串
}

type Buffer struct {
    grid   [][]Cell
    width  int
    height int
}

// 核心绘制方法：支持 Z-Index 的关键在于绘制顺序
func (r *Renderer) Render() string {
    // 1. 收集所有需要绘制的节点，并展平为列表
    renderList := r.collectRenderNodes(r.engine.root)

    // 2. 按照 Z-Index 排序 (稳定的排序算法)
    sort.SliceStable(renderList, func(i, j int) bool {
        return renderList[i].Style.ZIndex < renderList[j].Style.ZIndex
    })

    // 3. 依次绘制到 Buffer
    buf := NewBuffer(r.window.Width, r.window.Height)
    for _, node := range renderList {
        r.paintNodeToBuffer(node, buf)
    }

    // 4. 将 Buffer 转换为最终的 ANSI 字符串序列
    return buf.String()
}

```

### 4. 组件桥接：适配 `Bubble Tea` 组件 (`tui/render_engine.go`)

目前的 `renderLayoutNode` 强依赖于 `ComponentInstance`，且通过猜测类型来预估尺寸。

**重构方案：通用适配器模式**

不要让 Engine 知道具体的组件类型（如 `input`, `table`）。Engine 应该通过接口与组件交互。

1. **定义 `LayoutAware` 接口** (在 `tui/core` 中):

```go
type LayoutAware interface {
    // 组件报告自己在其内容发生变化时的首选大小
    IntrinsicSize() (width, height int)

    // 布局引擎通知组件其最终被分配的大小
    SetSize(width, height int)
}

```

2. **创建 Bubble Tea 适配器**:
   由于 `bubbletea` 的组件通常有 `View()` 和 `Update()`，我们需要一个 wrapper 来实现 `LayoutAware`。

```go
type BubbleWrapper struct {
    model tea.Model
    width int
    height int
}

func (b *BubbleWrapper) Measure(constraints BoxConstraints) Size {
    // 调用 bubbletea 组件的逻辑来估算大小，或者返回默认值
    // 对于 Viewport/Table 等组件，通常可以在此处返回 constraints.MaxWidth/MaxHeight
    return Size{Width: constraints.MaxWidth, Height: constraints.MaxHeight}
}

func (b *BubbleWrapper) Render(config RenderConfig) string {
    // 在渲染前，确保将布局计算出的尺寸同步给组件
    if m, ok := b.model.(interface{ SetSize(int, int) }); ok {
        m.SetSize(config.Width, config.Height)
    }
    return b.model.View()
}

```

### 总结与优先级

1. **P0 (最高优先级)**: 重构 `types.go`，引入 `Value` (Unit) 类型和 `BoxConstraints` 结构。这是所有计算的基础。
2. **P1**: 重写 `engine.go` 中的 `measureChild` 逻辑，移除所有针对特定组件 (`text`, `list` 等) 的 `switch-case` 硬编码，改为接口调用。
3. **P2**: 统一 `renderer.go`，弃用递归字符串拼接，全面转向 `CellBuffer` 绘制，以解决边框重叠和 Z-Index 问题。
4. **P3**: 实现脏矩形 (Dirty Rect) 检测，优化 `Renderer` 的 Buffer 输出，只针对变化的区域生成 ANSI 码。

通过这套组合拳，`yao/tui` 将能够像浏览器解析 HTML/CSS 一样解析和渲染复杂的终端界面，同时保持极高的运行时性能。

结合您提供的 `tui/core/types.go`、`tui/components/text.go` 和 `tui/layout/builder.go` 等文件，以及之前分析的 `engine.go` 和 `renderer.go`，我们可以对 **Yao TUI 布局引擎** 进行更深层次的架构分析和重构设计。

目前的实现是一个“混合态”：它拥有类 CSS 的数据结构，但底层计算逻辑是线性且硬编码的，渲染层则在“字符串拼接”和“缓冲区写入”之间摇摆。

为了实现**真正复杂的 CSS 布局（如自动换行、自适应高度、层叠上下文）**，建议进行以下三个维度的深度重构：

### 1. 核心协议升级：引入 `Measurable` 与 `BoxConstraints`

目前的组件接口 `ComponentInterface` 缺乏与布局引擎交互尺寸的能力。布局引擎不得不去“猜测”组件的大小，或者通过预渲染来获取尺寸，这效率极低且无法处理依赖关系（例如：文本组件的高度依赖于父容器分配的宽度）。

**重构方案：**

在 `tui/core/types.go` 中引入约束传递协议：

```go
// BoxConstraints 定义了父容器对子元素的尺寸约束
// 逻辑参考 Flutter/CSS：子元素必须在 Min-Max 之间决定自己的尺寸
type BoxConstraints struct {
    MinWidth, MaxWidth   int
    MinHeight, MaxHeight int
}

// Size 简单的整型尺寸定义
type Size struct {
    Width, Height int
}

// Measurable 接口：任何参与布局的组件都必须实现此接口
type Measurable interface {
    // Measure 接收约束，返回组件的理想尺寸 (Intrinsic Size)
    // 例如：文本组件接收 MaxWidth=100，计算出折行后需要 Height=5
    Measure(constraints BoxConstraints) Size
}

// 扩展 ComponentInterface
type ComponentInterface interface {
    // ... 原有方法
    Measurable // 嵌入 Measurable 接口
}

```

### 2. 布局算法重构：双阶段传递 (Measure & Arrange)

目前的 `layoutNode` 试图在一次递归中完成所有事情。我们需要将其拆分为两个明确的阶段。

**Phase 1: Measure (自底向上)**
计算每个节点的 `MeasuredSize`。

- 对于 **Flex 容器**：根据主轴/交叉轴逻辑，将父级约束转化为子级约束（例如减去 padding），递归调用子节点的 `Measure`，最后根据子节点的大小总和确定自身大小。
- 对于 **叶子节点（组件）**：调用组件的 `Measure` 实现。

**Phase 2: Arrange/Layout (自顶向下)**
确定每个节点的最终 `Bound` (x, y, w, h)。

- 父节点根据 `JustifyContent` (主轴对齐) 和 `AlignItems` (交叉轴对齐) 决定子节点的具体坐标。

**`tui/components/text.go` 的适配示例：**

目前 `RenderText` 是即时计算的。重构后应利用 `Measure`：

```go
func (m *TextModel) Measure(c core.BoxConstraints) core.Size {
    // 1. 确定可用宽度
    width := c.MaxWidth
    if m.Props.Width > 0 {
        width = m.Props.Width
    }

    // 2. 使用 lipgloss 计算折行后的高度
    style := lipgloss.NewStyle().Width(width)
    if m.Props.WordWrap {
        // ... 设置 wrap
    }
    rendered := style.Render(m.Props.Content)
    h := lipgloss.Height(rendered)
    w := lipgloss.Width(rendered)

    // 3. 返回受约束限制的尺寸
    return core.Size{
        Width:  clamp(w, c.MinWidth, c.MaxWidth),
        Height: clamp(h, c.MinHeight, c.MaxHeight),
    }
}

```

### 3. 渲染层统一：基于 Cell Buffer 的合成器

目前的 `Renderer` 在 Flex 布局中使用 `lipgloss.Join`（字符串拼接），在 Absolute 布局中使用 Buffer。这导致无法在 Flex 容器中放置一个 Z-Index 较高的 Absolute 弹窗（因为它会被字符串拼接“夹”在中间）。

**重构方案：**

废弃字符串拼接，所有渲染最终都写入一个统一的 `ScreenBuffer`。

1. **定义 Cell：**

```go
type Cell struct {
    Rune  rune
    Style lipgloss.Style
    ZIndex int
}

```

2. **统一绘制流程：**

- 布局引擎计算完所有节点的 `Bound` 后，生成一个扁平化的 `RenderList`。
- 根据 `ZIndex` 对 `RenderList` 进行排序（支持 CSS 这里的层叠上下文概念）。
- 依次调用组件的 `Render` 方法。此时 `Render` 不再返回字符串，而是将内容写入全局 Buffer 的指定 `(x, y)` 区域。

### 4. 针对 `builder.go` 的重构建议

目前的 `Builder` 构建出的 `LayoutStyle` 使用的是 `interface{}` 类型的宽高，这类型不安全。

**建议：**
配合新的 `Unit` 类型系统，修改 Builder 方法：

```go
// 在 types.go 中定义
type Unit int
const (
    Px Unit = iota
    Percent
    Auto
)
type Value struct {
    Val  float64
    Type Unit
}

// 修改 Builder helper
func WithWidthPercent(p float64) func(*LayoutStyle) {
    return func(s *LayoutStyle) {
        s.Width = Value{Val: p, Type: Percent}
    }
}

func WithWidthPx(px int) func(*LayoutStyle) {
    return func(s *LayoutStyle) {
        s.Width = Value{Val: float64(px), Type: Px}
    }
}

```

### 实施路线图

1. **Stage 1 (Core):** 修改 `tui/core/types.go`，添加 `BoxConstraints`, `Size`, `Measurable`。
2. **Stage 2 (Adapters):** 修改 `tui/render_engine.go`，使其能够适配旧组件，或者让所有基础组件（Text, Input 等）实现 `Measurable`。
3. **Stage 3 (Engine):** 重写 `tui/layout/engine.go`。移除 `measureChildWidth/Height` 中的 `switch-case` 硬编码逻辑，改为调用接口。实现 Measure/Layout 双遍算法。
4. **Stage 4 (Renderer):** 重写 `tui/layout/renderer.go`，实现纯 Buffer 渲染，支持 Z-Index。

通过这种方式，Yao 的 TUI 就能像现代浏览器引擎一样，通过**约束传递**解决复杂的布局依赖，通过**层叠缓冲区**解决渲染遮挡，实现真正的“终端 UI 框架”。

结合您提供的文件内容和之前的分析，我们现在进入**代码实现层面的深度重构建议**。重点是如何在 `yao/tui` 中落地“约束布局（Constraint Layout）”和“缓冲区渲染（Buffer Rendering）”。

以下是分模块的具体实现建议：

### 1. 核心定义重构 (`tui/layout/types.go` & `tui/core/types.go`)

首先，必须建立强类型的数据结构来替代现在的 `interface{}`，这是实现复杂算法的基础。

**建议代码实现：**

```go
package layout

// 引入更精确的单位系统，替代原来的 Size{Value: interface{}}
type UnitType int

const (
    UnitPixel UnitType = iota // 绝对字符数
    UnitPercent               // 百分比 (0.0 - 1.0)
    UnitAuto                  // 自动（由内容决定）
)

// Dimension 定义一个唯独的尺寸（宽或高）
type Dimension struct {
    Value float64
    Type  UnitType
}

// 辅助构造函数
func Px(v int) Dimension     { return Dimension{Value: float64(v), Type: UnitPixel} }
func Pct(v float64) Dimension { return Dimension{Value: v / 100.0, Type: UnitPercent} }
func Auto() Dimension        { return Dimension{Type: UnitAuto} }

// BoxConstraints 是布局计算的核心（参考 Flutter/CSS）
// 父节点告诉子节点：“你必须在这个范围内展示”
type BoxConstraints struct {
    MinWidth, MaxWidth   int
    MinHeight, MaxHeight int
}

// 检查约束是否为紧约束（宽高已固定）
func (bc BoxConstraints) IsTight() bool {
    return bc.MinWidth == bc.MaxWidth && bc.MinHeight == bc.MaxHeight
}

// Constrain 将给定尺寸限制在约束范围内
func (bc BoxConstraints) Constrain(width, height int) (int, int) {
    w := width
    if w < bc.MinWidth { w = bc.MinWidth }
    if w > bc.MaxWidth { w = bc.MaxWidth }

    h := height
    if h < bc.MinHeight { h = bc.MinHeight }
    if h > bc.MaxHeight { h = bc.MaxHeight }

    return w, h
}

// LayoutNode 增加布局计算的中间状态
type LayoutNode struct {
    // ... 原有字段保持不变

    // 样式属性升级
    Style *NewLayoutStyle

    // 布局计算结果
    ComputedSize Size // 测量后的尺寸
    Offset       Point // 相对父节点的偏移 (x, y)

    // 缓存：避免重复计算
    lastConstraints BoxConstraints
}

type NewLayoutStyle struct {
    Width, Height     Dimension
    MinWidth, MaxWidth Dimension
    MinHeight, MaxHeight Dimension

    // Flex 属性
    FlexGrow   float64
    FlexShrink float64
    FlexBasis  Dimension

    // 布局模型
    Display DisplayType // Flex, Grid, Block, None
    Position PositionType // Relative, Absolute

    // 层叠
    ZIndex int
}

```

### 2. 组件接口升级 (`tui/core/types.go`)

组件不能只是黑盒，它必须参与布局协商。

**建议代码实现：**

```go
package core

import "github.com/yaoapp/yao/tui/layout" // 假设引用路径

// Measurable 接口允许组件根据约束计算自己的大小
type Measurable interface {
    // Measure: 给定约束，返回组件想要的尺寸
    // 例如：Text 组件在 MaxWidth=20 时，计算出自己需要 3 行高度
    Measure(constraints layout.BoxConstraints) (width, height int)
}

// 扩展 ComponentInterface
type ComponentInterface interface {
    // ... 原有 View(), UpdateMsg() 等方法

    // 增加测量能力
    // 如果组件无法测量（如纯 BubbleTea 组件），可以提供默认实现返回 MaxWidth/MaxHeight
    Measurable
}

```

### 3. 布局引擎算法重构 (`tui/layout/engine.go`)

将原本混合在一起的 `layoutNode` 拆分为 `Measure` 和 `Place` 两个阶段。这里以最复杂的 Flex 算法为例。

**建议代码实现：**

```go
// Measure 阶段：自底向上计算尺寸
func (e *Engine) measureNode(node *LayoutNode, parentConstraints BoxConstraints) {
    // 1. 根据 CSS 样式（如 width: 50%）修正父级传入的约束
    nodeConstraints := e.applyStyleConstraints(node, parentConstraints)

    // 2. 如果是容器，递归测量子节点
    if len(node.Children) > 0 {
        if node.Style.Display == DisplayFlex {
            e.measureFlex(node, nodeConstraints)
        } else {
            // 默认 Block 布局或 Grid 布局处理
        }
    } else {
        // 3. 如果是叶子节点（组件），调用组件的 Measure
        if node.Component != nil {
            w, h := node.Component.Instance.Measure(nodeConstraints)
            node.ComputedSize = Size{Width: w, Height: h}
        } else {
            // 空节点，大小为 0 或由 MinWidth/Height 决定
            node.ComputedSize = Size{
                Width: nodeConstraints.MinWidth,
                Height: nodeConstraints.MinHeight,
            }
        }
    }
}

// 简化的 Flex 测量逻辑 (核心难点)
func (e *Engine) measureFlex(node *LayoutNode, constraints BoxConstraints) {
    // 假设是 Row 布局 (DirectionRow)
    mainAxisLimit := constraints.MaxWidth
    crossAxisLimit := constraints.MaxHeight

    totalFlexGrow := 0.0
    usedMainSpace := 0

    // Pass 1: 测量非 Flex 元素 (固定宽度)
    for _, child := range node.Children {
        if child.Style.FlexGrow == 0 {
            // 给子元素传入宽松约束 (0 -> mainAxisLimit)
            e.measureNode(child, BoxConstraints{
                MinWidth: 0, MaxWidth: mainAxisLimit,
                MinHeight: 0, MaxHeight: crossAxisLimit,
            })
            usedMainSpace += child.ComputedSize.Width
        } else {
            totalFlexGrow += child.Style.FlexGrow
        }
    }

    // Pass 2: 分配剩余空间给 Flex 元素
    remainingSpace := mainAxisLimit - usedMainSpace
    if remainingSpace < 0 { remainingSpace = 0 }

    maxCrossSize := 0

    for _, child := range node.Children {
        if child.Style.FlexGrow > 0 {
            // 计算分配给该子元素的宽度
            flexWidth := int(float64(remainingSpace) * (child.Style.FlexGrow / totalFlexGrow))

            // 强制子元素宽度为 flexWidth
            e.measureNode(child, BoxConstraints{
                MinWidth: flexWidth, MaxWidth: flexWidth,
                MinHeight: 0, MaxHeight: crossAxisLimit,
            })
        }

        // 记录交叉轴最大高度 (用于容器高度)
        if child.ComputedSize.Height > maxCrossSize {
            maxCrossSize = child.ComputedSize.Height
        }
    }

    // 设置容器最终尺寸
    node.ComputedSize = Size{
        Width: constraints.ConstrainWidth(usedMainSpace + remainingSpace), // 通常是 MaxWidth
        Height: constraints.ConstrainHeight(maxCrossSize),
    }
}

// Place 阶段：自顶向下确定坐标
func (e *Engine) placeNode(node *LayoutNode, x, y int) {
    node.Offset = Point{X: x, Y: y}

    // 处理 Flex 对齐 (JustifyContent, AlignItems)
    if node.Style.Display == DisplayFlex {
        currentX := x
        // ... 根据 JustifyContent 计算起始 X 和 间距

        for _, child := range node.Children {
            // ... 根据 AlignItems 计算 childY
            childY := y // 默认为 Top

            e.placeNode(child, currentX, childY)
            currentX += child.ComputedSize.Width
        }
    }
}

```

### 4. 渲染器重构：基于 Cell Buffer (`tui/layout/renderer.go`)

为了解决 Z-Index 和字符覆盖问题（例如弹窗遮挡背景），渲染器不应再做字符串拼接，而是操作一个二维数组。

**建议代码实现：**

```go
type Cell struct {
    Char   rune
    Style  lipgloss.Style // 或者存储具体的 FG/BG 颜色值以节省内存
    ZIndex int
}

type RenderBuffer struct {
    Cells  [][]Cell
    Width  int
    Height int
}

func NewRenderBuffer(w, h int) *RenderBuffer {
    cells := make([][]Cell, h)
    for i := range cells {
        cells[i] = make([]Cell, w)
        // 初始化为空格
    }
    return &RenderBuffer{Cells: cells, Width: w, Height: h}
}

// 核心绘制逻辑
func (r *Renderer) Render() string {
    // 1. 触发布局计算
    r.engine.Measure(r.windowWidth, r.windowHeight)
    r.engine.Place(0, 0)

    // 2. 准备画布
    buf := NewRenderBuffer(r.windowWidth, r.windowHeight)

    // 3. 收集所有需要绘制的节点（扁平化列表）
    nodes := r.collectNodes(r.engine.Root)

    // 4. 按 Z-Index 排序 (保证上层元素覆盖下层)
    sort.Slice(nodes, func(i, j int) bool {
        return nodes[i].Style.ZIndex < nodes[j].Style.ZIndex
    })

    // 5. 绘制
    for _, node := range nodes {
        if node.Component != nil {
            // 调用组件渲染生成 string
            // 注意：这里传入的 Width/Height 必须等于 Layout 计算出的 ComputedSize
            content := node.Component.Instance.View()

            // 将 string 解析并写入 buf
            r.writeToBuffer(buf, content, node.Offset.X, node.Offset.Y, node.Style.ZIndex)
        }
    }

    // 6. 输出为 ANSI 字符串
    return buf.String()
}

func (r *Renderer) writeToBuffer(buf *RenderBuffer, content string, x, y, z int) {
    // 这里需要解析 content 中的 ANSI Escape Codes
    // 将带颜色的字符一一填入 buf.Cells[y+dy][x+dx]
    // 只有当 z >= existingCell.ZIndex 时才覆盖
}

```

### 5. 适配 `Text` 组件示例 (`tui/components/text.go`)

让现有的组件适配新的 `Measurable` 接口。

**建议代码实现：**

```go
// 适配 TextModel
func (m *TextModel) Measure(c layout.BoxConstraints) (int, int) {
    // 1. 获取内容
    content := m.Props.Content

    // 2. 确定渲染宽度
    renderWidth := m.Props.Width
    if renderWidth == 0 {
        // 如果没有指定宽度，尝试尽可能宽，但不超过约束
        renderWidth = c.MaxWidth
    }

    // 3. 使用 lipgloss 预计算高度
    // 这是一个相对昂贵的操作，可以考虑增加内部缓存
    style := lipgloss.NewStyle().Width(renderWidth)
    if m.Props.WordWrap {
        // 配置 wrap
    }

    rendered := style.Render(content)
    h := lipgloss.Height(rendered)
    w := lipgloss.Width(rendered) // 实际占用的宽度

    // 4. 返回受约束限制的结果
    finalW := clamp(w, c.MinWidth, c.MaxWidth)
    finalH := clamp(h, c.MinHeight, c.MaxHeight)

    return finalW, finalH
}

```

### 总结

这套重构方案的核心在于：

1. **打破循环依赖**：通过 `BoxConstraints` 和 `Measure` 明确了父子节点之间的尺寸协商协议。
2. **统一渲染模型**：通过 `RenderBuffer` 和 `ZIndex` 解决了 TUI 中常见的图层遮挡和边框对齐问题。
3. **兼容性设计**：`ComponentInterface` 的扩充允许逐步迁移现有组件，未实现 `Measure` 的组件可以给一个默认的“填满”行为。

结合您提供的文件（`tui/core/types.go`, `tui/components/text.go`, `tui/layout/builder.go`, `tui/layout/engine.go`, `tui/layout/renderer.go`, `tui/layout/types.go`）以及之前的分析，我们现在可以进入代码落地阶段。

要将 Yao TUI 的布局引擎升级为支持复杂约束（Constraint-Based）和层叠上下文（Stacking Context）的现代引擎，我建议采取**增量重构**策略。

以下是针对核心模块的具体代码实现建议：

### 1. 布局核心：Flex 算法的完整实现 (`tui/layout/flex.go`)

目前的 `engine.go` 中 `layoutFlex` 逻辑过于简单。为了支持类似 CSS 的 `flex-wrap`、`flex-shrink` 和 `align-self`，建议将其抽取为一个单独的文件 `flex.go` 并实现标准算法。

**建议新增/修改文件 `tui/layout/flex.go`：**

```go
package layout

import "math"

// FlexLayoutState 用于在测量过程中保持状态
type FlexLayoutState struct {
	MainAxis      int // 主轴方向 (Row/Column)
	CrossAxis     int // 交叉轴方向
	AvailableMain float64
}

// measureFlex 核心 Flex 测量算法 (Pass 2)
// node: 当前容器节点
// cs: 父容器传入的约束 (BoxConstraints)
func (e *Engine) measureFlex(node *LayoutNode, cs BoxConstraints) Size {
	style := node.Style
	direction := style.Direction

	// 1. 确定主轴和交叉轴的限制
	var maxMain, maxCross float64
	if direction == DirectionRow {
		maxMain = float64(cs.MaxWidth)
		maxCross = float64(cs.MaxHeight)
	} else {
		maxMain = float64(cs.MaxHeight)
		maxCross = float64(cs.MaxWidth)
	}

	// 2. 预遍历：计算总的基础尺寸 (Basis) 和 冻结非 Flex 元素
	totalFlexGrow := 0.0
	totalFlexShrink := 0.0
	usedMain := 0.0

	type childResult struct {
		node *LayoutNode
		size Size
		flexBase float64 // 记录 flex-basis 或 初始 main size
	}
	results := make([]childResult, len(node.Children))

	for i, child := range node.Children {
		// 如果子元素是绝对定位，跳过 Flex 计算 (在 Pass 3 处理)
		if child.Style.Position == PositionAbsolute {
			continue
		}

		// 暂时给予宽松约束来测量 Intrinsic Size
		childCs := cs.Loosen()
		childSize := e.Measure(child, childCs)

		// 确定主轴尺寸基准
		var mainSize float64
		if direction == DirectionRow {
			mainSize = float64(childSize.Width)
		} else {
			mainSize = float64(childSize.Height)
		}

		results[i] = childResult{node: child, size: childSize, flexBase: mainSize}

		if child.Style.FlexGrow > 0 {
			totalFlexGrow += child.Style.FlexGrow
		}
		if child.Style.FlexShrink > 0 {
			totalFlexShrink += child.Style.FlexShrink
		}

		usedMain += mainSize
	}

	// 3. 计算剩余空间 (Gap 也需要计算在内)
	totalGap := float64(len(node.Children)-1) * float64(style.Gap)
	if totalGap < 0 { totalGap = 0 }
	usedMain += totalGap

	remainingSpace := maxMain - usedMain

	// 4. 解析弹性空间 (Resolve Flexible Lengths)
	if remainingSpace > 0 && totalFlexGrow > 0 {
		// Grow 逻辑: 分配剩余空间
		for i := range results {
			if results[i].node.Style.FlexGrow > 0 {
				extra := remainingSpace * (results[i].node.Style.FlexGrow / totalFlexGrow)
				newMain := results[i].flexBase + extra
				// 重新测量子元素，强制主轴尺寸
				e.forceMeasureMain(results[i].node, newMain, direction, cs)
			}
		}
	} else if remainingSpace < 0 && totalFlexShrink > 0 {
		// Shrink 逻辑: 压缩溢出空间
		overflow := math.Abs(remainingSpace)
		// ... 标准 CSS 收缩算法 (通常基于 width * shrink_factor 加权)
		for i := range results {
			if results[i].node.Style.FlexShrink > 0 {
				// 简化版收缩：按比例减去
				shrinkRatio := results[i].node.Style.FlexShrink / totalFlexShrink
				deduct := overflow * shrinkRatio
				newMain := math.Max(0, results[i].flexBase - deduct)
				e.forceMeasureMain(results[i].node, newMain, direction, cs)
			}
		}
	}

	// 5. 计算容器自身的最终尺寸
	// 这里需要遍历一遍最终的子元素尺寸来决定容器的 Cross Size
	var finalMain, finalCross float64
	for _, child := range node.Children {
		// 累加...
	}

	// 确保符合父级约束
	return Size{
		Width:  cs.ConstrainWidth(int(finalMain)),
		Height: cs.ConstrainHeight(int(finalCross)),
	}
}

func (e *Engine) forceMeasureMain(node *LayoutNode, size float64, dir Direction, parentCs BoxConstraints) {
	// 构建一个新的紧约束 (Tight Constraint)
	var newCs BoxConstraints
	if dir == DirectionRow {
		newCs = BoxConstraints{
			MinWidth: int(size), MaxWidth: int(size), // 固定宽度
			MinHeight: 0, MaxHeight: parentCs.MaxHeight, // 高度仍自由
		}
	} else {
		// ... Column 处理
	}
	e.Measure(node, newCs)
}

```

### 2. 渲染层：交互感知的虚拟画布 (`tui/layout/renderer.go`)

为了实现鼠标点击事件的准确分发（Hit Testing）和复杂的图层遮挡（Popup over Content），我们需要在渲染缓冲区中存储 `NodeID`。

**重构 `tui/layout/renderer.go`：**

```go
package layout

import (
	"github.com/charmbracelet/lipgloss"
)

// Cell 屏幕上的一个像素点
type Cell struct {
	Char   rune
	Style  lipgloss.Style
	NodeID string // 关键：记录这个点属于哪个组件 ID，用于点击事件
	ZIndex int    // 关键：用于处理重叠
}

// RenderBuffer 虚拟屏幕缓冲区
type RenderBuffer struct {
	Cells  [][]Cell
	Width  int
	Height int
}

func NewRenderBuffer(width, height int) *RenderBuffer {
	cells := make([][]Cell, height)
	for i := range cells {
		cells[i] = make([]Cell, width)
		// 初始化空白
		for j := range cells[i] {
			cells[i][j] = Cell{Char: ' '}
		}
	}
	return &RenderBuffer{Cells: cells, Width: width, Height: height}
}

// SetContent 写入内容，处理 Z-Index 遮挡
func (b *RenderBuffer) SetContent(x, y, z int, char rune, style lipgloss.Style, nodeID string) {
	if x < 0 || x >= b.Width || y < 0 || y >= b.Height {
		return
	}

	// 只有当新的 Z-Index >= 现有的 Z-Index 时才覆盖
	if z >= b.Cells[y][x].ZIndex {
		b.Cells[y][x] = Cell{
			Char:   char,
			Style:  style,
			ZIndex: z,
			NodeID: nodeID,
		}
	}
}

// Renderer 渲染器
type Renderer struct {
	engine *Engine
	buffer *RenderBuffer
}

// Render 执行渲染
func (r *Renderer) Render() string {
	// 1. 触发布局计算 (Measure & Arrange)
	r.engine.Layout()

	// 2. 重新初始化 Buffer
	r.buffer = NewRenderBuffer(r.engine.window.Width, r.engine.window.Height)

	// 3. 递归绘制所有节点
	r.drawNode(r.engine.root)

	// 4. 将 Buffer 转为字符串 (Stringify)
	return r.buffer.String()
}

func (r *Renderer) drawNode(node *LayoutNode) {
	if node == nil { return }

	// 计算绝对坐标 (假设 node.Bound 已经是相对于屏幕的绝对坐标，或者在 Arrange 阶段已计算)
	x, y := node.Bound.X, node.Bound.Y
	w, h := node.Bound.Width, node.Bound.Height
	z := node.Style.ZIndex

	// 绘制背景/边框 (如果有)
	// r.drawBox(x, y, w, h, z, node)

	// 绘制组件内容
	if node.Component != nil {
		// 获取组件渲染后的视图字符串
		content := node.Component.Instance.View()

		// 解析 ANSI 字符串并填入 Buffer
		// 注意：这里需要一个 helper 函数来解析带颜色的字符串
		// ParseANSIAndWriteToBuffer(r.buffer, content, x, y, z, node.ID)
	}

	// 递归绘制子节点 (注意：这里不再依赖递归顺序来决定遮挡，而是依赖 Z-Index)
	for _, child := range node.Children {
		r.drawNode(child)
	}
}

// GetNodeAt 用于鼠标事件处理
func (r *Renderer) GetNodeAt(x, y int) string {
	if r.buffer == nil || x < 0 || x >= r.buffer.Width || y < 0 || y >= r.buffer.Height {
		return ""
	}
	return r.buffer.Cells[y][x].NodeID
}

```

### 3. 组件适配器：`Measurable` 接口的实现 (`tui/components/text.go`)

现有的组件需要适配新的布局协议。以 `Text` 组件为例，它应该能够告诉引擎它需要多大的空间。

**修改 `tui/components/text.go`：**

```go
// 实现 core.Measurable 接口
func (m *TextModel) Measure(constraints core.BoxConstraints) core.Size {
	// 1. 确定目标宽度
	targetWidth := m.Props.Width

	// 如果没有指定固定宽度，尝试使用最大可用宽度
	if targetWidth == 0 {
		targetWidth = constraints.MaxWidth
	}

	// 如果设置了 WordWrap，我们需要在 targetWidth 下计算高度
	content := m.Props.Content

	// 使用 lipgloss 计算实际渲染尺寸
	style := lipgloss.NewStyle().Width(targetWidth)
	if len(m.Props.Padding) > 0 {
		// ... 应用 padding
	}

	rendered := style.Render(content)
	h := lipgloss.Height(rendered)
	w := lipgloss.Width(rendered)

	// 2. 返回受约束限制的尺寸
	// 例如：即使文本很短，如果 constraints.MinWidth 要求填充，则返回 MinWidth
	return core.Size{
		Width:  constraints.ConstrainWidth(w),
		Height: constraints.ConstrainHeight(h),
	}
}

```

### 4. 优化 `engine.go` 的脏检查逻辑

在双 Pass 系统中，`MarkDirty` 需要更智能。

**修改 `tui/layout/engine.go`：**

```go
// MarkDirty 标记节点需要重新布局
func (e *Engine) MarkDirty(node *LayoutNode) {
	curr := node
	for curr != nil {
		curr.Dirty = true

		// 关键优化：如果当前节点是固定尺寸（例如 Width: 100px, Height: 50px），
		// 且它的变化不影响父容器的布局（例如它只是内容变了，但尺寸没变），
		// 则可以停止向上传播 Dirty 标记。
		// 这对于大型列表中的单行更新非常重要。
		if e.isFixedSize(curr) {
			// 但仍需标记父级以触发重绘（Repaint），但不触发重排（Relayout）
			if curr.Parent != nil {
				curr.Parent.ChildDirty = true // 区分 SelfDirty 和 ChildDirty
			}
			break
		}

		curr = curr.Parent
	}
}

```

### 总结建议

1. **数据结构先行**：优先重构 `types.go`，引入 `BoxConstraints` 和 `Unit` 类型。这不需要动逻辑，风险最小。
2. **实现 Buffer**：创建一个新的 `buffer.go` 文件，写好 `SetContent` 和 ANSI 解析逻辑。这一步可以独立测试。
3. **改造 Engine**：这是最难的一步。建议先保留旧的 `Layout()` 方法，新建一个 `LayoutV2()`，逐步迁移。
4. **组件接入**：让 `Text` 和 `Box` 组件率先实现 `Measurable` 接口，验证 Flexbox 的自适应能力。

这套方案将使 Yao TUI 具备类似 Web 浏览器的布局能力，解决当前“无法处理自动高度”和“无法正确处理弹窗遮挡”的两大痛点。

基于之前对 `yao/tui` 架构的深度分析，我们已经确定了从“流式/递归布局”向“约束驱动（Constraint-Based）+ 虚拟画布（Virtual Canvas）”架构迁移的路线。

以下是针对核心模块的具体**代码实现建议**。我们将通过增量重构的方式，引入新的文件来承载新的逻辑，尽量减少对现有逻辑的破坏性修改。

### 1. 基础几何与约束系统 (`tui/layout/geometry.go`)

首先，我们需要定义一套精确的几何类型系统，用于替代原来模糊的 `interface{}` 类型。建议新建 `geometry.go`。

```go
package layout

import "math"

// UnitType 定义尺寸单位类型
type UnitType uint8

const (
	UnitPixel UnitType = iota // 绝对字符数
	UnitPercent               // 百分比 (0.0 - 1.0)
	UnitAuto                  // 自动 (由内容决定)
)

// Dimension 表示一个带有单位的尺寸值
type Dimension struct {
	Value float64
	Unit  UnitType
}

// 辅助构造函数
func Px(v int) Dimension      { return Dimension{Value: float64(v), Unit: UnitPixel} }
func Pct(v float64) Dimension { return Dimension{Value: v / 100.0, Unit: UnitPercent} }
func Auto() Dimension         { return Dimension{Unit: UnitAuto} }

// Resolve 计算实际像素值
func (d Dimension) Resolve(parentSize int) int {
	switch d.Unit {
	case UnitPixel:
		return int(d.Value)
	case UnitPercent:
		return int(float64(parentSize) * d.Value)
	default:
		return 0 // Auto 需要在 measure 阶段特殊处理
	}
}

// Size 简单的整数尺寸
type Size struct {
	Width, Height int
}

// BoxConstraints 布局约束核心结构
// 父级传递给子级：“你的尺寸必须在这个范围内”
type BoxConstraints struct {
	MinWidth, MaxWidth int
	MinHeight, MaxHeight int
}

// NewBoxConstraints 创建约束
func NewBoxConstraints(minW, maxW, minH, maxH int) BoxConstraints {
	return BoxConstraints{minW, maxW, minH, maxH}
}

// Tight 创建一个固定大小的紧约束
func BoxConstraintsTight(width, height int) BoxConstraints {
	return BoxConstraints{width, width, height, height}
}

// Constrain 将建议的尺寸限制在约束范围内
func (bc BoxConstraints) Constrain(size Size) Size {
	w := size.Width
	if w < bc.MinWidth { w = bc.MinWidth }
	if w > bc.MaxWidth { w = bc.MaxWidth }

	h := size.Height
	if h < bc.MinHeight { h = bc.MinHeight }
	if h > bc.MaxHeight { h = bc.MaxHeight }

	return Size{w, h}
}

// Loosen 放宽约束（去除最小限制），常用于测量阶段的试探
func (bc BoxConstraints) Loosen() BoxConstraints {
	return BoxConstraints{
		MinWidth: 0, MaxWidth: bc.MaxWidth,
		MinHeight: 0, MaxHeight: bc.MaxHeight,
	}
}

```

### 2. 虚拟画布缓冲区 (`tui/layout/buffer.go`)

为了解决 Z-Index 遮挡和字符级渲染问题，我们需要一个高效的 `RenderBuffer`。建议新建 `buffer.go`。

```go
package layout

import (
	"strings"
	"github.com/charmbracelet/lipgloss"
)

// Cell 屏幕上的一个单元格
type Cell struct {
	Char   rune
	Style  lipgloss.Style
	NodeID string // 用于点击事件命中测试 (Hit Testing)
	ZIndex int    // 层叠顺序
}

// RenderBuffer 渲染缓冲区
type RenderBuffer struct {
	Cells  [][]Cell
	Width  int
	Height int
}

// NewRenderBuffer 创建指定大小的缓冲区
func NewRenderBuffer(width, height int) *RenderBuffer {
	cells := make([][]Cell, height)
	for i := range cells {
		cells[i] = make([]Cell, width)
		for j := range cells[i] {
			cells[i][j] = Cell{Char: ' '} // 默认填充空格
		}
	}
	return &RenderBuffer{Cells: cells, Width: width, Height: height}
}

// SetContent 在指定位置写入内容，包含层叠逻辑
func (b *RenderBuffer) SetContent(x, y, z int, char rune, style lipgloss.Style, nodeID string) {
	if x < 0 || x >= b.Width || y < 0 || y >= b.Height {
		return
	}

	// 核心逻辑：只有当 Z-Index 更高或相等时才覆盖
	if z >= b.Cells[y][x].ZIndex {
		b.Cells[y][x] = Cell{
			Char:   char,
			Style:  style,
			ZIndex: z,
			NodeID: nodeID,
		}
	}
}

// WriteString 写入字符串（简单实现，未处理 ANSI 颜色解析）
// 实际生产中需要解析 content 中的 ANSI 码并拆解为 Cell
func (b *RenderBuffer) WriteString(x, y, z int, content string, nodeID string) {
	lines := strings.Split(content, "\n")
	for i, line := range lines {
		curY := y + i
		curX := x
		for _, char := range line {
			// 注意：这里假设 content 已经是纯文本。
			// 如果 content 包含 ANSI 码，需要使用 ansi.Parse 解析每个字符的 Style
			b.SetContent(curX, curY, z, char, lipgloss.NewStyle(), nodeID)
			curX++
		}
	}
}

// String 将缓冲区转换为最终输出的字符串
func (b *RenderBuffer) String() string {
	var sb strings.Builder
	for i, row := range b.Cells {
		for _, cell := range row {
			if cell.Style.GetForeground() != nil || cell.Style.GetBackground() != nil {
				sb.WriteString(cell.Style.Render(string(cell.Char)))
			} else {
				sb.WriteRune(cell.Char)
			}
		}
		if i < b.Height-1 {
			sb.WriteRune('\n')
		}
	}
	return sb.String()
}

```

### 3. 组件测量接口适配 (`tui/core/types.go`)

在 `ComponentInterface` 中增加 `Measurable` 能力。

```go
package core

import "github.com/yaoapp/yao/tui/layout" // 假设路径

// Measurable 允许组件参与布局计算
type Measurable interface {
	// Measure 接收约束，返回组件的理想尺寸
	// constraints: 父级给出的限制
	// return: 组件实际占用的宽高
	Measure(constraints layout.BoxConstraints) layout.Size
}

type ComponentInterface interface {
	// ... 原有方法 (View, UpdateMsg 等)

	// 嵌入 Measurable
	// 注意：为了兼容旧组件，可以在适配层提供默认实现（返回 constraints.MaxWidth/Height）
	Measurable
}

```

### 4. Flex 布局算法实现 (`tui/layout/flex.go`)

实现标准的 Flex 算法，处理剩余空间分配 (`Grow`) 和溢出收缩 (`Shrink`)。建议新建 `flex.go`。

```go
package layout

import "math"

// FlexDirection 布局方向
type FlexDirection int
const (
	Row FlexDirection = iota
	Column
)

// MeasureFlex 执行 Flex 布局计算
func (e *Engine) MeasureFlex(node *LayoutNode, constraints BoxConstraints) Size {
	// 1. 解析样式和方向
	dir := Row
	if node.Style.Direction == DirectionColumn {
		dir = Column
	}

	// 确定主轴和交叉轴的限制
	var maxMain, maxCross int
	if dir == Row {
		maxMain = constraints.MaxWidth
		maxCross = constraints.MaxHeight
	} else {
		maxMain = constraints.MaxHeight
		maxCross = constraints.MaxWidth
	}

	totalFlexGrow := 0.0
	totalFlexShrink := 0.0
	usedMain := 0

	// 存储子节点测量结果
	type childData struct {
		node *LayoutNode
		size Size
		flexBase int // 基础尺寸
	}
	childrenData := make([]childData, 0, len(node.Children))

	// Pass 1: 测量非 Flex 子节点 (FlexGrow == 0)
	for _, child := range node.Children {
		// 跳过绝对定位
		if child.Style.Position == PositionAbsolute { continue }

		if child.Style.FlexGrow == 0 {
			// 使用宽松约束测量内容尺寸
			childConstraints := constraints.Loosen()
			// 如果是 Row 布局，高度受限；如果是 Column，宽度受限
			if dir == Row {
				childConstraints.MaxHeight = maxCross
			} else {
				childConstraints.MaxWidth = maxCross
			}

			size := e.Measure(child, childConstraints)

			mainSize := size.Width
			if dir == Column { mainSize = size.Height }

			usedMain += mainSize
			childrenData = append(childrenData, childData{child, size, mainSize})
		} else {
			// Flex 项目暂时记录，后续处理
			totalFlexGrow += child.Style.FlexGrow
			childrenData = append(childrenData, childData{child, Size{}, 0})
		}
	}

	// Pass 2: 分配剩余空间给 Flex 子节点
	remainingSpace := maxMain - usedMain
	if remainingSpace < 0 { remainingSpace = 0 } // 暂不处理 Shrink，简化逻辑

	if totalFlexGrow > 0 {
		for i, cd := range childrenData {
			if cd.node.Style.FlexGrow > 0 {
				// 按比例分配
				share := float64(remainingSpace) * (cd.node.Style.FlexGrow / totalFlexGrow)
				flexSize := int(math.Floor(share))

				// 构建强制约束
				var flexConstraints BoxConstraints
				if dir == Row {
					flexConstraints = BoxConstraints{
						MinWidth: flexSize, MaxWidth: flexSize,
						MinHeight: 0, MaxHeight: maxCross,
					}
				} else {
					flexConstraints = BoxConstraints{
						MinWidth: 0, MaxWidth: maxCross,
						MinHeight: flexSize, MaxHeight: flexSize,
					}
				}

				// 重新测量
				size := e.Measure(cd.node, flexConstraints)
				childrenData[i].size = size

				if dir == Row {
					usedMain += size.Width
				} else {
					usedMain += size.Height
				}
			}
		}
	}

	// Pass 3: 计算容器最终尺寸 (包含交叉轴对齐)
	finalW, finalH := 0, 0
	if dir == Row {
		finalW = usedMain
		// 高度取子元素最大高度
		for _, cd := range childrenData {
			if cd.size.Height > finalH { finalH = cd.size.Height }
		}
	} else {
		finalH = usedMain
		// 宽度取子元素最大宽度
		for _, cd := range childrenData {
			if cd.size.Width > finalW { finalW = cd.size.Width }
		}
	}

	// 确保符合父级约束
	return constraints.Constrain(Size{finalW, finalH})
}

```

### 5. 引擎核心逻辑整合 (`tui/layout/engine.go`)

在 `Engine` 中整合 `Measure` 和 `Layout` (Arrange) 两个阶段。

```go
// LayoutNode 增加布局状态
type LayoutNode struct {
	// ... 原有字段

	// 计算后的几何信息
	ComputedSize Size
	Offset       struct{ X, Y int } // 相对父节点的偏移
}

// Measure 阶段入口：计算尺寸
func (e *Engine) Measure(node *LayoutNode, constraints BoxConstraints) Size {
	if node == nil { return Size{} }

	// 1. 如果节点有固定样式尺寸 (如 width: 100px)，修正约束
	// if node.Style.Width != nil ... constraints = ...

	var size Size

	// 2. 根据节点类型分发
	if len(node.Children) > 0 {
		if node.Type == LayoutFlex {
			size = e.MeasureFlex(node, constraints)
		} else {
			// 默认 Block 处理
			// size = e.MeasureBlock(node, constraints)
		}
	} else if node.Component != nil {
		// 3. 调用组件测量
		if measurable, ok := node.Component.Instance.(core.Measurable); ok {
			size = measurable.Measure(constraints)
		} else {
			// 默认填满
			size = Size{constraints.MaxWidth, constraints.MinHeight}
		}
	}

	node.ComputedSize = size
	return size
}

// Arrange 阶段入口：确定坐标
func (e *Engine) Arrange(node *LayoutNode, x, y int) {
	node.Offset.X = x
	node.Offset.Y = y

	// 更新 Bound，供渲染器使用
	node.Bound.X = x // 绝对坐标需要累加，这里简化为相对
	node.Bound.Y = y
	node.Bound.Width = node.ComputedSize.Width
	node.Bound.Height = node.ComputedSize.Height

	if node.Type == LayoutFlex {
		// 根据 Direction, JustifyContent, AlignItems 计算子节点偏移
		// 简化的 Row 排列：
		currentX := x
		for _, child := range node.Children {
			e.Arrange(child, currentX, y) // 还需要处理 AlignItems 的 Y 轴偏移
			currentX += child.ComputedSize.Width
		}
	}
}

```

### 实施步骤总结

1. **添加文件**: 创建 `tui/layout/geometry.go` 和 `tui/layout/buffer.go`。这部分代码是独立的，可以先提交。
2. **更新接口**: 修改 `tui/core/types.go`，添加 `Measurable` 接口。
3. **组件适配**: 修改 `tui/components/text.go` (以及其他组件)，实现 `Measure` 方法。这是验证布局逻辑的关键。
4. **引擎改造**: 在 `tui/layout/engine.go` 中引入 `Measure` 和 `Arrange` 方法，并逐步替换旧的 `layoutNode` 递归逻辑。
5. **渲染器切换**: 修改 `tui/layout/renderer.go`，使其先调用 `engine.Measure` -> `engine.Arrange`，然后遍历节点树将内容写入 `RenderBuffer`，最后输出 `Buffer.String()`。

通过这套方案，你可以彻底解决之前提到的“无法自动计算高度”和“Flex/Absolute 混合布局渲染错误”的问题。

基于之前的分析，我们已经确立了**约束驱动（Constraint-Based）**和**双阶段布局（Measure/Arrange）**的核心架构。

接下来，为了达成“类似 CSS 的复杂布局处理”这一目标，我们需要深入解决最棘手的两个问题：**Grid 网格布局的约束实现**以及**绝对定位（Absolute Positioning）与文档流的交互**。此外，我们还将完善**事件命中测试（Hit Testing）**，这是虚拟画布带来的额外红利。

以下是具体的深度分析与代码实现建议：

### 1. 复杂网格布局 (`tui/layout/grid.go`)

目前的 `layoutGrid` 实现过于简单（硬编码列数）。真正的 Grid 需要处理轨道（Tracks）的尺寸计算，支持 `fr` 单位。

**约束策略分析：**

1. **轨道计算**：首先计算所有固定宽度（Pixel）和百分比（Percent）的列。
2. **Auto 处理**：对于设置为 `auto` 的列，需要先测量该列中所有单元格的内容最大宽度。
3. **Fr 分配**：将剩余空间按比例分配给 `fr` 单位的列。
4. **单元格测量**：确定了所有行高列宽后，对每个子元素施加严格约束（Tight Constraints）进行最终测量。

**代码实现建议 (`tui/layout/grid.go`)：**

```go
package layout

// GridTrack 定义行列轨道配置
type GridTrack struct {
    Size  Dimension // 比如: 1fr, 100px, 20%
    Min   int       // 最小尺寸
    Max   int       // 最大尺寸
}

// MeasureGrid 执行网格布局计算
func (e *Engine) MeasureGrid(node *LayoutNode, cs BoxConstraints) Size {
    // 假设 node.Style.GridTemplateColumns 包含了轨道定义
    colTracks := node.Style.GridTemplateColumns
    // rowTracks := node.Style.GridTemplateRows

    // 1. 初始化列宽数组
    colWidths := make([]int, len(colTracks))
    availableWidth := cs.MaxWidth
    usedWidth := 0
    totalFr := 0.0

    // 2. Pass 1: 解析固定值和百分比
    for i, track := range colTracks {
        if track.Size.Unit == UnitPixel {
            colWidths[i] = int(track.Size.Value)
            usedWidth += colWidths[i]
        } else if track.Size.Unit == UnitFr {
            totalFr += track.Size.Value
        }
    }

    // 3. Pass 2: 处理 Auto (需要测量内容)
    // 这是一个简化实现，通常需要两次遍历
    for i, track := range colTracks {
        if track.Size.Unit == UnitAuto {
            // 找到该列所有的子元素，测量它们的最大 IntrinsicWidth
            maxContentWidth := 0
            for _, child := range e.getChildrenInColumn(node, i) {
                // 给一个宽松的约束进行试探
                s := e.Measure(child, cs.Loosen())
                if s.Width > maxContentWidth {
                    maxContentWidth = s.Width
                }
            }
            colWidths[i] = maxContentWidth
            usedWidth += maxContentWidth
        }
    }

    // 4. Pass 3: 分配 Fr 空间
    remaining := availableWidth - usedWidth
    if remaining > 0 && totalFr > 0 {
        for i, track := range colTracks {
            if track.Size.Unit == UnitFr {
                w := int(float64(remaining) * (track.Size.Value / totalFr))
                colWidths[i] = w
                usedWidth += w // 注意：可能会有舍入误差，需要最后修正
            }
        }
    }

    // 5. 测量所有子节点
    // 既然列宽已定，我们可以生成严格的约束
    maxHeight := 0
    // ... 遍历行逻辑类似，计算 rowHeights ...

    for i, child := range node.Children {
        // 计算子元素所在的 col 和 row
        col := i % len(colTracks)
        // row := i / len(colTracks)

        targetW := colWidths[col]
        // targetH := rowHeights[row]

        // 强制子元素适应单元格大小
        childSize := e.Measure(child, BoxConstraintsTight(targetW, 0 /* or targetH */))

        // 更新容器高度
        if childSize.Height > maxHeight {
            maxHeight = childSize.Height
        }
    }

    return Size{Width: usedWidth, Height: maxHeight}
}

// 辅助方法：获取某一列的所有子元素
func (e *Engine) getChildrenInColumn(node *LayoutNode, colIndex int) []*LayoutNode {
    // 简单实现假设顺序填充
    cols := len(node.Style.GridTemplateColumns)
    var children []*LayoutNode
    for i, child := range node.Children {
        if i % cols == colIndex {
            children = append(children, child)
        }
    }
    return children
}

```

### 2. 绝对定位的深度集成 (`tui/layout/engine.go`)

绝对定位元素不占据文档流空间，这在 `Measure` 阶段必须特殊处理：容器的大小仅由**非绝对定位**的子元素决定，但绝对定位的子元素需要基于容器的 Padding Box 进行测量。

**重构建议 (`engine.go` 中的 `Measure` 方法更新)：**

```go
func (e *Engine) Measure(node *LayoutNode, cs BoxConstraints) Size {
    if node == nil { return Size{} }

    // 1. 样式约束修正
    // ... apply style constraints ...

    var size Size
    var absChildren []*LayoutNode

    // 2. 分离普通流子元素和绝对定位子元素
    if len(node.Children) > 0 {
        // 创建一个新的 Children 切片用于布局计算，排除 Absolute 元素
        flowChildren := make([]*LayoutNode, 0, len(node.Children))
        for _, child := range node.Children {
            if child.Style.Position == PositionAbsolute {
                absChildren = append(absChildren, child)
            } else {
                flowChildren = append(flowChildren, child)
            }
        }

        // 3. 测量普通流 (仅使用 flowChildren)
        if node.Type == LayoutFlex {
            size = e.MeasureFlex(node, flowChildren, cs) // 需修改 MeasureFlex 签名接受 children
        } else {
            // ... Grid or Block ...
        }
    } else if node.Component != nil {
        // ... Leaf component measure ...
    }

    // 4. 测量绝对定位子元素
    // 绝对定位元素的参照物是当前容器 (Padding Box)
    // 它们的大小不影响当前容器的 size
    for _, child := range absChildren {
        // 计算绝对定位的约束
        // 例如：如果设置了 Left=0, Right=0，则宽度被强制为容器宽度
        absCs := e.calculateAbsoluteConstraints(child, size)
        e.Measure(child, absCs)
    }

    node.ComputedSize = size
    return size
}

// 计算绝对定位子元素的约束
func (e *Engine) calculateAbsoluteConstraints(node *LayoutNode, parentSize Size) BoxConstraints {
    style := node.Style
    minW, maxW := 0, parentSize.Width
    minH, maxH := 0, parentSize.Height

    // 如果同时设定了 Left 和 Right，则宽度固定
    if style.Left != nil && style.Right != nil {
        width := parentSize.Width - *style.Left - *style.Right
        minW, maxW = width, width
    }
    // ... Top/Bottom 同理 ...

    return BoxConstraints{MinWidth: minW, MaxWidth: maxW, MinHeight: minH, MaxHeight: maxH}
}

```

### 3. 事件交互与命中测试 (`tui/layout/renderer.go`)

在之前的重构中，我们引入了 `RenderBuffer`。现在利用它来实现精确的鼠标点击事件处理。这对于 TUI 中的 Tab 切换、列表点击至关重要。

**实现建议：**

```go
// HitTest 查找给定坐标下的组件 ID
// 优先返回 Z-Index 最高的元素
func (r *Renderer) HitTest(x, y int) (string, bool) {
    if x < 0 || y < 0 || x >= r.buffer.Width || y >= r.buffer.Height {
        return "", false
    }

    cell := r.buffer.Cells[y][x]
    if cell.NodeID != "" {
        return cell.NodeID, true
    }

    return "", false
}

// 集成到 Update 循环 (在 Model 中)
func (m *Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
    switch msg := msg.(type) {
    case tea.MouseMsg:
        if msg.Type == tea.MouseLeft {
            // 使用 Renderer 进行命中测试
            if targetID, ok := m.Renderer.HitTest(msg.X, msg.Y); ok {
                // 分发事件给对应组件
                return m.dispatchClickEvent(targetID, msg)
            }
        }
    }
    // ...
}

```

### 4. 样式解析的防腐层 (`tui/layout/style.go`)

目前的 `builder.go` 承担了过多的样式构造职责。建议引入 `StyleSheet` 概念，将字符串样式（如 "width: 100px; color: red"）解析为引擎可理解的结构。

**代码实现建议：**

```go
package layout

// ParseStyle 将 DSL 中的 map 或 string 转换为 LayoutStyle
func ParseStyle(raw interface{}) *LayoutStyle {
    style := &LayoutStyle{
        Width: Auto(),
        Height: Auto(),
        // Defaults...
    }

    props, ok := raw.(map[string]interface{})
    if !ok {
        return style
    }

    // 解析尺寸
    if w, ok := props["width"]; ok {
        style.Width = parseDimension(w)
    }

    // 解析 Flex
    if display, ok := props["display"].(string); ok && display == "flex" {
        style.Display = DisplayFlex
    }

    // ... 其他属性解析

    return style
}

func parseDimension(v interface{}) Dimension {
    switch val := v.(type) {
    case int:
        return Px(val)
    case float64:
        return Px(int(val))
    case string:
        if strings.HasSuffix(val, "%") {
            // 解析百分比
        } else if strings.HasSuffix(val, "fr") {
            // 解析 Fr
        }
    }
    return Auto()
}

```

### 总结：完整重构清单

1. **Types (`layout/types.go`, `layout/geometry.go`)**:

- 引入 `UnitType`, `Dimension`, `BoxConstraints`。
- 废弃 `interface{}` 类型的宽高定义。

2. **Engine Core (`layout/engine.go`)**:

- 将 `Layout()` 拆分为 `Measure()` (自底向上) 和 `Arrange()` (自顶向下)。
- 实现绝对定位元素的“脱离文档流”测量逻辑。

3. **Algorithms (`layout/flex.go`, `layout/grid.go`)**:

- `Flex`: 实现双 Pass 算法（测量 Intrinsic -> 分配 Grow/Shrink）。
- `Grid`: 实现轨道计算逻辑。

4. **Renderer (`layout/renderer.go`, `layout/buffer.go`)**:

- 引入 `Cell` 和 `RenderBuffer`。
- 实现 Z-Index 覆盖逻辑。
- 提供 `HitTest(x, y)` API。

5. **Adapters (`core/types.go`, `components/*.go`)**:

- 在 `ComponentInterface` 中增加 `Measurable` 接口。
- 更新 `Text`, `Input` 等基础组件实现 `Measure` 方法。

通过这五个步骤的落地，Yao TUI 将能够处理类似 Dashboard 仪表盘、复杂表单、以及带遮罩层的模态框等高级 UI 场景。

基于之前的分析，我们已经确立了**约束驱动（Constraint-Based）**和**双阶段布局（Measure/Arrange）**的核心架构。

接下来，为了达成“类似 CSS 的复杂布局处理”这一目标，我们需要深入解决最棘手的两个问题：**Grid 网格布局的约束实现**以及**绝对定位（Absolute Positioning）与文档流的交互**。此外，我们还将完善**事件命中测试（Hit Testing）**，这是虚拟画布带来的额外红利。

以下是具体的深度分析与代码实现建议：

### 1. 复杂网格布局 (`tui/layout/grid.go`)

目前的 `layoutGrid` 实现过于简单（硬编码列数）。真正的 Grid 需要处理轨道（Tracks）的尺寸计算，支持 `fr` 单位。

**约束策略分析：**

1. **轨道计算**：首先计算所有固定宽度（Pixel）和百分比（Percent）的列。
2. **Auto 处理**：对于设置为 `auto` 的列，需要先测量该列中所有单元格的内容最大宽度。
3. **Fr 分配**：将剩余空间按比例分配给 `fr` 单位的列。
4. **单元格测量**：确定了所有行高列宽后，对每个子元素施加严格约束（Tight Constraints）进行最终测量。

**代码实现建议 (`tui/layout/grid.go`)：**

```go
package layout

// GridTrack 定义行列轨道配置
type GridTrack struct {
    Size  Dimension // 比如: 1fr, 100px, 20%
    Min   int       // 最小尺寸
    Max   int       // 最大尺寸
}

// MeasureGrid 执行网格布局计算
func (e *Engine) MeasureGrid(node *LayoutNode, cs BoxConstraints) Size {
    // 假设 node.Style.GridTemplateColumns 包含了轨道定义
    colTracks := node.Style.GridTemplateColumns
    // rowTracks := node.Style.GridTemplateRows

    // 1. 初始化列宽数组
    colWidths := make([]int, len(colTracks))
    availableWidth := cs.MaxWidth
    usedWidth := 0
    totalFr := 0.0

    // 2. Pass 1: 解析固定值和百分比
    for i, track := range colTracks {
        if track.Size.Unit == UnitPixel {
            colWidths[i] = int(track.Size.Value)
            usedWidth += colWidths[i]
        } else if track.Size.Unit == UnitFr {
            totalFr += track.Size.Value
        }
    }

    // 3. Pass 2: 处理 Auto (需要测量内容)
    // 这是一个简化实现，通常需要两次遍历
    for i, track := range colTracks {
        if track.Size.Unit == UnitAuto {
            // 找到该列所有的子元素，测量它们的最大 IntrinsicWidth
            maxContentWidth := 0
            for _, child := range e.getChildrenInColumn(node, i) {
                // 给一个宽松的约束进行试探
                s := e.Measure(child, cs.Loosen())
                if s.Width > maxContentWidth {
                    maxContentWidth = s.Width
                }
            }
            colWidths[i] = maxContentWidth
            usedWidth += maxContentWidth
        }
    }

    // 4. Pass 3: 分配 Fr 空间
    remaining := availableWidth - usedWidth
    if remaining > 0 && totalFr > 0 {
        for i, track := range colTracks {
            if track.Size.Unit == UnitFr {
                w := int(float64(remaining) * (track.Size.Value / totalFr))
                colWidths[i] = w
                usedWidth += w // 注意：可能会有舍入误差，需要最后修正
            }
        }
    }

    // 5. 测量所有子节点
    // 既然列宽已定，我们可以生成严格的约束
    maxHeight := 0
    // ... 遍历行逻辑类似，计算 rowHeights ...

    for i, child := range node.Children {
        // 计算子元素所在的 col 和 row
        col := i % len(colTracks)
        // row := i / len(colTracks)

        targetW := colWidths[col]
        // targetH := rowHeights[row]

        // 强制子元素适应单元格大小
        childSize := e.Measure(child, BoxConstraintsTight(targetW, 0 /* or targetH */))

        // 更新容器高度
        if childSize.Height > maxHeight {
            maxHeight = childSize.Height
        }
    }

    return Size{Width: usedWidth, Height: maxHeight}
}

// 辅助方法：获取某一列的所有子元素
func (e *Engine) getChildrenInColumn(node *LayoutNode, colIndex int) []*LayoutNode {
    // 简单实现假设顺序填充
    cols := len(node.Style.GridTemplateColumns)
    var children []*LayoutNode
    for i, child := range node.Children {
        if i % cols == colIndex {
            children = append(children, child)
        }
    }
    return children
}

```

### 2. 绝对定位的深度集成 (`tui/layout/engine.go`)

绝对定位元素不占据文档流空间，这在 `Measure` 阶段必须特殊处理：容器的大小仅由**非绝对定位**的子元素决定，但绝对定位的子元素需要基于容器的 Padding Box 进行测量。

**重构建议 (`engine.go` 中的 `Measure` 方法更新)：**

```go
func (e *Engine) Measure(node *LayoutNode, cs BoxConstraints) Size {
    if node == nil { return Size{} }

    // 1. 样式约束修正
    // ... apply style constraints ...

    var size Size
    var absChildren []*LayoutNode

    // 2. 分离普通流子元素和绝对定位子元素
    if len(node.Children) > 0 {
        // 创建一个新的 Children 切片用于布局计算，排除 Absolute 元素
        flowChildren := make([]*LayoutNode, 0, len(node.Children))
        for _, child := range node.Children {
            if child.Style.Position == PositionAbsolute {
                absChildren = append(absChildren, child)
            } else {
                flowChildren = append(flowChildren, child)
            }
        }

        // 3. 测量普通流 (仅使用 flowChildren)
        if node.Type == LayoutFlex {
            size = e.MeasureFlex(node, flowChildren, cs) // 需修改 MeasureFlex 签名接受 children
        } else {
            // ... Grid or Block ...
        }
    } else if node.Component != nil {
        // ... Leaf component measure ...
    }

    // 4. 测量绝对定位子元素
    // 绝对定位元素的参照物是当前容器 (Padding Box)
    // 它们的大小不影响当前容器的 size
    for _, child := range absChildren {
        // 计算绝对定位的约束
        // 例如：如果设置了 Left=0, Right=0，则宽度被强制为容器宽度
        absCs := e.calculateAbsoluteConstraints(child, size)
        e.Measure(child, absCs)
    }

    node.ComputedSize = size
    return size
}

// 计算绝对定位子元素的约束
func (e *Engine) calculateAbsoluteConstraints(node *LayoutNode, parentSize Size) BoxConstraints {
    style := node.Style
    minW, maxW := 0, parentSize.Width
    minH, maxH := 0, parentSize.Height

    // 如果同时设定了 Left 和 Right，则宽度固定
    if style.Left != nil && style.Right != nil {
        width := parentSize.Width - *style.Left - *style.Right
        minW, maxW = width, width
    }
    // ... Top/Bottom 同理 ...

    return BoxConstraints{MinWidth: minW, MaxWidth: maxW, MinHeight: minH, MaxHeight: maxH}
}

```

### 3. 事件交互与命中测试 (`tui/layout/renderer.go`)

在之前的重构中，我们引入了 `RenderBuffer`。现在利用它来实现精确的鼠标点击事件处理。这对于 TUI 中的 Tab 切换、列表点击至关重要。

**实现建议：**

```go
// HitTest 查找给定坐标下的组件 ID
// 优先返回 Z-Index 最高的元素
func (r *Renderer) HitTest(x, y int) (string, bool) {
    if x < 0 || y < 0 || x >= r.buffer.Width || y >= r.buffer.Height {
        return "", false
    }

    cell := r.buffer.Cells[y][x]
    if cell.NodeID != "" {
        return cell.NodeID, true
    }

    return "", false
}

// 集成到 Update 循环 (在 Model 中)
func (m *Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
    switch msg := msg.(type) {
    case tea.MouseMsg:
        if msg.Type == tea.MouseLeft {
            // 使用 Renderer 进行命中测试
            if targetID, ok := m.Renderer.HitTest(msg.X, msg.Y); ok {
                // 分发事件给对应组件
                return m.dispatchClickEvent(targetID, msg)
            }
        }
    }
    // ...
}

```

### 4. 样式解析的防腐层 (`tui/layout/style.go`)

目前的 `builder.go` 承担了过多的样式构造职责。建议引入 `StyleSheet` 概念，将字符串样式（如 "width: 100px; color: red"）解析为引擎可理解的结构。

**代码实现建议：**

```go
package layout

// ParseStyle 将 DSL 中的 map 或 string 转换为 LayoutStyle
func ParseStyle(raw interface{}) *LayoutStyle {
    style := &LayoutStyle{
        Width: Auto(),
        Height: Auto(),
        // Defaults...
    }

    props, ok := raw.(map[string]interface{})
    if !ok {
        return style
    }

    // 解析尺寸
    if w, ok := props["width"]; ok {
        style.Width = parseDimension(w)
    }

    // 解析 Flex
    if display, ok := props["display"].(string); ok && display == "flex" {
        style.Display = DisplayFlex
    }

    // ... 其他属性解析

    return style
}

func parseDimension(v interface{}) Dimension {
    switch val := v.(type) {
    case int:
        return Px(val)
    case float64:
        return Px(int(val))
    case string:
        if strings.HasSuffix(val, "%") {
            // 解析百分比
        } else if strings.HasSuffix(val, "fr") {
            // 解析 Fr
        }
    }
    return Auto()
}

```

### 总结：完整重构清单

1. **Types (`layout/types.go`, `layout/geometry.go`)**:

- 引入 `UnitType`, `Dimension`, `BoxConstraints`。
- 废弃 `interface{}` 类型的宽高定义。

2. **Engine Core (`layout/engine.go`)**:

- 将 `Layout()` 拆分为 `Measure()` (自底向上) 和 `Arrange()` (自顶向下)。
- 实现绝对定位元素的“脱离文档流”测量逻辑。

3. **Algorithms (`layout/flex.go`, `layout/grid.go`)**:

- `Flex`: 实现双 Pass 算法（测量 Intrinsic -> 分配 Grow/Shrink）。
- `Grid`: 实现轨道计算逻辑。

4. **Renderer (`layout/renderer.go`, `layout/buffer.go`)**:

- 引入 `Cell` 和 `RenderBuffer`。
- 实现 Z-Index 覆盖逻辑。
- 提供 `HitTest(x, y)` API。

5. **Adapters (`core/types.go`, `components/*.go`)**:

- 在 `ComponentInterface` 中增加 `Measurable` 接口。
- 更新 `Text`, `Input` 等基础组件实现 `Measure` 方法。

通过这五个步骤的落地，Yao TUI 将能够处理类似 Dashboard 仪表盘、复杂表单、以及带遮罩层的模态框等高级 UI 场景。

这是一个非常完整且具备高度可行性的重构方案。它不仅解决了当前的痛点（自动高度、层叠遮挡），还引入了现代 GUI 框架的核心特性（约束布局、虚拟画布）。

为了确保该方案能够顺利**落地（Production Ready）**，在实施前我需要补充**两个关键的缺失环节**，这两个细节决定了重构的成败：

1. **ANSI 转译器（ANSI Parser）**：因为现有的 Bubble Tea 组件（包括 Lipgloss）输出的是带 ANSI 转义码的字符串，而我们的新渲染器是基于 `Cell`（单元格）的。我们需要一个高效的解析器将 `View()` 的字符串结果“拆解”并填入 `RenderBuffer`。
2. **事件分发闭环（Event Dispatch Loop）**：有了 `HitTest` 只是第一步，我们需要在 `tui/model.go` 的 `Update` 循环中拦截鼠标消息，并根据 Z-Index 准确分发给对应的组件。

以下是针对这两个缺失环节的**补充代码实现建议**，加上这部分后，方案就完整了。

### 1. 补充：ANSI 字符串转译器 (`tui/layout/ansi.go`)

这是连接旧世界（Bubble Tea 组件）和新世界（Virtual Canvas）的桥梁。

```go
package layout

import (
	"github.com/charmbracelet/lipgloss"
	"github.com/muesli/reflow/ansi"
)

// WriteANSI 将带有 ANSI 样式的字符串写入缓冲区
// 这是新渲染引擎兼容现有组件的关键函数
func (b *RenderBuffer) WriteANSI(startX, startY, zIndex int, content string, nodeID string) {
	// 使用 reflow/ansi 或简单的状态机解析 ANSI 码
	// 这里提供一个简化逻辑，实际生产建议使用成熟的 ANSI 解析库

	x, y := startX, startY
	runes := []rune(content)

	// 当前激活的样式
	var currentStyle lipgloss.Style

	for i := 0; i < len(runes); i++ {
		r := runes[i]

		// 处理换行
		if r == '\n' {
			y++
			x = startX
			continue
		}

		// 处理 ANSI 转义序列 (简化版：跳过或解析颜色)
		// 在实际实现中，这里需要提取颜色代码并更新 currentStyle
		if r == '\x1b' {
			// ... 解析 ANSI code，更新 currentStyle ...
			// 建议引入 "github.com/muesli/termenv" 或自己写一个小型状态机
			// 这里的逻辑稍微复杂，为了代码简洁，假设已解析出 style
			continue
		}

		// 写入单元格
		if x >= 0 && x < b.Width && y >= 0 && y < b.Height {
			// 只有当 Z-Index 更高时才覆盖
			if zIndex >= b.Cells[y][x].ZIndex {
				b.Cells[y][x] = Cell{
					Char:   r,
					Style:  currentStyle,
					NodeID: nodeID,
					ZIndex: zIndex,
				}
			}
		}
		x++
	}
}

```

### 2. 补充：事件分发集成 (`tui/model.go`)

在主循环中利用新的布局引擎进行事件路由。

```go
// tui/model.go

func (m *Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	var cmds []tea.Cmd

	switch msg := msg.(type) {

	// 窗口大小调整：触发重新测量 (Measure)
	case tea.WindowSizeMsg:
		m.Width = msg.Width
		m.Height = msg.Height
		m.LayoutEngine.UpdateWindowSize(msg.Width, msg.Height)
		// 强制标记根节点 Dirty，重新计算布局
		m.LayoutEngine.MarkDirty(m.LayoutEngine.Root())

	// 鼠标事件：利用 HitTest 进行路由
	case tea.MouseMsg:
		// 1. 获取点击位置的组件 ID
		targetID, hit := m.Renderer.HitTest(msg.X, msg.Y)

		if hit && targetID != "" {
			// 2. 包装为定向消息
			targetedMsg := core.TargetedMsg{
				TargetID: targetID,
				InnerMsg: msg,
			}

			// 3. 优先分发给目标组件
			// 注意：这里需要递归遍历组件树或通过注册表查找组件实例
			if component, exists := m.ComponentRegistry.Get(targetID); exists {
				newModel, cmd, response := component.UpdateMsg(targetedMsg)
				if response != core.Ignored {
					return m, cmd
				}
			}
		}
		// 如果没有命中或组件未处理，继续默认流程...
	}

	// ... 原有的 Update 逻辑 ...
	return m, tea.Batch(cmds...)
}

```

### 3. 落地实施检查清单 (Checklist)

为了确保平滑过渡，建议按以下顺序落地：

1. **基础建设 (Day 1-2)**:

- [ ] 创建 `tui/layout/geometry.go` (BoxConstraints, Dimension)。
- [ ] 创建 `tui/layout/buffer.go` (Cell, RenderBuffer)。
- [ ] 实现 `tui/layout/ansi.go` (最简可用的 ANSI 解析)。

2. **核心改造 (Day 3-5)**:

- [ ] 修改 `tui/layout/engine.go`，实现 `Measure` 和 `Arrange` 骨架。
- [ ] 迁移 `Flex` 算法到 `tui/layout/flex.go`。
- [ ] 修改 `tui/layout/renderer.go`，接入 `RenderBuffer`。

3. **组件适配 (Day 6-7)**:

- [ ] 更新 `core.ComponentInterface`，加入 `Measure` 方法。
- [ ] 创建 `DefaultMeasurable` 结构体，让未修改的组件默认返回 "Fill Parent" (填满父容器)，保证旧代码不崩。
- [ ] 重点改造 `Text` 和 `Container` 组件适配新接口。

4. **验证 (Day 8)**:

- [ ] 运行 `tui-list` 演示，检查滚动列表是否正常。
- [ ] 测试弹窗 (Modal) 是否能正确遮挡下方内容且不再受 Flex 布局干扰。

### 结论
