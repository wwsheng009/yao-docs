你好！我是 **Yao Dev**。

在完成第一阶段的基础定义与加载逻辑后，我们现在进入 **第二阶段：核心运行时驱动引擎 (The TUI Driver)**。

这一阶段的任务是实现 Bubble Tea 的 `tea.Model` 接口，并建立 Yao 状态机与终端 UI 之间的“双向桥接”。我们将重点解决**数据响应式绑定**和 **Process 异步执行循环**。

### 阶段 2：运行时驱动与状态管理

#### 2.1 核心驱动程序 (`tui/driver.go`)

这个文件是 TUI 的“心脏”，负责处理初始化、事件分发和视图聚合。

```go
package tui

import (
	tea "github.com/charmbracelet/bubbletea"
	"github.com/yaoapp/yao/widgets/component"
)

// Model 实现 tea.Model 接口
type Model struct {
	Config   *Config
	State    map[string]interface{}
	Width    int
	Height   int
	Ready    bool
}

// NewModel 创建一个新的 TUI 实例
func NewModel(cfg *Config, args map[string]interface{}) *Model {
	state := make(map[string]interface{})
	// 合并初始数据
	for k, v := range cfg.Data {
		state[k] = v
	}
	// 合并传入参数
	for k, v := range args {
		state[k] = v
	}
	return &Model{
		Config: cfg,
		State:  state,
	}
}

// Init 初始化生命周期
func (m *Model) Init() tea.Cmd {
	if m.Config.OnLoad != nil {
		return m.ExecuteAction(*m.Config.OnLoad)
	}
	return nil
}

// Update 统一消息处理
func (m *Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	var cmds []tea.Cmd

	switch msg := msg.(type) {
	case tea.WindowSizeMsg:
		m.Width = msg.Width
		m.Height = msg.Height
		m.Ready = true

	case tea.KeyMsg:
		// 匹配全局快捷键
		if act, ok := m.Config.Bindings[msg.String()]; ok {
			cmds = append(cmds, m.ExecuteAction(act))
		}

	case ProcessResultMsg:
		// 更新状态机并触发重新渲染
		m.State[msg.Target] = msg.Data
		// 这里可以扩展：根据 Target 找到对应的子组件通知更新
	}

	return m, tea.Batch(cmds...)
}

// View 视图聚合渲染
func (m *Model) View() string {
	if !m.Ready {
		return "正在初始化 Yao TUI..."
	}
	// 第三阶段将实现递归布局渲染逻辑
	return m.RenderLayout(m.Config.Layout)
}

```

#### 2.2 异步 Action 执行器 (`tui/action.go`)

这是 Yao 与 TUI 交互的关键桥梁，它利用 `gou/process` 执行逻辑并将结果泵回 UI。

```go
package tui

import (
	tea "github.com/charmbracelet/bubbletea"
	"github.com/yaoapp/gou/process"
	"github.com/yaoapp/yao/pipe"
)

// ExecuteAction 将 Action 转换为 tea.Cmd
func (m *Model) ExecuteAction(act Action) tea.Cmd {
	return func() tea.Msg {
		// 1. 处理参数插值 ({{}})
		// 复用 Yao 的 pipe.Replace 逻辑解析表达式
		args := make([]interface{}, len(act.Args))
		for i, arg := range act.Args {
			args[i] = pipe.Replace(arg, m.State)
		}

		// 2. 执行 Yao Process
		p := process.New(act.Process, args...)
		res, err := p.Exec()
		if err != nil {
			return ErrorMsg(err) // 错误处理消息
		}

		// 3. 返回结果消息
		if act.OnSuccess != "" {
			return ProcessResultMsg{
				Target: act.OnSuccess,
				Data:   res,
			}
		}
		return nil
	}
}

// ErrorMsg 错误消息定义
type ErrorMsg error

```

#### 2.3 数据绑定与表达式解析逻辑

我们需要确保在渲染时，`Props` 里的表达式能够被实时替换。

```go
// 在驱动中添加解析方法
func (m *Model) applyState(props map[string]interface{}) map[string]interface{} {
	newProps := make(map[string]interface{})
	for k, v := range props {
		// 递归解析字符串中的 {{path}}
		newProps[k] = pipe.Replace(v, m.State)
	}
	return newProps
}

```

---

### 第二阶段要点说明：

1. **非阻塞架构**：所有的 `Process` 调用都被封装在 `tea.Cmd` 中。这意味着当你在终端请求一个耗时的 AI 模型（如 `aigc.chat`）时，UI 仍能响应按键和缩放，不会导致终端卡死。
2. **状态驱动**：UI 不直接持有数据。所有的组件在 `View()` 方法执行时，都会通过 `applyState` 从中央状态机获取最新的值。
3. **快捷键解耦**：通过 `Bindings` 配置，开发者可以轻松地在 JSON 中定义如 `ctrl+s` 触发保存 Process。

**下一步（第三批次）我们将完成：**

1. `tui/render.go`：基于 Lip Gloss 的递归布局引擎（实现 `direction` 和 `flex` 布局）。
2. `tui/components/`：实现首批核心组件（`Table` 和 `Chat` 视图）。
3. `tui/api.go`：导出 `tui.Update` 处理器，允许外部（如 JS 或 Flow）主动推送数据到 UI。

这部分代码是驱动 TUI 运转的逻辑中枢。你是否需要我先给出一份完整的 `ProcessResultMsg` 的深度合并逻辑代码，以支持复杂嵌套状态的局部更新？
