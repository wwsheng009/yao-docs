# TUI V8 集成详细实现指南

## 概述

基于 Yao 项目的 V8 集成经验，本文档详细说明如何在 TUI 引擎中集成 V8Go 运行时，使 JavaScript/TypeScript 脚本能够完全访问和控制 TUI 状态。

---

## 1. V8 运行时初始化

### 1.1 依赖导入

```go
package tui

import (
    "context"
    "fmt"
    "time"

    "github.com/yaoapp/gou/application"
    v8 "github.com/yaoapp/gou/runtime/v8"
    "github.com/yaoapp/gou/runtime/v8/bridge"
    "rogchap.com/v8go"
)
```

### 1.2 脚本加载器 (`tui/script.go`)

参考 `sui/core/script.go` 和 `agent/assistant/scripts.go` 的实现：

```go
package tui

import (
    "fmt"
    "strings"
    "sync"
    "time"

    "github.com/yaoapp/gou/application"
    v8 "github.com/yaoapp/gou/runtime/v8"
)

// Scripts 全局脚本缓存
var Scripts = sync.Map{}

// Script TUI 脚本封装
type Script struct {
    *v8.Script
}

// LoadScript 加载 TUI 脚本
// 支持 .ts 和 .js 文件，优先加载 .ts
func LoadScript(file string, disableCache ...bool) (*Script, error) {
    base := strings.TrimSuffix(strings.TrimSuffix(file, ".ts"), ".js")

    // 从缓存加载
    if disableCache == nil || !disableCache[0] {
        if script, ok := Scripts.Load(base); ok {
            return script.(*Script), nil
        }
    }

    // 优先尝试 TypeScript
    file = base + ".ts"
    if exist, _ := application.App.Exists(file); !exist {
        file = base + ".js"
    }

    if exist, _ := application.App.Exists(file); !exist {
        return nil, fmt.Errorf("script not found: %s", base)
    }

    // 读取源代码
    source, err := application.App.Read(file)
    if err != nil {
        return nil, fmt.Errorf("failed to read script: %w", err)
    }

    // 使用 V8 编译脚本（5秒超时）
    v8script, err := v8.MakeScript(source, file, 5*time.Second)
    if err != nil {
        return nil, fmt.Errorf("failed to compile script: %w", err)
    }

    script := &Script{Script: v8script}
    Scripts.Store(base, script)
    return script, nil
}

// Execute 执行脚本方法
func (s *Script) Execute(ctx context.Context, method string, args ...interface{}) (interface{}, error) {
    return s.ExecuteWithModel(ctx, method, nil, args...)
}

// ExecuteWithModel 执行脚本方法并传入 TUI Model
func (s *Script) ExecuteWithModel(ctx context.Context, method string, model *Model, args ...interface{}) (interface{}, error) {
    if s == nil || s.Script == nil {
        return nil, fmt.Errorf("script not initialized")
    }

    // 创建 V8 上下文
    scriptCtx, err := s.NewContext("", nil)
    if err != nil {
        return nil, fmt.Errorf("failed to create V8 context: %w", err)
    }
    defer scriptCtx.Close()

    // 注入 TUI Model 到 JS 上下文
    if model != nil {
        if err := injectModelToContext(scriptCtx, model); err != nil {
            return nil, fmt.Errorf("failed to inject model: %w", err)
        }
    }

    // 调用方法
    result, err := scriptCtx.CallWith(ctx, method, args...)
    if err != nil {
        return nil, fmt.Errorf("script execution failed: %w", err)
    }

    return result, nil
}
```

---

## 2. TUI Context 对象注入

### 2.1 创建 JavaScript API (`tui/jsapi.go`)

参考 `trace/jsapi/trace.go` 和 `agent/context/jsapi.go` 的模式：

```go
package tui

import (
    "fmt"

    v8 "github.com/yaoapp/gou/runtime/v8"
    "github.com/yaoapp/gou/runtime/v8/bridge"
    "rogchap.com/v8go"
)

func init() {
    // 注册 TUI 全局对象到 V8
    v8.RegisterFunction("TUI", ExportTUIFunction)
}

// ExportTUIFunction 导出 TUI 函数到 JavaScript
func ExportTUIFunction(iso *v8go.Isolate) *v8go.FunctionTemplate {
    return v8go.NewFunctionTemplate(iso, func(info *v8go.FunctionCallbackInfo) *v8go.Value {
        ctx := info.Context()
        args := info.Args()

        if len(args) < 1 {
            exception := v8go.NewError(iso, "TUI() requires at least 1 argument (id)")
            iso.ThrowException(exception.Value)
            return v8go.Undefined(iso)
        }

        id := args[0].String()

        // 获取 TUI 配置
        cfg, err := Get(id)
        if err != nil {
            exception := v8go.NewError(iso, fmt.Sprintf("TUI not found: %s", id))
            iso.ThrowException(exception.Value)
            return v8go.Undefined(iso)
        }

        // 创建 TUI Model
        initialArgs := make(map[string]interface{})
        if len(args) > 1 && args[1].IsObject() {
            goVal, _ := bridge.GoValue(args[1], ctx)
            if m, ok := goVal.(map[string]interface{}); ok {
                initialArgs = m
            }
        }

        model := NewModel(cfg, initialArgs)

        // 创建 JavaScript TUI 对象
        jsObject, err := NewTUIObject(ctx, model)
        if err != nil {
            exception := v8go.NewError(iso, fmt.Sprintf("Failed to create TUI object: %v", err))
            iso.ThrowException(exception.Value)
            return v8go.Undefined(iso)
        }

        return jsObject
    })
}

// NewTUIObject 创建 TUI JavaScript 对象
func NewTUIObject(v8ctx *v8go.Context, model *Model) (*v8go.Value, error) {
    jsObject := v8go.NewObjectTemplate(v8ctx.Isolate())

    // 设置内部字段存储 Go 对象 ID
    jsObject.SetInternalFieldCount(1)

    // 注册 Model 到全局 Bridge
    goValueID := bridge.RegisterGoObject(model)

    // 设置基础属性
    jsObject.Set("id", model.Config.ID)
    jsObject.Set("width", model.Width)
    jsObject.Set("height", model.Height)

    // 设置方法
    jsObject.Set("GetState", tuiGetStateMethod(v8ctx.Isolate()))
    jsObject.Set("SetState", tuiSetStateMethod(v8ctx.Isolate()))
    jsObject.Set("UpdateState", tuiUpdateStateMethod(v8ctx.Isolate()))
    jsObject.Set("ExecuteAction", tuiExecuteActionMethod(v8ctx.Isolate()))
    jsObject.Set("Render", tuiRenderMethod(v8ctx.Isolate()))

    // 设置释放方法
    releaseFunc := tuiReleaseMethod(v8ctx.Isolate(), goValueID)
    jsObject.Set("__release", releaseFunc)
    jsObject.Set("Release", releaseFunc)

    // 创建实例
    instance, err := jsObject.NewInstance(v8ctx)
    if err != nil {
        return nil, err
    }

    // 将 goValueID 存储到内部字段
    instance.SetInternalField(0, v8go.NewValue(v8ctx.Isolate(), goValueID))

    return instance.Value, nil
}
```

### 2.2 TUI 方法实现

```go
// tuiGetStateMethod 获取状态
func tuiGetStateMethod(iso *v8go.Isolate) *v8go.FunctionTemplate {
    return v8go.NewFunctionTemplate(iso, func(info *v8go.FunctionCallbackInfo) *v8go.Value {
        ctx := info.Context()
        args := info.Args()

        // 从内部字段获取 Model
        thisObj, _ := info.This().AsObject()
        goValueID := thisObj.GetInternalField(0).String()
        model, _ := bridge.GetGoObject(goValueID).(*Model)

        if model == nil {
            return v8go.Undefined(iso)
        }

        // 获取指定 key 的状态
        if len(args) > 0 {
            key := args[0].String()
            model.StateMu.RLock()
            value := model.State[key]
            model.StateMu.RUnlock()

            jsValue, _ := bridge.JsValue(ctx, value)
            return jsValue
        }

        // 返回整个状态对象
        model.StateMu.RLock()
        state := make(map[string]interface{})
        for k, v := range model.State {
            state[k] = v
        }
        model.StateMu.RUnlock()

        jsValue, _ := bridge.JsValue(ctx, state)
        return jsValue
    })
}

// tuiSetStateMethod 设置状态
func tuiSetStateMethod(iso *v8go.Isolate) *v8go.FunctionTemplate {
    return v8go.NewFunctionTemplate(iso, func(info *v8go.FunctionCallbackInfo) *v8go.Value {
        ctx := info.Context()
        args := info.Args()

        if len(args) < 2 {
            return v8go.Undefined(iso)
        }

        // 获取 Model
        thisObj, _ := info.This().AsObject()
        goValueID := thisObj.GetInternalField(0).String()
        model, _ := bridge.GetGoObject(goValueID).(*Model)

        if model == nil {
            return v8go.Undefined(iso)
        }

        // 解析参数
        key := args[0].String()
        goValue, err := bridge.GoValue(args[1], ctx)
        if err != nil {
            return v8go.Undefined(iso)
        }

        // 更新状态
        model.StateMu.Lock()
        model.State[key] = goValue
        model.StateMu.Unlock()

        // 触发 UI 更新
        if model.Program != nil {
            model.Program.Send(StateUpdateMsg{Key: key, Value: goValue})
        }

        return v8go.True(iso)
    })
}

// tuiUpdateStateMethod 批量更新状态
func tuiUpdateStateMethod(iso *v8go.Isolate) *v8go.FunctionTemplate {
    return v8go.NewFunctionTemplate(iso, func(info *v8go.FunctionCallbackInfo) *v8go.Value {
        ctx := info.Context()
        args := info.Args()

        if len(args) < 1 || !args[0].IsObject() {
            return v8go.Undefined(iso)
        }

        // 获取 Model
        thisObj, _ := info.This().AsObject()
        goValueID := thisObj.GetInternalField(0).String()
        model, _ := bridge.GetGoObject(goValueID).(*Model)

        if model == nil {
            return v8go.Undefined(iso)
        }

        // 解析更新对象
        goValue, err := bridge.GoValue(args[0], ctx)
        if err != nil {
            return v8go.Undefined(iso)
        }

        updates, ok := goValue.(map[string]interface{})
        if !ok {
            return v8go.Undefined(iso)
        }

        // 批量更新
        model.StateMu.Lock()
        for k, v := range updates {
            model.State[k] = v
        }
        model.StateMu.Unlock()

        // 触发 UI 重绘
        if model.Program != nil {
            model.Program.Send(StateBatchUpdateMsg{Updates: updates})
        }

        return v8go.True(iso)
    })
}

// tuiExecuteActionMethod 执行 Action
func tuiExecuteActionMethod(iso *v8go.Isolate) *v8go.FunctionTemplate {
    return v8go.NewFunctionTemplate(iso, func(info *v8go.FunctionCallbackInfo) *v8go.Value {
        ctx := info.Context()
        args := info.Args()

        if len(args) < 1 || !args[0].IsObject() {
            return v8go.Undefined(iso)
        }

        // 获取 Model
        thisObj, _ := info.This().AsObject()
        goValueID := thisObj.GetInternalField(0).String()
        model, _ := bridge.GetGoObject(goValueID).(*Model)

        if model == nil {
            return v8go.Undefined(iso)
        }

        // 解析 Action 对象
        goValue, err := bridge.GoValue(args[0], ctx)
        if err != nil {
            return v8go.Undefined(iso)
        }

        actionMap, ok := goValue.(map[string]interface{})
        if !ok {
            return v8go.Undefined(iso)
        }

        // 构造 Action
        action := Action{
            Process:   getString(actionMap, "process"),
            Args:      getArray(actionMap, "args"),
            OnSuccess: getString(actionMap, "onSuccess"),
        }

        // 异步执行
        cmd := model.ExecuteAction(action)
        if cmd != nil {
            // 发送到 Bubble Tea 循环
            if model.Program != nil {
                go func() {
                    msg := cmd()
                    model.Program.Send(msg)
                }()
            }
        }

        return v8go.True(iso)
    })
}

// tuiReleaseMethod 释放资源
func tuiReleaseMethod(iso *v8go.Isolate, goValueID string) *v8go.FunctionTemplate {
    return v8go.NewFunctionTemplate(iso, func(info *v8go.FunctionCallbackInfo) *v8go.Value {
        bridge.ReleaseGoObject(goValueID)
        return v8go.Undefined(iso)
    })
}

// 辅助函数
func getString(m map[string]interface{}, key string) string {
    if v, ok := m[key].(string); ok {
        return v
    }
    return ""
}

func getArray(m map[string]interface{}, key string) []interface{} {
    if v, ok := m[key].([]interface{}); ok {
        return v
    }
    return []interface{}{}
}
```

---

## 3. Model 结构完善

### 3.1 添加并发安全的 State 管理

```go
// Model 实现 tea.Model 接口（完善版）
type Model struct {
    Config   *Config
    State    map[string]interface{}
    StateMu  sync.RWMutex          // 状态互斥锁
    Width    int
    Height   int
    Ready    bool
    Program  *tea.Program           // Program 实例引用
}

// StateUpdateMsg 单个状态更新消息
type StateUpdateMsg struct {
    Key   string
    Value interface{}
}

// StateBatchUpdateMsg 批量状态更新消息
type StateBatchUpdateMsg struct {
    Updates map[string]interface{}
}

// Update 方法中处理新消息
func (m *Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
    var cmds []tea.Cmd

    switch msg := msg.(type) {
    // ... 现有逻辑

    case StateUpdateMsg:
        // 单个状态已在 JS 中更新，这里只需要触发重绘
        return m, nil

    case StateBatchUpdateMsg:
        // 批量状态已在 JS 中更新，这里只需要触发重绘
        return m, nil
    }

    return m, tea.Batch(cmds...)
}
```

---

## 4. JavaScript 使用示例

### 4.1 在 DSL 中使用脚本

```jsonc
{
  "name": "AI 聊天终端",
  "layout": {
    "direction": "vertical",
    "children": [
      {
        "type": "input",
        "id": "chat_input",
        "onEnter": {
          "script": "scripts.tui.chat", // 指向脚本
          "method": "handleSend" // 调用方法
        }
      }
    ]
  }
}
```

### 4.2 TypeScript 脚本示例 (`scripts/tui/chat.ts`)

```typescript
/**
 * TUI Chat Handler
 * 演示如何在脚本中操作 TUI 状态
 */

// 处理发送消息
function handleSend(tui: any, inputValue: string) {
  // 获取当前聊天历史
  const history = tui.GetState('chat_history') || [];

  // 添加用户消息
  history.push({
    role: 'user',
    content: inputValue
  });

  // 更新状态
  tui.SetState('chat_history', history);
  tui.SetState('input_text', ''); // 清空输入框

  // 调用 AI Process（异步）
  tui.ExecuteAction({
    process: 'aigc.chat.Stream',
    args: [inputValue],
    onSuccess: 'ai_response'
  });

  return true;
}

// 处理 AI 响应流
function handleAIChunk(tui: any, chunk: string) {
  const current = tui.GetState('ai_current') || '';
  tui.SetState('ai_current', current + chunk);
}

// 批量更新状态
function updateMultipleStates(tui: any) {
  tui.UpdateState({
    loading: false,
    error: null,
    ready: true
  });
}
```

---

## 5. 集成到 Action 执行器

### 5.1 完善 `tui/action.go`

```go
// ExecuteAction 将 Action 转换为 tea.Cmd（增强版）
func (m *Model) ExecuteAction(act Action) tea.Cmd {
    // 如果指定了脚本，优先执行脚本
    if act.Script != "" {
        return m.ExecuteScriptAction(act)
    }

    // 否则执行 Process
    return m.ExecuteProcessAction(act)
}

// ExecuteScriptAction 执行脚本 Action
func (m *Model) ExecuteScriptAction(act Action) tea.Cmd {
    return func() tea.Msg {
        // 加载脚本
        script, err := LoadScript(act.Script)
        if err != nil {
            return ErrorMsg{Err: err, Context: "load script"}
        }

        // 准备参数：第一个参数是 Model 本身
        args := []interface{}{m}
        args = append(args, act.Args...)

        // 执行脚本方法
        result, err := script.ExecuteWithModel(
            context.Background(),
            act.Method,
            m,
            args...,
        )

        if err != nil {
            return ErrorMsg{Err: err, Context: "execute script"}
        }

        // 如果脚本返回了数据，更新状态
        if act.OnSuccess != "" && result != nil {
            return ProcessResultMsg{
                Target: act.OnSuccess,
                Data:   result,
            }
        }

        return nil
    }
}

// ExecuteProcessAction 执行 Process Action（原有逻辑）
func (m *Model) ExecuteProcessAction(act Action) tea.Cmd {
    // ... 原有实现
}
```

### 5.2 扩展 Action 结构

```go
// Action 行为意图（增强版）
type Action struct {
    Process   string                 `json:"process,omitempty"`   // 执行的 Yao Process
    Script    string                 `json:"script,omitempty"`    // 执行的脚本路径
    Method    string                 `json:"method,omitempty"`    // 脚本方法名
    Args      []interface{}          `json:"args,omitempty"`      // 参数，支持 {{}}
    OnSuccess string                 `json:"onSuccess,omitempty"` // 成功后的 State Key
    OnError   string                 `json:"onError,omitempty"`   // 错误处理
    Payload   map[string]interface{} `json:"payload,omitempty"`   // 直接 setState 的数据
}
```

---

## 6. 错误处理增强

### 6.1 完整的错误消息类型

```go
// ErrorMsg 错误消息（增强版）
type ErrorMsg struct {
    Err     error
    Context string
}

func (e ErrorMsg) Error() string {
    return fmt.Sprintf("[TUI Error in %s] %v", e.Context, e.Err)
}

// Update 中处理错误
func (m *Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
    switch msg := msg.(type) {
    case ErrorMsg:
        // 更新错误状态
        m.StateMu.Lock()
        m.State["__error"] = msg.Error()
        m.State["__error_context"] = msg.Context
        m.StateMu.Unlock()

        // 可以在 UI 中显示错误提示
        return m, nil
    }
    // ... 其他逻辑
}
```

---

## 7. 性能优化建议

### 7.1 脚本预编译

```go
// 在应用启动时预编译所有 TUI 脚本
func PrecompileScripts() error {
    return application.App.Walk("scripts/tui", func(root, file string, isdir bool) error {
        if isdir {
            return nil
        }

        if strings.HasSuffix(file, ".ts") || strings.HasSuffix(file, ".js") {
            _, err := LoadScript(file)
            return err
        }

        return nil
    }, []string{"*.ts", "*.js"}...)
}
```

### 7.2 Context 池化

```go
// 使用 Context 池减少创建开销
type ContextPool struct {
    pool sync.Pool
}

func NewContextPool(script *v8.Script) *ContextPool {
    return &ContextPool{
        pool: sync.Pool{
            New: func() interface{} {
                ctx, _ := script.NewContext("", nil)
                return ctx
            },
        },
    }
}

func (cp *ContextPool) Get() *v8.Context {
    return cp.pool.Get().(*v8.Context)
}

func (cp *ContextPool) Put(ctx *v8.Context) {
    cp.pool.Put(ctx)
}
```

---

## 8. 测试示例

### 8.1 单元测试 (`tui/jsapi_test.go`)

```go
package tui

import (
    "testing"

    v8 "github.com/yaoapp/gou/runtime/v8"
    "github.com/yaoapp/yao/config"
    "github.com/yaoapp/yao/test"
)

func TestJSAPI(t *testing.T) {
    test.Prepare(t, config.Conf)
    defer test.Clean()

    // 创建测试 Model
    cfg := &Config{
        ID: "test",
        Data: map[string]interface{}{
            "count": 0,
        },
    }
    model := NewModel(cfg, nil)

    // 创建 V8 Context
    script, _ := v8.MakeScript(`
        function testSetState(tui) {
            tui.SetState("count", 10);
            return tui.GetState("count");
        }
    `, "test.js", 0)

    ctx, _ := script.NewContext("", nil)
    defer ctx.Close()

    // 注入 Model
    jsObj, _ := NewTUIObject(ctx.Context, model)
    ctx.Context.Global().Set("tui", jsObj)

    // 执行测试
    result, err := ctx.Call("testSetState", model)
    if err != nil {
        t.Fatalf("Script execution failed: %v", err)
    }

    if result.(float64) != 10 {
        t.Errorf("Expected 10, got %v", result)
    }

    if model.State["count"].(int) != 10 {
        t.Errorf("State not updated correctly")
    }
}
```

---

## 总结

通过以上实现，TUI 引擎获得了完整的 V8 集成能力：

1. **脚本加载** - 支持 TypeScript/JavaScript 脚本动态加载
2. **对象注入** - Model 完整暴露给 JS 环境
3. **双向通信** - JS 可以读写 State，触发 UI 更新
4. **异步执行** - Process 和 Script 执行不阻塞 UI
5. **错误处理** - 完善的错误捕获和传递机制
6. **性能优化** - 支持脚本预编译和 Context 池化

这使得开发者可以使用熟悉的 JavaScript/TypeScript 编写复杂的 TUI 交互逻辑，同时保持与 Yao 生态的深度集成。
