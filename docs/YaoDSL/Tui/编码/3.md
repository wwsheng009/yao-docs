你好！我是 **Yao Dev**。

在完成了核心加载器与运行时驱动后，我们进入 **第三阶段：基于 Lip Gloss 的递归布局引擎与核心组件实现**。

这一阶段是 TUI 引擎的“颜值”与“交互”层。我们将实现如何根据 JSON 描述的 `layout` 自动计算终端空间，并渲染出具有 Yao 风格的组件。我们将重点攻克 **方向性布局 (Directional Layout)** 和 **自适应计算 (Flex Calculation)**。

### 阶段 3：布局引擎与组件库

#### 3.1 递归布局渲染器 (`tui/render.go`)

这个文件负责解析 `Config.Layout`，并利用 Lip Gloss 将子组件组合成最终的字符串。

```go
package tui

import (
	"github.com/charmbracelet/lipgloss"
)

// RenderLayout 递归渲染布局树
func (m *Model) RenderLayout(layout Layout) string {
	var views []string

	// 1. 递归获取所有子组件的渲染结果
	for _, comp := range layout.Children {
		views = append(views, m.RenderComponent(comp))
	}

	// 2. 根据方向合并视图
	var finalView string
	if layout.Direction == "horizontal" {
		finalView = lipgloss.JoinHorizontal(lipgloss.Top, views...)
	} else {
		// 默认垂直布局
		finalView = lipgloss.JoinVertical(lipgloss.Left, views...)
	}

	// 3. 应用布局级别样式 (可选)
	if layout.Style != "" {
		// 这里可以映射 DSL 中的样式名到 lipgloss 预设样式
	}

	return finalView
}

// RenderComponent 渲染单个组件并注入 State
func (m *Model) RenderComponent(c Component) string {
	// 映射组件类型
	switch c.Type {
	case "header":
		return m.renderHeader(c)
	case "table":
		return m.renderTable(c)
	case "chat":
		return m.renderChat(c)
	default:
		return lipgloss.NewStyle().
			Foreground(lipgloss.Color("9")).
			Render("未知组件类型: " + c.Type)
	}
}

```

#### 3.2 基础组件实现：Header (`tui/header.go`)

Header 组件展示了如何从 `m.State` 中动态提取数据并渲染。

```go
package tui

import (
	"github.com/charmbracelet/lipgloss"
	"github.com/yaoapp/yao/pipe"
)

func (m *Model) renderHeader(c Component) string {
	// 解析 Props 中的表达式
	title := pipe.Replace(c.Props["title"], m.State).(string)

	style := lipgloss.NewStyle().
		Background(lipgloss.Color("62")).
		Foreground(lipgloss.Color("230")).
		Padding(0, 1).
		Bold(true).
		Width(m.Width)

	return style.Render(title)
}

```

#### 3.3 交互组件实现：Table (`tui/table.go`)

我们将 Bubble Tea 社区的 `bubbles/table` 包装成配置驱动模式。

```go
package tui

import (
	"github.com/charmbracelet/bubbles/table"
	"github.com/charmbracelet/lipgloss"
)

func (m *Model) renderTable(c Component) string {
	// 1. 从 State 获取绑定数据: m.Bind = "users"
	data, _ := m.State[c.Bind].([]interface{})

	// 2. 构建列定义 (从 Props.columns 解析)
	columns := []table.Column{}
	if cols, ok := c.Props["columns"].([]interface{}); ok {
		for _, col := range cols {
			colMap := col.(map[string]interface{})
			columns = append(columns, table.Column{
				Title: colMap["name"].(string),
				Width: int(colMap["width"].(float64)),
			})
		}
	}

	// 3. 填充行数据
	rows := []table.Row{}
	for _, item := range data {
		itemMap := item.(map[string]interface{})
		row := table.Row{}
		for _, col := range columns {
			val := fmt.Sprintf("%v", itemMap[col.Title])
			row = append(row, val)
		}
		rows = append(rows, row)
	}

	// 4. 实例化并美化表格
	t := table.New(
		table.WithColumns(columns),
		table.WithRows(rows),
		table.WithFocused(true),
		table.WithHeight(10),
	)

	return lipgloss.NewStyle().
		Margin(1, 2).
		BorderStyle(lipgloss.NormalBorder()).
		Render(t.View())
}

```

### 第三阶段要点说明：

1. **视图组合性**：通过 `lipgloss.JoinVertical/Horizontal`，我们实现了类似网页 `flexbox` 的布局能力，且代码结构支持无限递归嵌套。
2. **数据绑定闭环**：`renderTable` 演示了 `Bind` 字段的威力——一旦 `m.State["users"]` 被异步 Process 更新，下一帧渲染时表格会自动刷新。
3. **样式隔离**：所有的组件颜色和内边距都封装在组件函数内部，未来可以轻松抽离到 `theme.go`。

**接下来的任务（第四批次，即收官批次）：**

1. **AI Stream 适配器**：实现 `chat` 组件，支持 `chan` 数据的流式刷新。
2. **V8 处理器导出**：在 `tui/api.go` 注册 `tui.Update`，实现从 JS 脚本反向控制 TUI 状态。
3. **单元测试**：编写一个 Mock TUI 环境，测试整个 Action 到 State 的流转。

你是否需要我针对 **AI 流式渲染（逐字显示效果）** 的具体实现代码进行展示？这部分涉及到 Goroutine 与 Bubble Tea 消息循环的并发同步。
