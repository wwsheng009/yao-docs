你好！我是 **Yao Dev**，高级代码开发工程师。

既然进入了代码编写阶段，我们将严格按照“架构先行、模块推进”的原则。鉴于 TUI 引擎涉及内核集成、DSL 解析及 Bubble Tea 消息循环，我将分为 **3 个批次** 交付代码。

**第一批次：核心定义与 DSL 加载器**。这是整个 TUI 的地基，解决“如何定义”和“如何找到”TUI 资源的问题。

### 阶段 1：数据结构与加载器 (`tui/` 模块)

我们需要在 Yao 源码根目录下创建 `tui` 文件夹，并定义其核心配置协议。

#### 1.1 定义配置结构 (`tui/types.go`)

参考 `yaoapp/yao/pipe/types.go`，我们采用声明式结构。

```go
package tui

import (
	tea "github.com/charmbracelet/bubbletea"
)

// Config TUI 界面配置映射 .tui.yao
type Config struct {
	ID       string                 `json:"id,omitempty"`
	Name     string                 `json:"name,omitempty"`
	Data     map[string]interface{} `json:"data,omitempty"`     // 初始状态
	OnLoad   *Action                `json:"onLoad,omitempty"`   // 加载时执行
	Layout   Layout                 `json:"layout,omitempty"`   // 布局结构
	Bindings map[string]Action      `json:"bindings,omitempty"` // 全局快捷键映射
}

// Layout 布局描述
type Layout struct {
	Direction string      `json:"direction,omitempty"` // vertical, horizontal
	Children  []Component `json:"children,omitempty"`
	Style     string      `json:"style,omitempty"`
}

// Component 组件描述
type Component struct {
	ID    string                 `json:"id,omitempty"`
	Type  string                 `json:"type,omitempty"` // table, form, chat, viewport...
	Bind  string                 `json:"bind,omitempty"` // 绑定 State 中的 Key
	Props map[string]interface{} `json:"props,omitempty"`
	Actions map[string]Action    `json:"actions,omitempty"` // 组件内事件
}

// Action 行为意图
type Action struct {
	Process   string                 `json:"process,omitempty"` // 执行的 Yao Process
	Args      []interface{}          `json:"args,omitempty"`    // 参数，支持 {{}}
	OnSuccess string                 `json:"onSuccess,omitempty"` // 成功后的 State Key
	Payload   map[string]interface{} `json:"payload,omitempty"` // 直接 setState 的数据
}

// ProcessResultMsg Process 执行完后的内部消息
type ProcessResultMsg struct {
	Target string
	Data   interface{}
}

```

#### 1.2 实现全局加载器 (`tui/loader.go`)

参考 `yaoapp/yao/engine/load.go` 中的资源注册逻辑。

```go
package tui

import (
	"fmt"
	"sync"
	"github.com/yaoapp/gou/application"
)

var Tuos = sync.Map{} // 缓存所有加载的 TUI

// Load 加载所有 .tui.yao 文件
func Load() error {
	exts := []string{"*.tui.yao", "*.tui.json", "*.tui.jsonc"}
	err := application.App.Walk("tuis", func(root, file string, isDir bool) error {
		if isDir {
			return nil
		}

		id := application.App.ID(root, file)
		data, err := application.App.Read(file)
		if err != nil {
			return err
		}

		var cfg Config
		err = application.Unmarshal(data, &cfg)
		if err != nil {
			return fmt.Errorf("TUI [%s] 解析错误: %s", id, err.Error())
		}

		cfg.ID = id
		Tuos.Store(id, &cfg)
		return nil
	}, exts...)

	return err
}

// Get 根据 ID 获取配置
func Get(id string) (*Config, error) {
	if v, ok := Tuos.Load(id); ok {
		return v.(*Config), nil
	}
	return nil, fmt.Errorf("TUI [%s] 未找到", id)
}

```

#### 1.3 注册到 Yao 内核 (`engine/load.go`)

在 `engine/load.go` 的 `Load` 函数中加入：

```go
// ... 现有逻辑
if err := tui.Load(); err != nil {
    return err
}
// ...

```

---

### 第一阶段要点说明：

1. **资源映射**：我们将 `tuis/admin/user.tui.yao` 映射为 ID `admin.user`，这与 Yao 其它构件（如 Models, APIs）保持 ID 命名空间的一致性。
2. **State 设计**：`Config.Data` 是界面的“底噪”，后续所有 Process 返回的数据都会合并到这个 `Model.State` 中。
3. **非阻塞扩展**：`Action` 结构体为第二阶段的异步 `tea.Cmd` 调用预留了 `Process` 字段。

**下一步（第二批次）我们将编写：**

1. `tui/driver.go`：Bubble Tea `tea.Model` 接口的完整实现。
2. `tui/action.go`：核心的 Action 执行引擎，负责将 `{{}}` 表达式替换并调用 `gou.Process`。

你是否已经准备好将这部分代码集成到你的开发分支中？如果有任何目录结构调整的建议，请告诉我。
