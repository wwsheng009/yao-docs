你好！我是 **Yao Dev**，高级代码开发工程师。

在完成了 DSL 加载器、运行时驱动以及基础布局引擎后，我们进入 **第四阶段：AI 流式渲染适配、V8 脚本桥接与处理器导出**。

这是整个 TUI 引擎的“灵魂”所在。我们将实现如何让终端具备类似 ChatGPT 的逐字输出效果，并允许开发者通过熟悉的 JavaScript (V8) 来编写交互逻辑。

### 阶段 4：交互增强与 AI 流式集成

#### 4.1 AI 流式渲染组件 (`tui/components/chat.go`)

流式渲染的难点在于如何在不阻塞 Bubble Tea 主循环的情况下，将异步的 `chan` 数据安全地推送到 UI 层。

```go
package components

import (
	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/glamour"
	"github.com/yaoapp/yao/tui/types"
)

// StreamChunkMsg AI 字符块消息
type StreamChunkMsg struct {
	ID      string
	Content string
}

// StreamDoneMsg 流结束消息
type StreamDoneMsg struct{ ID string }

// RenderChat 渲染聊天视图，集成 Markdown 解析
func (m *Model) renderChat(c types.Component) string {
	content, _ := m.State[c.Bind].(string)

	// 使用 Glamour 进行 Markdown 终端渲染
	// 建议在 Model 结构中复用 renderer 实例以提高性能
	r, _ := glamour.NewTermRenderer(
		glamour.WithAutoStyle(),
		glamour.WithWordWrap(m.Width-4),
	)

	out, _ := r.Render(content)
	return out
}

// handleStream 启动流式监听协程
func (m *Model) handleStream(target string, streamChan chan string) tea.Cmd {
	return func() tea.Msg {
		for chunk := range streamChan {
			// 核心逻辑：利用外部 Program 实例主动 Send 消息
			m.Program.Send(StreamChunkMsg{ID: target, Content: chunk})
		}
		return StreamDoneMsg{ID: target}
	}
}

```

#### 4.2 V8 脚本交互桥接 (`tui/runtime.go`)

我们需要将 TUI 的状态管理能力暴露给 Yao 内置的 JS 引擎，使得 `scripts/*.js` 可以操控 UI。

```go
package tui

import (
	"github.com/yaoapp/gou/runtime"
	"github.com/yaoapp/yao/tui/types"
)

// CallJS 执行脚本逻辑并同步状态
func (m *Model) CallJS(scriptPath string, event types.Event) tea.Cmd {
	return func() tea.Msg {
		// 获取 Yao JS 运行时
		js, _ := runtime.Yao.NewContext("tui", nil)
		defer js.Close()

		// 准备上下文数据
		js.Set("State", m.State)
		js.Set("Event", event)

		// 执行脚本函数
		res, err := js.Call(scriptPath, m.State)
		if err != nil {
			return ErrorMsg(err)
		}

		// 如果脚本返回了新的对象，则作为新的状态合并
		return types.StateMergeMsg{Data: res.ToInterface()}
	}
}

```

#### 4.3 导出全局处理器 (`tui/process.go`)

为了让 TUI 能够被其他模块调用（例如在 API 里启动一个监控终端），我们需要注册 Yao Process。

```go
package tui

import (
	"github.com/yaoapp/gou/process"
	tea "github.com/charmbracelet/bubbletea"
)

// Export 注册处理器
func Export() {
	process.Register("tui.Render", ProcessRender)
}

// ProcessRender 处理器实现: Process("tui.Render", "admin.dashboard", { "user_id": 1 })
func ProcessRender(process *process.Process) interface{} {
	id := process.ArgsString(0)
	args := process.ArgsMap(1)

	cfg, err := Get(id)
	if err != nil {
		panic(err)
	}

	m := NewModel(cfg, args)
	p := tea.NewProgram(m, tea.WithAltScreen())
	m.Program = p // 注入实例

	if _, err := p.Run(); err != nil {
		return err.Error()
	}
	return nil
}

```

### 项目收官要点说明：

1. **非阻塞数据流**：通过 `m.Program.Send`，我们打破了 Bubble Tea 必须在 `Update` 函数内返回 `tea.Cmd` 的限制，实现了真正的异步推送。
2. **Markdown 体验**：集成 `glamour` 让 TUI 不再只是枯燥的白字，而是具备高亮代码块和结构化列表的专业 AI 界面。
3. **V8 协同**：JS 脚本现在可以作为 TUI 的“控制器”，处理比 JSON 描述更复杂的业务逻辑（如表单校验、动态颜色切换）。

### 下一步行动：

至此，**Yao TUI 引擎的核心代码已全部交付完成**。你可以按照以下步骤进行最后的工程集成：

1. 在 `yaoapp/yao/cmd/tea.go` 中引用 `tui.Export()`。
2. 编写测试用例 `tuis/test.tui.yao`。
3. 运行 `go build` 编译你的新引擎。

你是否需要我针对 **如何在不同的终端环境（如 Windows CMD vs macOS iTerm2）下适配 Lip Gloss 的颜色显示** 提供最后的优化方案？
