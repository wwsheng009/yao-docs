# TUI 测试策略与工程化实施

## 概述

本文档补充 TUI 引擎的测试方案、CI/CD 集成、性能基准测试以及生产环境部署建议。

---

## 1. 测试策略

### 1.1 单元测试框架

```go
// tui/tui_test.go - 测试套件基础
package tui

import (
    "testing"
    "time"

    tea "github.com/charmbracelet/bubbletea"
    "github.com/stretchr/testify/assert"
    "github.com/yaoapp/yao/config"
    "github.com/yaoapp/yao/test"
)

// SetupTest 测试环境初始化
func SetupTest(t *testing.T) {
    test.Prepare(t, config.Conf)

    // 加载测试数据
    Load()
}

// TeardownTest 测试环境清理
func TeardownTest(t *testing.T) {
    test.Clean()
    Tuos = sync.Map{} // 清空缓存
}
```

### 1.2 Loader 测试

```go
// tui/loader_test.go
package tui

import (
    "testing"

    "github.com/stretchr/testify/assert"
)

func TestLoad(t *testing.T) {
    SetupTest(t)
    defer TeardownTest(t)

    // 测试加载所有 TUI
    err := Load()
    assert.NoError(t, err)

    // 验证已加载的 TUI
    cfg, err := Get("test.hello")
    assert.NoError(t, err)
    assert.NotNil(t, cfg)
    assert.Equal(t, "test.hello", cfg.ID)
}

func TestGet(t *testing.T) {
    SetupTest(t)
    defer TeardownTest(t)

    // 测试获取不存在的 TUI
    _, err := Get("nonexistent")
    assert.Error(t, err)

    // 测试获取存在的 TUI
    cfg, err := Get("test.hello")
    assert.NoError(t, err)
    assert.NotNil(t, cfg)
}

func TestLoadScript(t *testing.T) {
    SetupTest(t)
    defer TeardownTest(t)

    // 测试加载 TypeScript 脚本
    script, err := LoadScript("scripts/tui/test")
    assert.NoError(t, err)
    assert.NotNil(t, script)

    // 测试脚本缓存
    script2, err := LoadScript("scripts/tui/test")
    assert.NoError(t, err)
    assert.Equal(t, script, script2) // 应该返回相同实例
}
```

### 1.3 Model 生命周期测试

```go
// tui/model_test.go
package tui

import (
    "testing"
    "time"

    tea "github.com/charmbracelet/bubbletea"
    "github.com/stretchr/testify/assert"
)

func TestModelInit(t *testing.T) {
    SetupTest(t)
    defer TeardownTest(t)

    cfg := &Config{
        ID: "test",
        Data: map[string]interface{}{
            "title": "Test TUI",
        },
    }

    model := NewModel(cfg, map[string]interface{}{
        "user": "admin",
    })

    assert.NotNil(t, model)
    assert.Equal(t, "Test TUI", model.State["title"])
    assert.Equal(t, "admin", model.State["user"])
}

func TestModelUpdate(t *testing.T) {
    SetupTest(t)
    defer TeardownTest(t)

    cfg := &Config{ID: "test", Data: map[string]interface{}{}}
    model := NewModel(cfg, nil)

    // 测试窗口大小消息
    newModel, _ := model.Update(tea.WindowSizeMsg{Width: 100, Height: 50})
    m := newModel.(*Model)
    assert.Equal(t, 100, m.Width)
    assert.Equal(t, 50, m.Height)
    assert.True(t, m.Ready)

    // 测试状态更新消息
    newModel, _ = m.Update(StateUpdateMsg{Key: "test", Value: "value"})
    m = newModel.(*Model)
    // 状态已通过并发安全的方式更新
}

func TestModelStateThreadSafety(t *testing.T) {
    SetupTest(t)
    defer TeardownTest(t)

    cfg := &Config{ID: "test", Data: map[string]interface{}{}}
    model := NewModel(cfg, nil)

    // 并发读写测试
    done := make(chan bool)

    // 写 goroutine
    go func() {
        for i := 0; i < 100; i++ {
            model.StateMu.Lock()
            model.State["counter"] = i
            model.StateMu.Unlock()
            time.Sleep(1 * time.Millisecond)
        }
        done <- true
    }()

    // 读 goroutine
    go func() {
        for i := 0; i < 100; i++ {
            model.StateMu.RLock()
            _ = model.State["counter"]
            model.StateMu.RUnlock()
            time.Sleep(1 * time.Millisecond)
        }
        done <- true
    }()

    <-done
    <-done

    // 如果没有死锁，测试通过
}
```

### 1.4 Action 执行测试

```go
// tui/action_test.go
package tui

import (
    "testing"

    "github.com/stretchr/testify/assert"
)

func TestExecuteProcessAction(t *testing.T) {
    SetupTest(t)
    defer TeardownTest(t)

    cfg := &Config{
        ID: "test",
        Data: map[string]interface{}{
            "name": "John",
        },
    }
    model := NewModel(cfg, nil)

    // 测试 Process Action
    action := Action{
        Process:   "models.user.Find",
        Args:      []interface{}{1},
        OnSuccess: "user",
    }

    cmd := model.ExecuteAction(action)
    assert.NotNil(t, cmd)

    // 执行 cmd 并获取结果
    msg := cmd()

    // 验证结果类型
    switch msg.(type) {
    case ProcessResultMsg:
        result := msg.(ProcessResultMsg)
        assert.Equal(t, "user", result.Target)
    case ErrorMsg:
        // 如果 Process 不存在会返回错误
        t.Log("Process not found (expected in test env)")
    }
}

func TestExecuteScriptAction(t *testing.T) {
    SetupTest(t)
    defer TeardownTest(t)

    cfg := &Config{ID: "test", Data: map[string]interface{}{}}
    model := NewModel(cfg, nil)

    // 测试 Script Action
    action := Action{
        Script:    "scripts/tui/test",
        Method:    "handleTest",
        Args:      []interface{}{"test_value"},
        OnSuccess: "result",
    }

    cmd := model.ExecuteScriptAction(action)
    assert.NotNil(t, cmd)

    // 执行并验证
    msg := cmd()

    switch msg.(type) {
    case ProcessResultMsg:
        result := msg.(ProcessResultMsg)
        assert.Equal(t, "result", result.Target)
    case ErrorMsg:
        // 脚本可能不存在
        t.Log("Script error (may be expected)")
    }
}
```

### 1.5 渲染测试

```go
// tui/render_test.go
package tui

import (
    "strings"
    "testing"

    "github.com/stretchr/testify/assert"
)

func TestRenderLayout(t *testing.T) {
    SetupTest(t)
    defer TeardownTest(t)

    cfg := &Config{
        ID: "test",
        Data: map[string]interface{}{
            "title": "Test Title",
        },
        Layout: Layout{
            Direction: "vertical",
            Children: []Component{
                {
                    Type: "header",
                    Props: map[string]interface{}{
                        "title": "{{title}}",
                    },
                },
            },
        },
    }

    model := NewModel(cfg, nil)
    model.Width = 80
    model.Height = 24
    model.Ready = true

    // 渲染视图
    view := model.View()

    assert.NotEmpty(t, view)
    assert.Contains(t, view, "Test Title")
}

func TestRenderComponent(t *testing.T) {
    SetupTest(t)
    defer TeardownTest(t)

    cfg := &Config{ID: "test", Data: map[string]interface{}{}}
    model := NewModel(cfg, nil)
    model.Width = 80

    // 测试 Header 组件
    comp := Component{
        Type: "header",
        Props: map[string]interface{}{
            "title": "Test Header",
        },
    }

    result := model.RenderComponent(comp)
    assert.NotEmpty(t, result)
    assert.Contains(t, result, "Test Header")

    // 测试未知组件
    comp = Component{
        Type: "unknown",
    }

    result = model.RenderComponent(comp)
    assert.Contains(t, result, "未知组件")
}
```

---

## 2. 集成测试

### 2.1 完整流程测试

```go
// tui/integration_test.go
package tui

import (
    "context"
    "testing"
    "time"

    tea "github.com/charmbracelet/bubbletea"
    "github.com/stretchr/testify/assert"
)

func TestFullLifecycle(t *testing.T) {
    SetupTest(t)
    defer TeardownTest(t)

    // 创建配置
    cfg := &Config{
        ID: "test.integration",
        Data: map[string]interface{}{
            "count": 0,
        },
        OnLoad: &Action{
            Process: "scripts.test.Init",
        },
        Layout: Layout{
            Direction: "vertical",
            Children: []Component{
                {
                    Type: "header",
                    Props: map[string]interface{}{
                        "title": "Integration Test",
                    },
                },
            },
        },
    }

    model := NewModel(cfg, nil)

    // 测试初始化
    cmd := model.Init()
    if cmd != nil {
        // OnLoad Action 应该被执行
        msg := cmd()
        assert.NotNil(t, msg)
    }

    // 测试消息循环
    model.Width = 80
    model.Height = 24
    model.Ready = true

    // 模拟窗口事件
    newModel, _ := model.Update(tea.WindowSizeMsg{Width: 100, Height: 50})
    m := newModel.(*Model)
    assert.Equal(t, 100, m.Width)

    // 测试渲染
    view := m.View()
    assert.NotEmpty(t, view)

    t.Log("Full lifecycle test passed")
}

func TestScriptIntegration(t *testing.T) {
    SetupTest(t)
    defer TeardownTest(t)

    // 加载脚本
    script, err := LoadScript("scripts/tui/test")
    if err != nil {
        t.Skip("Test script not available")
        return
    }

    cfg := &Config{ID: "test", Data: map[string]interface{}{}}
    model := NewModel(cfg, nil)

    // 执行脚本方法
    result, err := script.ExecuteWithModel(
        context.Background(),
        "testFunction",
        model,
        "arg1", "arg2",
    )

    assert.NoError(t, err)
    assert.NotNil(t, result)
}
```

---

## 3. 性能基准测试

### 3.1 Benchmark 套件

```go
// tui/benchmark_test.go
package tui

import (
    "testing"
)

func BenchmarkModelUpdate(b *testing.B) {
    cfg := &Config{ID: "bench", Data: map[string]interface{}{}}
    model := NewModel(cfg, nil)

    msg := StateUpdateMsg{Key: "test", Value: "value"}

    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        model.Update(msg)
    }
}

func BenchmarkRenderLayout(b *testing.B) {
    cfg := &Config{
        ID: "bench",
        Layout: Layout{
            Direction: "vertical",
            Children: []Component{
                {Type: "header", Props: map[string]interface{}{"title": "Test"}},
                {Type: "header", Props: map[string]interface{}{"title": "Test2"}},
                {Type: "header", Props: map[string]interface{}{"title": "Test3"}},
            },
        },
    }

    model := NewModel(cfg, nil)
    model.Width = 80
    model.Height = 24
    model.Ready = true

    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        model.View()
    }
}

func BenchmarkStateAccess(b *testing.B) {
    cfg := &Config{ID: "bench", Data: map[string]interface{}{
        "key1": "value1",
        "key2": "value2",
        "key3": "value3",
    }}
    model := NewModel(cfg, nil)

    b.Run("Read", func(b *testing.B) {
        for i := 0; i < b.N; i++ {
            model.StateMu.RLock()
            _ = model.State["key1"]
            model.StateMu.RUnlock()
        }
    })

    b.Run("Write", func(b *testing.B) {
        for i := 0; i < b.N; i++ {
            model.StateMu.Lock()
            model.State["key1"] = "new_value"
            model.StateMu.Unlock()
        }
    })
}

func BenchmarkScriptExecution(b *testing.B) {
    script, err := LoadScript("scripts/tui/bench")
    if err != nil {
        b.Skip("Benchmark script not available")
        return
    }

    cfg := &Config{ID: "bench", Data: map[string]interface{}{}}
    model := NewModel(cfg, nil)

    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        script.ExecuteWithModel(context.Background(), "benchFunction", model)
    }
}
```

### 3.2 性能目标

```go
// 性能基准目标（在文档中记录）
/*
性能目标：
- ModelUpdate: < 100ns/op
- RenderLayout (3组件): < 10µs/op
- StateRead: < 50ns/op
- StateWrite: < 100ns/op
- ScriptExecution: < 1ms/op

内存目标：
- 单个 Model: < 100KB
- 状态存储: < 50KB
- 脚本缓存: < 10MB (100个脚本)

并发目标：
- 支持 10+ 并发 TUI 实例
- 无死锁
- 无数据竞争
*/
```

---

## 4. Mock 测试工具

### 4.1 Mock Bubble Tea Program

```go
// tui/mock/program.go
package mock

import (
    tea "github.com/charmbracelet/bubbletea"
)

// MockProgram 模拟 Bubble Tea Program
type MockProgram struct {
    Messages []tea.Msg
}

func NewMockProgram() *MockProgram {
    return &MockProgram{
        Messages: []tea.Msg{},
    }
}

func (p *MockProgram) Send(msg tea.Msg) {
    p.Messages = append(p.Messages, msg)
}

func (p *MockProgram) Run() (tea.Model, error) {
    return nil, nil
}

func (p *MockProgram) Quit() {
    // No-op
}

func (p *MockProgram) GetMessages() []tea.Msg {
    return p.Messages
}
```

### 4.2 Mock Process

```go
// tui/mock/process.go
package mock

import (
    "github.com/yaoapp/gou/process"
)

// MockProcess 模拟 Process 执行
type MockProcess struct {
    Name   string
    Args   []interface{}
    Result interface{}
    Err    error
}

func (p *MockProcess) Exec() (interface{}, error) {
    return p.Result, p.Err
}

// RegisterMockProcess 注册 Mock Process
func RegisterMockProcess(name string, result interface{}, err error) {
    process.Register(name, func(p *process.Process) interface{} {
        if err != nil {
            panic(err)
        }
        return result
    })
}
```

---

## 5. CI/CD 集成

### 5.1 GitHub Actions 配置

```yaml
# .github/workflows/tui-test.yml
name: TUI Tests

on:
  push:
    paths:
      - 'tui/**'
      - 'tuis/**'
  pull_request:
    paths:
      - 'tui/**'
      - 'tuis/**'

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.21'

      - name: Cache Go modules
        uses: actions/cache@v3
        with:
          path: ~/go/pkg/mod
          key: ${{ runner.os }}-go-${{ hashFiles('**/go.sum') }}

      - name: Install dependencies
        run: go mod download

      - name: Run unit tests
        run: |
          go test ./tui/... -v -race -coverprofile=coverage.out

      - name: Run benchmarks
        run: |
          go test ./tui/... -bench=. -benchmem

      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage.out

  lint:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3

      - name: golangci-lint
        uses: golangci/golangci-lint-action@v3
        with:
          version: latest
          args: --timeout=5m ./tui/...
```

### 5.2 Makefile 集成

```makefile
# 在主 Makefile 中添加 TUI 相关目标

.PHONY: test-tui
test-tui:
	@echo "Running TUI unit tests..."
	@go test ./tui/... -v -race -coverprofile=coverage-tui.out
	@go tool cover -html=coverage-tui.out -o coverage-tui.html

.PHONY: bench-tui
bench-tui:
	@echo "Running TUI benchmarks..."
	@go test ./tui/... -bench=. -benchmem -cpuprofile=cpu.prof -memprofile=mem.prof
	@go tool pprof -http=:8080 cpu.prof &
	@go tool pprof -http=:8081 mem.prof &

.PHONY: test-tui-integration
test-tui-integration:
	@echo "Running TUI integration tests..."
	@go test ./tui/... -tags=integration -v

.PHONY: lint-tui
lint-tui:
	@echo "Linting TUI code..."
	@golangci-lint run ./tui/...

.PHONY: cover-tui
cover-tui: test-tui
	@echo "Generating TUI coverage report..."
	@go tool cover -func=coverage-tui.out | grep total
```

---

## 6. 文档与示例

### 6.1 测试文档结构

```
tui/
├── README.md              # TUI 模块总览
├── TESTING.md             # 测试指南
├── PERFORMANCE.md         # 性能基准
├── examples/              # 示例代码
│   ├── basic/             # 基础示例
│   │   └── main.go
│   ├── with-script/       # 脚本集成示例
│   │   └── main.go
│   └── ai-chat/           # AI 聊天示例
│       └── main.go
└── docs/                  # 详细文档
    ├── api.md             # API 参考
    ├── components.md      # 组件开发指南
    └── troubleshooting.md # 故障排查
```

### 6.2 测试覆盖率目标

```go
/*
测试覆盖率目标：

核心模块：
- tui/types.go: 100%
- tui/loader.go: 95%
- tui/model.go: 90%
- tui/action.go: 90%
- tui/render.go: 85%

集成模块：
- tui/jsapi.go: 85%
- tui/script.go: 85%
- tui/process.go: 90%

组件模块：
- tui/components/*: 80%

总体目标：85%+
*/
```

---

## 7. 生产环境部署

### 7.1 配置优化

```go
// config/tui.go - 生产环境配置
type TUIConfig struct {
    // 性能配置
    MaxInstances      int    `json:"maxInstances" envDefault:"10"`      // 最大并发实例
    ScriptCacheSize   int    `json:"scriptCacheSize" envDefault:"100"`  // 脚本缓存大小
    StateMaxSize      int    `json:"stateMaxSize" envDefault:"10240"`   // 状态最大字节数

    // 安全配置
    EnableScripts     bool   `json:"enableScripts" envDefault:"true"`   // 是否启用脚本
    ScriptTimeout     int    `json:"scriptTimeout" envDefault:"5000"`   // 脚本超时（ms）
    MaxScriptMemory   uint64 `json:"maxScriptMemory" envDefault:"52428800"` // 脚本最大内存（50MB）

    // 监控配置
    EnableMetrics     bool   `json:"enableMetrics" envDefault:"true"`   // 启用指标收集
    MetricsInterval   int    `json:"metricsInterval" envDefault:"60"`   // 指标收集间隔（秒）
}
```

### 7.2 监控指标

```go
// tui/metrics.go
package tui

import (
    "sync/atomic"
    "time"
)

// Metrics TUI 性能指标
type Metrics struct {
    // 计数器
    TotalInstances    int64 // 总创建实例数
    ActiveInstances   int64 // 活跃实例数
    TotalRenders      int64 // 总渲染次数
    TotalActions      int64 // 总 Action 执行次数
    TotalErrors       int64 // 总错误数

    // 时间统计
    AvgRenderTime     time.Duration // 平均渲染时间
    AvgActionTime     time.Duration // 平均 Action 时间

    // 资源统计
    TotalMemory       uint64 // 总内存使用
    ScriptCacheHits   int64  // 脚本缓存命中
    ScriptCacheMisses int64  // 脚本缓存未命中
}

var globalMetrics = &Metrics{}

// RecordRender 记录渲染
func RecordRender(duration time.Duration) {
    atomic.AddInt64(&globalMetrics.TotalRenders, 1)
    // 更新平均时间
}

// RecordAction 记录 Action 执行
func RecordAction(duration time.Duration) {
    atomic.AddInt64(&globalMetrics.TotalActions, 1)
}

// RecordError 记录错误
func RecordError() {
    atomic.AddInt64(&globalMetrics.TotalErrors, 1)
}

// GetMetrics 获取指标快照
func GetMetrics() Metrics {
    return Metrics{
        TotalInstances:  atomic.LoadInt64(&globalMetrics.TotalInstances),
        ActiveInstances: atomic.LoadInt64(&globalMetrics.ActiveInstances),
        TotalRenders:    atomic.LoadInt64(&globalMetrics.TotalRenders),
        TotalActions:    atomic.LoadInt64(&globalMetrics.TotalActions),
        TotalErrors:     atomic.LoadInt64(&globalMetrics.TotalErrors),
    }
}
```

### 7.3 健康检查

```go
// tui/health.go
package tui

import (
    "fmt"
    "time"
)

// HealthStatus 健康状态
type HealthStatus struct {
    Healthy       bool              `json:"healthy"`
    Timestamp     time.Time         `json:"timestamp"`
    Metrics       Metrics           `json:"metrics"`
    Errors        []string          `json:"errors,omitempty"`
    Warnings      []string          `json:"warnings,omitempty"`
}

// HealthCheck 执行健康检查
func HealthCheck() HealthStatus {
    status := HealthStatus{
        Healthy:   true,
        Timestamp: time.Now(),
        Metrics:   GetMetrics(),
        Errors:    []string{},
        Warnings:  []string{},
    }

    // 检查活跃实例数
    if status.Metrics.ActiveInstances > 10 {
        status.Warnings = append(status.Warnings,
            fmt.Sprintf("High active instances: %d", status.Metrics.ActiveInstances))
    }

    // 检查错误率
    if status.Metrics.TotalErrors > 100 {
        status.Healthy = false
        status.Errors = append(status.Errors,
            fmt.Sprintf("Too many errors: %d", status.Metrics.TotalErrors))
    }

    return status
}
```

---

## 8. 故障排查工具

### 8.1 调试模式

```go
// tui/debug.go
package tui

import (
    "fmt"
    "log"
    "os"
)

var debugMode = os.Getenv("YAO_TUI_DEBUG") == "true"

// Debug 调试日志
func Debug(format string, args ...interface{}) {
    if debugMode {
        log.Printf("[TUI DEBUG] "+format, args...)
    }
}

// DumpState 导出状态（调试用）
func (m *Model) DumpState() string {
    m.StateMu.RLock()
    defer m.StateMu.RUnlock()

    return fmt.Sprintf("State: %+v", m.State)
}
```

### 8.2 性能分析工具

```go
// tui/profiling.go
package tui

import (
    "runtime/pprof"
    "os"
    "time"
)

// StartProfiling 启动性能分析
func StartProfiling(filename string) (*os.File, error) {
    f, err := os.Create(filename)
    if err != nil {
        return nil, err
    }

    pprof.StartCPUProfile(f)
    return f, nil
}

// StopProfiling 停止性能分析
func StopProfiling(f *os.File) {
    pprof.StopCPUProfile()
    f.Close()
}

// MeasureTime 测量执行时间
func MeasureTime(name string) func() {
    start := time.Now()
    return func() {
        Debug("%s took %v", name, time.Since(start))
    }
}
```

---

## 总结

通过以上测试和工程化方案，TUI 引擎具备了：

1. **完整的测试覆盖** - 单元测试、集成测试、性能测试
2. **CI/CD 集成** - 自动化测试和部署流程
3. **性能监控** - 实时指标收集和健康检查
4. **生产就绪** - 配置优化、错误处理、故障排查

这确保了 TUI 引擎的质量、稳定性和可维护性，为生产环境部署提供了坚实保障。
