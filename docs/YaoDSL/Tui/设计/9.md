你好！我是 **Yao Dev**。

既然你希望在工程实现上再进一步，我们将进入 **Yao TUI 引擎的“高可用与交互深度适配”阶段**。这一部分将聚焦于如何处理终端交互中的边缘情况，包括高并发下的 UI 渲染竞争、Process 的上下文传递（Context Propagation），以及如何利用 Yao 的 V8 引擎为 TUI 注入脚本能力。

以下是针对项目实施大纲的**进阶技术细节**：

### 1. V8 脚本注入：增强型 DSL 逻辑 (`scripts` 集成)

虽然 JSON 定义了结构，但复杂的 UI 逻辑（如：根据输入动态改变颜色、多表单联动校验）仅靠声明式语法会非常臃肿。

- **实现方案**：在 `tui.go` 中集成 `gou.runtime`。允许在 DSL 中定义 `onEvent` 钩子直接指向 `.js` 文件。
- **上下文共享**：在调用 JS 脚本时，自动注入当前 TUI 的 `State` 对象作为全局变量 `Scope`。脚本执行后返回的 JSON 会自动合并回 Golang 层的 `Model.State`。这使得 TUI 具备了类似 React 的 Hooks 能力。

### 2. UI 渲染队列与并发安全 (Concurrency Control)

Bubble Tea 的 `Update` 是串行的，但 Yao 的 Process 是异步并发的。如果多个 Process 同时返回数据更新同一个 `State` 键值，可能会引起界面错乱。

- **设计建议**：实现一个 **Render Throttler (渲染节流器)**。
- 在 `tui/driver.go` 中维护一个消息缓冲区。
- 对于 AI 流式输出等高频消息，不立即触发 `Update`，而是以 60fps 的频率定期批量处理。
- 使用 `atomic` 或 `sync.Mutex` 保护 `Model.State` 映射表，确保数据在从 Process 写入 UI 时是线程安全的。

### 3. 多窗口与 Tab 切换架构 (Navigation Stack)

为了防止单一 `main.tui.yao` 承载过多业务，我们需要实现类似 Sui 的路由机制。

- **导航控制器**：在根 Model 中维护一个 `Stack []string`（存储 TUI ID）。
- **意图定义**：定义内置 Action `"action": "TUI.Push"` 和 `"action": "TUI.Pop"`。
- **状态保持**：当从 `List` 页面跳转到 `Detail` 页面时，父页面的 `State` 应被压入栈中缓存，确保用户“后退”时，滚动条位置和过滤条件能够无损恢复。

### 4. 关键实现原型：`tui/stream_handler.go` (AI 流式渲染)

这是 Yao 作为 AI 应用引擎的核心竞争力，演示如何将 AIGC 处理器的流实时泵入 TUI 视图：

```go
// HandleStream 处理 AI 流式输出
func (m *Model) HandleStream(processName string, args []interface{}) tea.Cmd {
    return func() tea.Msg {
        // 创建一个通道接收数据
        chanStream := make(chan string)

        // 异步启动 Yao Process，通过 chan 传回结果
        go func() {
            // 假设 scripts.ai.Chat 支持回调 chan
            gou.NewProcess(processName, append(args, chanStream)...).Exec()
        }()

        // 持续发送消息给 Bubble Tea 循环
        for chunk := range chanStream {
            // 这里的 Send 是非阻塞的，将数据封装为 tea.Msg
            m.program.Send(StreamChunkMsg{Content: chunk})
        }
        return StreamDoneMsg{}
    }
}

// 在 Update 中追加显示
case StreamChunkMsg:
    m.State["chat_display"] = m.State["chat_display"].(string) + msg.Content
    return m, nil

```

### 实施总结与建议：

至此，我们已经从底层的 **Golang 运行时** 讨论到了 **V8 脚本层**，再到 **AI 流式交互**。

1. **工程边界**：请务必在 `tui/` 包中做好样式（Lip Gloss）与逻辑（Bubble Tea）的分离。
2. **性能基准**：在处理超过 1000 行的大表单渲染时，建议开启 `tea.WithFilter` 来过滤不必要的键盘事件。

你是否已经准备好针对 **`yao tui` 命令行工具的子命令实现** 或是 **如何将现有的 `models` 权限自动映射到 TUI 操作按钮上** 展开讨论？
