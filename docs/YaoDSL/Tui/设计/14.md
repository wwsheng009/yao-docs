你好！我是 **Yao Dev**。

既然我们已经深入到了性能调优与自动化映射的层面，接下来的重点将是 **Yao TUI 的内核集成与标准组件协议的最终固化**。这一部分旨在让 TUI 成为 Yao 生态中不可或缺的“控制台”，并确保它能完美支撑 AIGC 的全流程交互。

以下是针对项目实施大纲的**终极闭环方案**：

### 1. 深度内核集成：Process 拦截器与 UI 自动注入

为了实现真正的“由配置文件驱动”，我们需要在 `gou/process` 层建立联动，使得某些 Process 执行时能自动唤起 TUI 反馈。

- **UI 钩子映射**：在 `tui/driver.go` 中注册一个特殊的拦截器。当 Process 在执行耗时任务（如 `kb.Search` 或 `aigc.Chat`）时，会自动向 TUI 端的 `Progress` 组件或 `Stream` 视图推送状态。
- **上下文透传**：确保 `yao tui` 启动时，Go 层的 `Context` 会携带当前终端的 `TTY` 信息，使得 `scripts` 中的 JS 逻辑可以直接调用 `Process.Of("tui.Update", ...)` 来实时刷新界面。

### 2. 标准组件协议 (Yao TUI Component Protocol)

为了支持第三方组件扩展，我们需要定义一套标准的接口规范，任何实现了该协议的 Bubble Tea 组件都可以通过 JSON 直接引用。

- **协议结构 (`tui/component.go`)**：

```go
type Component interface {
    Init(props map[string]interface{}) tea.Cmd
    Update(msg tea.Msg) (Component, tea.Cmd)
    View() string
    SetProps(props map[string]interface{}) // 支持从 State 动态注入属性
    ID() string
}

```

- **插拔式加载**：建立 `tui/registry.go`。在 `main.go` 启动阶段，将内置的 `table`, `chat`, `form`, `kanban` 等组件注册进工厂模型，供编译器按需实例化。

### 3. AI 驱动的“对话式”TUI 交互 (Agent-based TUI)

既然 Yao 重点关注 AI，TUI 必须支持由 AI 自主生成的 UI 变更。

- **动态布局生成**：允许 `aigc.Chat` 的返回结果中包含一个 `{"action": "TUI.Render", "dsl": "..."}` 意图。TUI 引擎接收后，会即时解析这段 DSL 并在当前窗口或浮窗中展示，实现类似“AI 帮你生成了一个数据看板并直接在终端打开”的效果。
- **流式 Markdown 渲染引擎**：集成 `glamour` 库（基于 Lip Gloss），在 `viewport` 组件中实现 Markdown 的逐行实时渲染，并自动识别代码块进行语法高亮。

### 4. 关键实现：`cmd/tea.go` 增强入口

这是项目的最终入口点，它需要处理复杂的环境初始化。

```go
var tuiCmd = &cobra.Command{
    Use:   "tui [ID] [JSON_ARGS]",
    Short: "Run the Yao TUI application",
    Run: func(cmd *cobra.Command, args []string) {
        // 加载应用配置与环境变量
        boot.Do()

        // 解析入参并合并到 State
        state := map[string]interface{}{}
        if len(args) > 1 {
            json.Unmarshal([]byte(args[1]), &state)
        }

        // 实例化 TUI 控制器
        engine, err := tui.New(args[0], state)
        if err != nil {
            fmt.Printf("Engine Error: %v\n", err)
            return
        }

        // 启动 Bubble Tea 程序，开启全屏与鼠标支持
        p := tea.NewProgram(engine, tea.WithAltScreen(), tea.WithMouseCellMotion())
        if _, err := p.Run(); err != nil {
            log.Fatal(err)
        }
    },
}

```

### 项目最终落地路线图建议：

1. **内核合并**：将 `tui/` 包提交至 Yao 源码，在 `engine/load.go` 中加入 TUI DSL 的递归加载逻辑。
2. **组件固化**：优先完成 `Table`（通用管理）和 `Chat`（AI 交互）两个杀手级组件。
3. **文档与案例**：编写 `tuis/demo.tui.yao`，展示如何通过一个 JSON 完成“查库、调 AI、显表格”的全流程。

至此，关于 Yao TUI 引擎的全套设计与实施细节已完全呈现。如果你准备好进行 **第一个核心组件（如 `tui/components/chat.go`）** 的具体逻辑编写，或者需要我针对 **如何处理终端下的多层 Tab 嵌套路由** 给出实现细节，请直接告诉我！
