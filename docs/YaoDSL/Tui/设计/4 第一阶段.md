你好！我是 **Yao Dev**，高级代码开发工程师。

在明确了项目实施大纲后，我们需要进入**核心架构的深度设计**阶段。TUI 引擎的成败在于如何优雅地处理“**Bubble Tea 的事件驱动模型**”与“**Yao 的 Process 同步/异步调用**”之间的矛盾。

以下是针对第一阶段核心运行时的详细技术实现方案：

### 1. 核心运行时：响应式状态机 (Reactive State Machine)

我们将 TUI 的 Model 设计为一个持有 Yao 全局状态的容器。参考 `pipe/context.go` 的设计，我们需要在 `Update` 循环中引入一个特殊的 `tea.Cmd` 来执行 Process。

- **状态结构 (`tui/types.go`)**：

```go
type Model struct {
    ID      string
    Config  TUIConfig              // 解析后的 JSON 配置
    State   map[string]interface{} // 响应式数据存储
    Err     error
    width   int
    height  int
}

```

- **Process 执行命令**：我们需要封装一个 `RunProcess` 函数，将 Yao 的 `Process.Of` 调用转化为 `tea.Msg`。这样可以保证 UI 不会在执行耗时任务（如 AI 检索）时卡死。

### 2. DSL 渲染：动态组件树 (Dynamic Component Tree)

参考 `widgets/component/compute.go` 的逻辑，TUI 引擎不应硬编码界面，而是根据 JSON 配置动态递归构建组件树。

- **递归渲染策略**：
  在 `View()` 方法中，遍历 `layout.children`。如果组件类型是 `vertical`，则调用 `lipgloss.JoinVertical`；如果是基础组件（如 `table`），则委派给该组件对应的 `Render` 方法。
- **数据注入**：使用 `pipe/expression.go` 提供的表达式解析能力，在渲染前将 `{{users}}` 等占位符替换为 `Model.State` 中的实际值。

### 3. 事件意图转换 (Intent Actions)

这是 TUI 交互的核心。我们需要定义一套从键盘事件（KeyMsg）到 Yao Action 的映射机制。

- **配置示例**：

```jsonc
{
  "bind": "enter",
  "action": {
    "process": "scripts.user.Login", // 触发 Yao 处理器
    "args": ["{{form.username}}", "{{form.password}}"],
    "onSuccess": "SET_STATE", // 成功后自动更新状态
    "onFail": "SHOW_ERROR" // 失败后显示通知
  }
}
```

### 4. 实施阶段：第一版原型 (PoC) 开发重点

为了快速落地，我建议你在第一周重点完成以下代码结构：

1. **`cmd/tui.go`**: 实现命令行入口，调用 `tea.NewProgram`。
2. **`tui/loader.go`**: 实现基本的 DSL 加载逻辑，支持从 `tuis/` 目录读取并缓存。
3. **内置 `Table` 组件**: 优先实现表格组件，因为它最能体现 Yao “数据管理”的核心价值。通过调用 `models.<name>.Get` 并将结果绑定到 TUI 表格。

**下一步行动建议：**
你是否希望我为你展示一段 **Golang 代码片段**，演示如何在 `tea.Model` 的 `Update` 方法中，通过一个中间件安全地并发调用 `gou/process` 并更新 UI 状态？这部分涉及到 Yao 的全局上下文传递，是整个引擎最关键的性能瓶颈点。
