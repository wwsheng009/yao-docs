你好！我是 **Yao Dev**。

既然你希望继续深入，我们将进入 **Yao TUI 引擎的“神经网络”设计——即：异步消息总线（Async Message Bus）与响应式组件绑定机制**。在 TUI 中，最忌讳的是 Process 调用阻塞 UI 渲染，因此我们需要实现一个基于 `tea.Cmd` 的非阻塞处理器。

以下是针对第一阶段核心代码实现的深度设计：

### 1. 响应式 Model 与 Yao 全局上下文集成

在 `tui/model.go` 中，我们需要将 Bubble Tea 的 Model 转化为 Yao 的“观察者”。通过 `pipe.Context` 来管理状态，确保 `{{}}` 表达式能实时解析。

```go
// Model 核心结构
type Model struct {
    ID      string                 // TUI ID
    Config  types.TUIConfig        // 解析后的 DSL 配置
    State   map[string]interface{} // 页面响应式数据
    Width   int
    Height  int
    IsLoading bool                 // 全局加载状态
}

// Update 处理 Yao Process 的异步返回
func (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
    switch msg := msg.(type) {
    case ProcessResultMsg: // 自定义消息：Process 执行完毕
        m.IsLoading = false
        // 使用 yaoapp/yao/pipe/expression 解析器更新 State
        m.State[msg.Target] = msg.Data
        return m, nil

    case tea.KeyMsg:
        // 根据 DSL 中的 actions 查找绑定关系
        if action, ok := m.Config.Bindings[msg.String()]; ok {
            m.IsLoading = true
            return m, m.RunAction(action) // 触发异步 Process
        }
    }
    return m, nil
}

```

### 2. 异步 Action 执行器 (RunProcess Bridge)

我们需要封装一个桥接函数，将 Yao 的 `gou.Process` 执行过程包装成 Bubble Tea 能够识别的 `tea.Cmd`。这部分代码是实现“配置驱动交互”的关键。

```go
// RunAction 将 DSL 中的 action 转换为 tea.Cmd
func (m Model) RunAction(act types.Action) tea.Cmd {
    return func() tea.Msg {
        // 执行 Yao Process: Process.Of("models.user.Get", args...)
        process := gou.NewProcess(act.Process, act.Args...)
        res, err := process.Exec()
        if err != nil {
            return ErrorMsg(err)
        }
        return ProcessResultMsg{
            Target: act.OnSuccess.Target, // 指定数据写回 State 的哪个 key
            Data:   res,
        }
    }
}

```

### 3. 组件递归渲染逻辑 (The DSL View)

参考 `widgets/component/compute.go`，我们的 `View()` 方法需要根据布局树动态生成 Lip Gloss 样式。

- **布局计算**：使用 `lipgloss.JoinVertical` 和 `lipgloss.JoinHorizontal`。
- **插值渲染**：在渲染每个组件的 `Props` 之前，调用 `pipe.ReplaceExpression(prop, m.State)`。这样，当 `m.State.users` 更新时，List 组件显示的列表会自动变化。

### 4. 下一步实施建议：工程化文件加载

在 `tui/loader.go` 中，你需要实现以下逻辑：

1. **自动注册**：在应用启动时，扫描 `tuis/` 目录。
2. **ID 转换**：文件 `tuis/admin/user.tui.yao` 自动映射为 ID `admin.user`。
3. **缓存机制**：使用 `sync.Map` 存储解析后的 `TUIConfig` 结构体，避免重复解析 JSON。

**现在，你是否需要我为你提供一份完整的 `.tui.yao` JSON 规范定义？** 它可以定义如何配置表单、列表以及与 AI 聊天窗口的联动逻辑。这对于后续开发标准组件库至关重要。
