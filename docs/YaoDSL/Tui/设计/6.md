你好！我是 **Yao Dev**。

在完成了架构设计与核心运行时的规划后，我们需要进入 **TUI 引擎的“表现层”与“工程化”深度设计**。为了实现你最初设想的“由配置文件驱动的交互”，我们需要定义一套严谨的 DSL 规范，并解决 TUI 环境下的多任务并行问题。

以下是针对项目实施大纲中 **DSL 规范定义** 与 **组件消息通信** 的详细补充：

### 1. 完善的 DSL 规范定义 (`.tui.yao`)

参考 Yao 的 `Table` 和 `Form` 构件，TUI 的配置文件应具备描述 **样式 (Styles)**、**布局 (Layout)** 和 **交互行为 (Actions)** 的能力。

```jsonc
{
  "name": "AI 助手终端",
  "config": { "fullScreen": true, "mouseSupport": true },
  "data": { "chat_history": [], "input_text": "" }, // 初始 State
  "layout": {
    "direction": "vertical",
    "children": [
      {
        "id": "viewer",
        "type": "viewport",
        "props": {
          "content": "{{chat_history}}", // 响应式绑定
          "border": "rounded",
          "borderColor": "#5A4FCF",
          "title": " Chat with Yao AI "
        },
        "height": "flex" // 自动撑开
      },
      {
        "id": "sender",
        "type": "input",
        "props": { "placeholder": "请输入指令...", "value": "{{input_text}}" },
        "height": 3,
        "onEnter": {
          // 行为定义
          "process": "scripts.ai.Chat",
          "args": ["{{input_text}}"],
          "onSuccess": {
            "action": "State.Merge", // 内置意图：合并状态
            "payload": { "chat_history": "{{res}}", "input_text": "" }
          }
        }
      }
    ]
  }
}
```

### 2. 组件级消息总线 (Component Messaging)

在 Bubble Tea 框架中，父子组件的通信通常是单向的。为了在 Yao 中实现配置驱动，我们需要引入一个 **全局 Event Bridge**：

- **指令下发 (Downstream)**：父 Model 接收到 `tea.Msg`（如 Process 执行结果），通过深度遍历组件树，匹配 `id` 并将数据通过 `SetProps` 注入子组件。
- **事件上浮 (Upstream)**：子组件（如 `Button`）触发点击时，抛出一个带有 Action 描述的自定义 `msg`，由根 Model 捕获并调用 `RunAction` 执行对应的 Yao Process。

### 3. Lip Gloss 样式引擎的 DSL 化

TUI 的美观取决于 Lip Gloss 样式的应用。我们不希望在 Golang 代码里硬编码颜色，而是通过 DSL 映射：

- **设计建议**：在 `tui/types.go` 中定义 `Style` 结构体，支持映射 `Foreground`, `Background`, `Bold`, `Padding` 等属性。渲染时，引擎读取 JSON 里的样式配置，实时生成 `lipgloss.Style` 对象。

### 4. 实施阶段：AI 流式渲染的特殊处理

既然 Yao 重点关注 AI 应用，TUI 必须支持 **Stream 输出**：

- **挑战**：传统的 Process 调用是阻塞式的返回。
- **对策**：实现 `tui.Stream` 处理器。通过 Golang 的 `chan` 接收 AI 生成的片段，每收到一个 chunk，就通过 `tea.Program.Send(chunkMsg)` 发送消息更新终端视图。这能让你的 TUI 界面像 ChatGPT 网页端一样逐字显示结果。

**接下来，是否需要我为你提供一份 `tui/components/` 文件夹下 `table.go` 的基础结构代码？** 这将演示如何将 Yao 模型数据（Model.Get）映射到 TUI 的表格展示中。
