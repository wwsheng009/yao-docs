你好！我是 **Yao Dev**。

既然你希望在项目实施大纲的基础上进入**实质性的代码落地与工程架构构建**，我们将不再停留在设计层面。作为高级开发工程师，我将为你梳理出 Yao TUI 引擎的 **核心代码骨架 (Skeleton)**。这套骨架将解决 DSL 转换、Bubble Tea 生命周期映射以及 Yao Process 异步调用这三大技术痛点。

以下是 Yao 项目中 `tui/` 模块的初始核心代码实现建议：

### 1. 核心模型与消息总线 (`tui/model.go`)

我们需要将 Bubble Tea 的 `tea.Model` 封装成一个能感知 Yao 状态的“响应式容器”。

```go
package tui

import (
	tea "github.com/charmbracelet/bubbletea"
	"github.com/yaoapp/gou/process"
	"github.com/yaoapp/yao/pipe"
)

// Model 定义了 TUI 的运行时模型
type Model struct {
	ID      string
	Config  Config                 // 解析后的 .tui.yao 配置
	State   map[string]interface{} // 页面级数据快照
	Width   int
	Height  int
	Program *tea.Program           // 引用程序实例以便从 Process 回传消息
}

// Update 消息循环：核心在于将 Action 转换为非阻塞的 Process 调用
func (m Model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.KeyMsg:
		// 查找 DSL 中绑定的按键行为
		if act, ok := m.Config.Bindings[msg.String()]; ok {
			return m, m.ExecuteAction(act)
		}
	case ProcessResultMsg:
		// 当 Yao Process 执行完毕，通过消息回传并更新 State
		m.State[msg.Target] = msg.Data
		return m, nil
	}
	return m, nil
}

// ExecuteAction 将 DSL 意图包装为异步的 tea.Cmd
func (m Model) ExecuteAction(act Action) tea.Cmd {
	return func() tea.Msg {
		// 执行 Yao Process: Process.Of(act.Process, act.Args...)
		// 结合 pipe/expression.go 解析参数中的 {{}}
		res, err := process.Of(act.Process, act.Args...).Exec()
		if err != nil {
			return ErrorMsg(err)
		}
		return ProcessResultMsg{Target: act.OnSuccess.Target, Data: res}
	}
}

```

### 2. DSL 编译器与组件映射 (`tui/compile.go`)

参考 `yao/widgets/component/compute.go`，实现从 JSON 到组件树的递归编译。

- **组件工厂**：在 `tui/components/` 下为 `table`, `list`, `form` 分别创建独立的渲染逻辑。
- **属性绑定**：利用 `yaoapp/yao/pipe/expression.go` 的 `Replace` 函数，在渲染循环中实时将 `{{users}}` 替换为 `m.State["users"]`。

### 3. CLI 入口集成 (`cmd/tui.go`)

我们需要让 `yao tui` 像 `yao start` 一样成为一等公民命令。

```go
var tuiCmd = &cobra.Command{
	Use:   "tui [ID]",
	Short: "启动 Yao TUI 界面",
	Args:  cobra.MinimumNArgs(1),
	Run: func(cmd *cobra.Command, args []string) {
		id := args[0]
		// 1. 加载 tuis/<id>.tui.yao
		cfg := tui.Load(id)
		// 2. 注入应用环境（环境变量、Session）
		m := tui.NewModel(id, cfg)
		// 3. 启动全屏程序
		p := tea.NewProgram(m, tea.WithAltScreen())
		if _, err := p.Run(); err != nil {
			fmt.Printf("Error: %v", err)
		}
	},
}

```

### 4. 实施阶段的“军规”：

1. **UI/Logic 分离**：所有业务逻辑必须通过 `Process.Of` 调用，不要在 `tui/` 模块中写任何数据库查询或 AI 接口逻辑。
2. **异步第一**：耗时 Process 必须使用 `tea.Cmd` 模式，严禁在 `Update` 函数中直接阻塞。
3. **样式共享**：统一在 `tui/theme` 中定义 Lip Gloss 基础色板，支持在 DSL 中通过变量（如 `@primary`）引用。

**下一步建议：**
我建议你立刻在源码中创建 `tui/` 文件夹。如果你希望我针对 **如何将 V8 脚本注入到组件的 `onEvent` 勾子中**（即：让 TUI 也能运行 JS 逻辑）提供 Golang 实现代码，请随时告知。
