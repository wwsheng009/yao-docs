# TUI 消息处理重构使用指南

## 概述

本文档介绍如何在 `yao/tui` 模块中使用重构后的新特性，包括消息处理机制、组件接口和状态管理。

## 1. Response 类型

Response 类型用于指示消息处理的结果：

```go
// Response 消息处理结果
type Response int

const (
    Ignored   Response = iota // 组件不感兴趣，消息应继续传递
    Handled                   // 组件已处理并截获，消息停止分发
    PassClick                 // 专门用于鼠标事件：处理了点击，但允许透传
)
```

## 2. ComponentInterface

新的组件接口定义了统一的消息处理方式：

```go
type ComponentInterface interface {
    Init() tea.Cmd
    // 返回处理后的组件、命令以及处理状态
    UpdateMsg(msg tea.Msg) (*Model, tea.Cmd, Response)
    View() string
}
```

### 实现示例

```go
type MyComponent struct {
    // 组件状态...
}

func (c *MyComponent) UpdateMsg(msg tea.Msg) (*Model, tea.Cmd, Response) {
    switch msg := msg.(type) {
    case tea.KeyMsg:
        if msg.Type == tea.KeyEnter {
            // 处理回车键，截获消息
            return nil, nil, Handled
        }
        // 对于其他按键，不处理
        return nil, nil, Ignored
    default:
        // 对于其他消息类型，不处理
        return nil, nil, Ignored
    }
}
```

## 3. TargetedMsg（定向消息）

TargetedMsg 用于向特定组件发送消息：

```go
type TargetedMsg struct {
    TargetID  string  // 目标组件ID
    InnerMsg  tea.Msg // 内部消息
}
```

### 使用示例

```go
// 创建一个定向消息
msg := tui.TargetedMsg{
    TargetID: "my-input-field",
    InnerMsg: tea.KeyMsg{Type: tea.KeyEnter},
}

// 发送到程序
program.Send(msg)
```

## 4. ActionMsg 和 EventBus

ActionMsg 用于组件间的通信：

```go
type ActionMsg struct {
    ID     string      // 触发者ID
    Action string      // 动作名称
    Data   interface{} // 携带数据
}
```

### EventBus 使用示例

```go
// 订阅事件
model.EventBus.Subscribe("USER_SELECTED", func(msg tui.ActionMsg) {
    userID := msg.Data.(string)
    fmt.Printf("Selected user: %s\n", userID)
})

// 发布事件
model.EventBus.Publish(tui.ActionMsg{
    ID:     "user-list-1",
    Action: "USER_SELECTED",
    Data:   "user123",
})
```

## 5. CRUD 状态机

CRUD 组件具有内部状态管理：

```go
type CRUDState int

const (
    StateList CRUDState = iota
    StateEditing
    StateCreating
    StateDeleting
    StateFiltering
)
```

### CRUD 组件实现

```go
type MyCRUDComponent struct {
    State  tui.CRUDState
    Table  tui.ComponentInterface
    Form   tui.ComponentInterface
    Data   interface{}
    EventBus *tui.EventBus
}

func (c *MyCRUDComponent) UpdateMsg(msg tea.Msg) (*Model, tea.Cmd, tui.Response) {
    switch c.State {
    case tui.StateEditing, tui.StateCreating:
        // 编辑/创建状态下，消息路由到表单组件
        if c.Form != nil {
            model, cmd, response := c.Form.UpdateMsg(msg)
            if actionMsg, ok := msg.(tui.ActionMsg); ok {
                switch actionMsg.Action {
                case "FORM_SUBMIT_SUCCESS":
                    c.State = tui.StateList
                    return model, cmd, tui.Handled
                case "FORM_CANCEL":
                    c.State = tui.StateList
                    return model, cmd, tui.Handled
                }
            }
            return model, cmd, response
        }
    case tui.StateList:
        // 列表状态下，消息路由到表格组件
        if c.Table != nil {
            model, cmd, response := c.Table.UpdateMsg(msg)
            if actionMsg, ok := msg.(tui.ActionMsg); ok {
                switch actionMsg.Action {
                case "ROW_SELECTED":
                    c.State = tui.StateEditing
                    return model, cmd, tui.Handled
                case "NEW_ITEM_REQUESTED":
                    c.State = tui.StateCreating
                    return model, cmd, tui.Handled
                }
            }
            return model, cmd, response
        }
    }

    return nil, nil, tui.Ignored
}
```

## 6. Bridge（外部消息桥接）

Bridge 用于从外部（如 JavaScript/V8 脚本）发送消息到 TUI：

```go
// 发送消息到 TUI
bridge.Send(tea.Msg(myCustomMessage))
```

## 7. 消息处理流程

重构后的消息处理遵循以下流程：

1. **Capture 阶段**：系统级消息拦截（如 Ctrl+C）
2. **Dispatch 阶段**：优先将消息发送给当前焦点组件
3. **Bubble 阶段**：执行全局通用逻辑

这种分层处理机制确保了消息的有序处理和冲突解决。

## 8. 最佳实践

1. **合理使用 Response**：根据组件是否处理了消息返回适当的 Response
2. **使用 TargetedMsg**：对于需要定向发送的消息，使用 TargetedMsg 确保正确路由
3. **利用 EventBus**：在组件间需要通信时，使用 EventBus 而不是直接引用
4. **状态管理**：对于复合组件，使用状态机管理不同的交互模式
5. **消息节流**：在处理高频消息时，利用 Bridge 的节流机制防止性能问题
