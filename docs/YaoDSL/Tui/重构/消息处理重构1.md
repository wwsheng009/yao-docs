在 Yao 项目的 `tui` 目录下构建基于 `charmbracelet/bubbletea` (tea) 的消息处理机制，参考 Windows 消息循环（Message Loop）是一个非常深刻的切入点。Windows 的核心思想是**消息分发（Dispatching）和递归处理（Recursive Handling）**，这能完美解决全局消息与组件消息的冲突。

### 设计核心理念：基于职责链的消息冒泡与截获

在 Bubble Tea 中，消息（`tea.Msg`）是扁平流动的。为了实现优雅的重构，我们需要引入**“组件树导航”**和**“事件掩码（Event Masking）”**的概念。

---

### 1. 基础架构设计：`Component` 接口

首先，我们需要定义一个增强型的接口，允许组件显式声明是否“消费”了该消息。

```go
// tui/types.go 或 tui/interfaces.go

type Response int

const (
    Unchanged Response = iota // 消息未处理，继续传递
    Handled                   // 消息已处理，停止传递（截获）
    Broadcast                 // 消息已处理，但允许继续传递（全局通知）
)

type Component interface {
    Init() tea.Cmd
    // Update 返回 (Component, tea.Cmd, Response)
    // 通过 Response 告知父容器该消息的状态
    Update(msg tea.Msg) (Component, tea.Cmd, Response)
    View() string
    SetFocus(focus bool)
}

```

---

### 2. 消息处理机制：参考 Windows 消息分发

模仿 Windows 的 `WndProc`，消息处理应遵循以下逻辑：

1. **捕获阶段 (Capture):** 顶层模型（Main Model）优先检查是否为系统级全局消息（如 `Ctrl+C`、窗口缩放）。
2. **分发阶段 (Dispatch):** 如果不是全局拦截消息，则将消息发送给**当前获得焦点的组件**。
3. **冒泡阶段 (Bubbling):** 如果组件返回 `Unchanged`，消息回传给父级进行通用处理。

#### 实现示例：`MainModel` 的调度逻辑

```go
// tui/model.go

type MainModel struct {
    components map[string]Component
    activeKey  string
    width, height int
}

func (m MainModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
    var cmds []tea.Cmd

    // 1. 全局消息处理 (Global Hooks)
    switch msg := msg.(type) {
    case tea.KeyMsg:
        if msg.String() == "ctrl+c" {
            return m, tea.Quit
        }
    case tea.WindowSizeMsg:
        m.width, m.height = msg.Width, msg.Height
        // 窗口缩放通常是广播消息
        for k, c := range m.components {
            newC, cmd, _ := c.Update(msg)
            m.components[k] = newC
            cmds = append(cmds, cmd)
        }
        return m, tea.Batch(cmds...)
    }

    // 2. 路由消息给活跃组件 (Windows-like Dispatch)
    if activeComp, ok := m.components[m.activeKey]; ok {
        newC, cmd, res := activeComp.Update(msg)
        m.components[m.activeKey] = newC
        cmds = append(cmds, cmd)

        // 如果组件截获了消息，直接返回
        if res == Handled {
            return m, tea.Batch(cmds...)
        }
    }

    // 3. 后续处理 (若组件未处理或需要冒泡)
    // 可以在这里处理那些活跃组件不感兴趣的消息

    return m, tea.Batch(cmds...)
}

```

---

### 3. 状态处理机制：CURD 组件扩展

针对复杂的 CURD 组件，建议使用 **内建状态机** 和 **消息总线 (Message Bus)**。

#### 定义组件内部状态

```go
type CRUDState int
const (
    StateList CRUDState = iota
    StateEditing
    StateSaving
)

type CRUDComponent struct {
    state  CRUDState
    table  Component
    form   Component
    // ...
}

```

#### 优雅的跨组件通信 (Internal Messaging)

为了避免组件间强耦合，使用自定义 `Msg` 结构体：

```go
// tui/messages.go

// 统一的内部消息
type ActionMsg struct {
    ID     string      // 触发者ID
    Action string      // 如 "SAVE_SUCCESS", "ROW_SELECTED"
    Data   interface{} // 携带的数据
}

func (c *CRUDComponent) Update(msg tea.Msg) (Component, tea.Cmd, Response) {
    switch msg := msg.(type) {
    case ActionMsg:
        if msg.Action == "ROW_SELECTED" {
            c.state = StateEditing
            // 切换状态并不代表消费了消息，可能父组件也要记录日志
            return c, nil, Unchanged
        }
    }
    // ...
}

```

---

### 4. 解决全局与组件冲突的“最优工程实践”

1. **优先级映射表 (Priority Map):**
   在 `MainModel` 中维护一个消息优先级。系统级（`SystemMsg`） > 焦点组件级（`FocusedMsg`） > 背景监听级（`BackgroundMsg`）。
2. **焦点管理 (Focus Manager):**
   参考 Windows 的 `SetFocus`。只有处于 `Focus` 状态的组件才能接收 `tea.KeyMsg`。这从根本上解决了多个组件同时响应按键的问题。
3. **Namespace 消息隔离:**
   在 Yao 的 DSL 转换过程中，为每个组件分配一个唯一 ID。消息传递时，如果是 `ComponentMsg`，检查其 `TargetID`。

```go
type ComponentMsg struct {
    TargetID string
    InnerMsg tea.Msg
}

// 在分发时
case ComponentMsg:
    if msg.TargetID == m.id {
        return m.Update(msg.InnerMsg)
    }

```

### 5. 结合 V8 脚本的扩展性

在 Yao 项目中，你可能需要通过 JavaScript 触发 TUI 更新。你可以定义一个 `ExternalMsg`：

```go
// tui/jsapi.go

// 当 v8go 中的 JS 调用特定的 Go 函数时，发送此消息
type JSResponseMsg struct {
    CallbackID string
    Payload    string
}

// 在 tea 的 Update 中处理，这样 JS 的异步回调就能无缝进入 TUI 的状态流

```

### 总结重构建议

1. **引入 `Response` 枚举**：明确组件对消息的占用权。
2. **实现焦点切换逻辑**：确保 `tea.KeyMsg` 的唯一分发目标。
3. **消息包装**：对业务消息使用 `ActionMsg` 或 `ComponentMsg` 进行封装，避免污染 Bubble Tea 的原生消息。
4. **分层处理**：`MainModel` 处理“布局和全局”，`Container` 处理“路由”，`Leaf Component` 处理“交互”。

这套方案不仅解决了目前的冲突，还为后续 CRUD 这种多状态切换的组件提供了清晰的边界。
