在 `yao/tui` 项目中，当前的实现（如 `tui/model.go` 和各组件）采用了 Bubble Tea 默认的扁平消息流。随着复杂组件（如 CRUD、Chat、Form）的增加，这种模式会导致 `Update` 函数臃肿，且难以处理“局部焦点”与“全局快捷键”的冲突。

参考 Windows 消息分发机制（WndProc）并结合 Bubble Tea 的函数式特性，我建议通过以下**五个步骤**进行重构：

### 步骤 1：定义带状态响应的消息接口

目前 `tea.Msg` 是 `interface{}`，无法表示“消息是否已被消费”。我们需要定义一个响应类型，让子组件告诉父容器消息的处理状态。

在 `tui/types.go` 中增加：

```go
// Response 消息处理结果
type Response int

const (
    Ignored   Response = iota // 组件不感兴趣，消息应继续传递
    Handled                   // 组件已处理并截获，消息停止分发
    PassClick                 // 专门用于鼠标事件：处理了点击，但允许透传
)

// Component 增强型组件接口
type Component interface {
    Init() tea.Cmd
    // 返回处理后的组件、命令以及处理状态
    UpdateMsg(msg tea.Msg) (Component, tea.Cmd, Response)
    View() string
}

```

### 2. 引入“焦点链”分发机制 (Windows WndProc 模拟)

Windows 消息的核心是分发给 `ActiveWindow`。在 TUI 中，我们需要一个 `FocusManager` 或在 `MainModel` 中维护焦点路径。

重构 `tui/model.go` 中的 `Update` 方法：

```go
func (m MainModel) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
    // 1. 系统级/全局消息拦截 (Pre-routing)
    // 优先级最高，类似于 Windows 的系统热键
    switch msg := msg.(type) {
    case tea.KeyMsg:
        if msg.String() == "ctrl+c" {
            return m, tea.Quit
        }
        // 如果是 Tab 切换焦点，由 MainModel 直接处理
        if msg.String() == "tab" {
            m.NextFocus()
            return m, nil
        }
    }

    // 2. 路由消息给活跃组件 (Targeted Dispatching)
    // 只有处于 Focus 状态的组件才会收到 KeyMsg
    if m.activeComp != nil {
        newComp, cmd, res := m.activeComp.UpdateMsg(msg)
        m.activeComp = newComp

        // 如果组件声明已截获消息，则不再进行后续处理
        if res == Handled {
            return m, cmd
        }
    }

    // 3. 冒泡/广播消息处理 (Bubbling/Broadcasting)
    // 比如 WindowSizeMsg 应该传递给所有可见组件
    if _, ok := msg.(tea.WindowSizeMsg); ok {
        var cmds []tea.Cmd
        // 遍历所有组件进行更新
        return m, tea.Batch(cmds...)
    }

    return m, nil
}

```

### 步骤 3：设计 CRUD 组件的内部消息路由

针对 CRUD 这种复合组件，重构其 `UpdateMsg`，使其内部具备“子消息循环”。

```go
// tui/components/crud.go

func (c *CRUDComponent) UpdateMsg(msg tea.Msg) (Component, tea.Cmd, Response) {
    // 内部状态机判断
    switch c.state {
    case StateEditing:
        // 消息定向发给 Form 组件
        newForm, cmd, res := c.form.UpdateMsg(msg)
        c.form = newForm
        return c, cmd, res

    case StateList:
        // 消息定向发给 Table 组件
        newTable, cmd, res := c.table.UpdateMsg(msg)
        c.table = newTable

        // 这里的关键：截获 Table 的特定动作并转化为 CRUD 状态切换
        if action, ok := msg.(ActionMsg); ok && action.Name == "row_click" {
             c.state = StateEditing
             return c, c.loadData(action.Data), Handled
        }
        return c, cmd, res
    }
    return c, nil, Ignored
}

```

### 步骤 4：引入 Namespace 消息隔离 (解决冲突)

为了防止两个不同实例的消息混淆，为每个组件分配一个 `UID`。

```go
// tui/messages.go
type TargetedMsg struct {
    TargetID string
    RealMsg  tea.Msg
}

// 发送消息时：
func SaveData(id string) tea.Cmd {
    return func() tea.Msg {
        return TargetedMsg{TargetID: id, RealMsg: SaveSuccessMsg{}}
    }
}

// 组件处理时：
func (c *BaseComponent) UpdateMsg(msg tea.Msg) (Component, tea.Cmd, Response) {
    if tMsg, ok := msg.(TargetedMsg); ok {
        if tMsg.TargetID != c.id {
            return c, nil, Ignored // 不是发给我的，忽略
        }
        msg = tMsg.RealMsg // 解包继续处理
    }
    // ... 原有逻辑
}

```

### 步骤 5：V8 脚本异步消息对接

Yao 的核心是 JS 执行。当 JS 异步任务完成时，需要通过一条“外部通道”注入 `tea.Msg`。

重构 `tui/jsapi.go`：

1. **定义外部事件桥接器**：
   在 `MainModel` 中包含一个 `chan tea.Msg`。
2. **JS 回调**：
   当 `v8go` 中的脚本调用 `Process("scripts.tui.Update", data)` 时，后台进程将结果封装成 `ActionMsg` 放入通道。
3. **使用 `tea.Every` 或监听器模式**：
   在 `Init()` 中启动一个订阅者，将通道中的消息持续转化为 `tea.Msg` 流。

### 重构后的工程目录结构建议

```text
tui/
├── components/
│   ├── table.go    // 实现 Component 接口，处理本地 Input
│   ├── form.go     // 处理验证状态
│   └── crud/       // 复合组件
│       ├── model.go // 内部状态机 (List/Edit/Filter)
│       └── msg.go   // CRUD 特有内部消息定义
├── model.go        // MainModel: 充当 Windows 消息调度中心 (Dispatcher)
├── types.go        // 定义 Response, Component 接口
└── manager.go      // 焦点管理逻辑 (FocusManager)

```

### 解决冲突的核心总结

- **按需消费**：组件显式返回 `Handled`。
- **定向路由**：优先将消息发送给 `activeComp`。
- **全局拦截**：`MainModel` 优先过滤系统按键（如 `Esc`, `Ctrl+C`）。
- **数据隔离**：使用 `TargetID` 包装业务消息，确保实例间互不干扰。

这套方案不仅解决了目前的冲突，还利用了 Yao 现有的 `Process` 机制，让 TUI 能够无缝响应来自服务器端或 JS 脚本的状态变化。
