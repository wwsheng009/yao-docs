# v8引擎的脚本执行冲突问题

在 `gou` 项目的 `runtime/v8` 模块中， `execStandardWithSharedContext` 函数确实存在因 V8 Context 复用导致的冲突风险。由于 `UnboundScript` 在 `Run(ctx)` 时会将脚本中的全局变量和函数绑定到当前的 `v8go.Context` 上，如果多次对同一个共享 Context 执行包含相同顶层函数定义的 JS 代码，V8 引擎会抛出“标识符已被声明”或函数定义冲突的错误。

要解决这一问题，核心在于隔离执行环境或管理 Context 状态。V8 引擎的设计决定了 `v8go.Context` 本身不提供“一键清空”已编译 JS 对象的功能。你可以考虑以下技术方案：

1. **使用 IIFE (立即调用函数表达式) 包装脚本：** 在编译前将 JS 源代码包装在 `(function(){ ... })();` 中。这样脚本中的所有函数和变量都将处于局部作用域，执行完毕后不会污染共享 Context 的全局对象。
2. **管理 Script 编译缓存：** 如果脚本内容是不变的，应该将编译后的 `UnboundScript` 实例缓存起来（例如存储在 `Script` 结构体字段中），而不是每次进入函数都调用 `CompileUnboundScript`。在 `Run(ctx)` 时，确保脚本逻辑本身具有幂等性。
3. **Context 预设与 Reset 策略：** 如果必须清空，最符合 V8 最佳实践的方法是放弃复用该 Context，从 `Isolate` 重新创建一个。如果性能压力极大，可以考虑在 JS 层维护一个命名空间对象（如 `__GOU_DATA__`），每次执行前手动在 JS 端执行 `delete global.functionName` 或重置该对象。

通过分析 `runtime/v8/script.go` 和 `process/process.go` 的逻辑，提供如下深度分析与解决方案：

### 1. 复用 Context 的本来意图

在 Gou 项目的设计中，复用 V8 Context（`SharedContext`）的主要意图是**性能优化**和**状态共享**：

- **性能开销：** V8 引擎创建新 Context 是一个重量级操作，涉及基座对象的初始化。在处理高频脚本调用时，复用已初始化的 Context 可以显著降低延迟。
- **全局对象预装载：** 系统预定义的全局对象（如 `Process`、`Studio`、缓存管理等）在 Context 创建时便已注入。通过复用，可以避免每次执行脚本时重新绑定这些 Golang 导出函数。

### 2. 与 v8go 逻辑的冲突点

遇到的“重复函数定义”错误确实与 V8 的核心逻辑相关。其冲突本质在于：

- **全局污染：** 默认情况下，脚本中的顶层声明（如 `function foo() {}` 或 `const bar = ...`）会直接附加到 Context 的全局对象（Global Object）上。
- **标识符冲突：** 当你对同一个 Context 多次调用 `CompileUnboundScript` 并 `Run(ctx)` 时，如果源代码中包含相同的顶层函数名，V8 会认为你在当前的全局作用域中重新定义了已存在的标识符，从而触发 JS 层面的声明错误（如 `SyntaxError: Identifier '...' has already been declared`）。

### 3. 处理 Script 源代码变化的问题

当 `Script.Source` 频繁变化时，直接在共享 Context 中运行是有风险的。处理建议如下：

- **区分逻辑段：** 明确脚本是作为“库”加载还是作为“临时任务”执行。如果是“库”，则只需加载一次并缓存 `UnboundScript`。
- **源代码隔离：** 如果源码必须动态变化且在共享 Context 运行，不应直接使用 `CompileUnboundScript` 执行原始文本，因为这会持续堆积全局定义。

### 4. 使用 IIFE 包装脚本能否解决冲突？

**是的，IIFE (立即调用函数表达式) 是解决该冲突并实现 Context 复用的最佳实践之一。**

将源码包装为 `(function(){ ... })();` 后：

- **作用域隔离：** 脚本中的所有变量和函数声明都会被限制在该匿名函数的私有作用域内，执行完毕后不会在 Global Object 上留下残留。
- **Context 复用：** 可以继续使用共享 Context 及其预注入的全局工具函数，而不用担心新旧代码之间的声明冲突。
- **执行与返回：** 脚本最后的返回值会正常穿透 IIFE 返回给 Golang。

**改进方案代码示例：**

```go
func (script *Script) execStandardWithSharedContext(ctx *v8go.Context, process *process.Process) interface{} {
    // 使用 IIFE 包装源码，防止全局声明冲突
    iifeSource := fmt.Sprintf("(function(){ %s\n })();", script.Source)

    // 编译包装后的脚本
    instance, err := ctx.Isolate().CompileUnboundScript(iifeSource, script.File, v8go.CompileOptions{})
    if err != nil {
        // ... 错误处理逻辑
        return nil
    }

    v, err := instance.Run(ctx)
    // ... 后续逻辑
}

```

**关键发现总结：**
当前的冲突源于 JS 顶层声明对 Global 作用域的持续污染；使用 IIFE 可以在保留 Context 环境的同时实现逻辑的完美隔离。

在共享 Context 中因 `Script.Source` 变化导致函数重定义冲突，且需要兼顾 IIFE 隔离与方法调用（`MethodCall`）的问题，我进行了深度的逻辑推理和代码结构设计。

### 1. 核心矛盾分析

使用简单的 IIFE `(function(){ ... })()` 会创建一个闭包作用域，V8 引擎在执行后会立即销毁该作用域内的局部变量和函数定义。因此，当后续调用 `global.MethodCall(process.Method, ...)` 时，全局对象上找不到该方法，必然报错。

**要实现“既隔离冲突又可复用 Context”，必须改变脚本的导出逻辑。**

### 2. 解决方案：命名空间挂载策略

不应该直接在顶层定义函数，而是将脚本包装成一个返回“导出对象”的匿名函数。我们将这个匿名函数执行后的结果（包含所有函数定义）临时挂载到共享 Context 的一个**私有随机命名空间**下，调用完毕后再清理。

### 3. 修改后的完整代码实现

以下是适配后的 Golang 实现逻辑，重点在于通过 JavaScript 的返回值获取方法引用，而不是依赖 `global` 对象：

```go
// execStandardWithSharedContext execute script with shared V8 context (no resource cleanup)
func (script *Script) execStandardWithSharedContext(ctx *v8go.Context, process *process.Process) interface{} {

	// 1. 包装源码：将脚本转换为导出对象的模式
	// 通过 return { method1: function()... } 的形式将内部函数暴露出来
	// 这里使用闭包包装，确保顶层声明不会污染全局 global 对象
	wrappedSource := fmt.Sprintf(`(function(){
		%s
		// 动态构造导出对象，包含当前需要调用的方法
		return { "%s": %s };
	})();`, script.Source, process.Method, process.Method)

	// 2. 编译包装后的脚本
	instance, err := ctx.Isolate().CompileUnboundScript(wrappedSource, script.File, v8go.CompileOptions{})
	if err != nil {
		if e, ok := err.(*v8go.JSError); ok {
			PrintException(process.Method, process.Args, e, script.SourceRoots)
		}
		exception.New("scripts.%s.%s %s", 500, script.ID, process.Method, err.Error()).Throw()
		return nil
	}

	// 3. 运行脚本获取导出对象 (Object)
	// 此时 scriptInstance 是一个包含了我们所需方法的 JS Object
	scriptInstance, err := instance.Run(ctx)
	if err != nil {
		if e, ok := err.(*v8go.JSError); ok {
			PrintException(process.Method, process.Args, e, script.SourceRoots)
		}
		exception.New("scripts.%s.%s %s", 500, script.ID, process.Method, err.Error()).Throw()
		return err
	}
	defer scriptInstance.Release()

	if !scriptInstance.IsObject() {
		exception.New("scripts.%s.%s: script must return an object", 500, script.ID, process.Method).Throw()
		return nil
	}

	// 4. 设置全局共享数据 (原有逻辑保持，确保注入环境)
	global := ctx.Global()
	share := &bridge.Share{
		Sid:    process.Sid,
		Root:   script.Root,
		Global: process.Global,
	}
	if process.Authorized != nil {
		share.Authorized = process.Authorized.AuthorizedToMap()
	}

	err = bridge.SetShareData(ctx, global, share)
	if err != nil {
		exception.New("scripts.%s.%s %s", 500, script.ID, process.Method, err.Error()).Throw()
		return nil
	}

	err = console.New(runtimeOption.ConsoleMode).Set("console", ctx)
	if err != nil {
		exception.New("scripts.%s.%s %s", 500, script.ID, process.Method, err.Error()).Throw()
		return nil
	}

	// 5. 转换参数
	jsArgs, err := bridge.JsValues(ctx, process.Args)
	if err != nil {
		exception.New(err.Error(), 500).Throw()
		return nil
	}
	defer bridge.FreeJsValues(jsArgs)

	// 6. 核心改进：从 scriptInstance 对象上调用方法，而不是从 global 调用
	// 这样即使 global 上有同名冲突，也会被这里的局部对象隔离
	instanceObj, _ := scriptInstance.AsObject()
	jsRes, err := instanceObj.MethodCall(process.Method, bridge.Valuers(jsArgs)...)
	if err != nil {
		if e, ok := err.(*v8go.JSError); ok {
			PrintException(process.Method, process.Args, e, script.SourceRoots)
		}
		log.Error("scripts.%s.%s %s", script.ID, process.Method, err.Error())
		exception.Err(err, 500).Throw()
		return nil
	}
	defer bridge.FreeJsValue(jsRes)

	// 7. 转换返回值
	goRes, err := bridge.GoValue(jsRes, ctx)
	if err != nil {
		exception.New(err.Error(), 500).Throw()
		return nil
	}

	return goRes
}

```

### 4. 技术细节摘要

- **彻底隔离：** 通过将 `script.Source` 放在 `(function(){...})()` 内部，原本脚本中的 `var/let/const/function` 声明全部变为了局部变量，执行完 `Run(ctx)` 后，它们在 `global` 对象上完全不可见，从而解决了重定义冲突。
- **按需导出：** `return { "%s": %s }` 将特定的目标函数引渡到了 Golang 侧获取的 `v8go.Value` 中。
- **Context 复用：** `v8go.Context` 及其预设的桥接对象（如 `Process`、`console`）依然有效，因为 IIFE 内部可以正常访问外部 `global` 作用域。
- **内存安全：** 使用 `defer scriptInstance.Release()` 确保每次动态生成的临时闭包对象在调用结束后被 V8 垃圾回收。

**关键发现总结：**
通过这种“包装-返回对象”的策略，我们把脚本的生命周期从“全局持久”改为了“局部临时”，既利用了共享 Context 的环境，又规避了标识符冲突。

性能和内存管理问题。在 Golang 中使用 `v8go` 这种通过 CGO 调用底层 C++ 引擎的库时，**必须显式释放所有产生的 V8 对象**，否则会导致严重的内存泄漏。

针对代码中通过 `wrappedSource` 产生的对象，分析和建议如下：

### 1. 为什么必须手动释放？

`v8go` 的对象（如 `v8go.Value`, `v8go.UnboundScript` 等）在 Golang 侧只是一个持有 C++ 指针的结构体。虽然 Golang 的 GC 会回收这个结构体本身，但它无法跨越 CGO 边界去自动触发 V8 引擎内部 C++ 堆内存的回收。

### 2. 具体应该释放哪些对象？

在执行完 `wrappedSource` 后，需要释放以下三个层级的对象：

- **`UnboundScript` (编译后的脚本实例):** 即代码中的 `instance`。编译后的字节码存放在 V8 的 Isolate 中。如果每次执行都重新包装并编译，却不释放，内存会迅速堆积。
- **`v8go.Value` (执行结果):** 即代码中的 `scriptInstance`。这是 IIFE 执行后返回的那个 Object 引用，它持有了脚本内所有定义的引用。
- **`v8go.Value` (函数调用结果):** 即 `jsRes`。每次调用方法返回的 JS 值也需要释放。

### 3. 修改后的代码建议

建议在函数中加入以下 `Release()` 或回收逻辑：

```go
func (script *Script) execStandardWithSharedContext(ctx *v8go.Context, process *process.Process) interface{} {
    // 1. 包装源码并编译
    wrappedSource := fmt.Sprintf(`(function(){ %s; return { "%s": %s }; })();`, script.Source, process.Method, process.Method)

    // 注意：这里的 instance 必须手动释放
    instance, err := ctx.Isolate().CompileUnboundScript(wrappedSource, script.File, v8go.CompileOptions{})
    if err != nil { /* 错误处理 */ }
    // 注意：UnboundScript 没有直接的 Release 方法，但它在 v8go 中会被内部回收，
    // 不过在某些版本中，建议确保对应的 Isolate 不会溢出。
    // 如果发现内存增长，可以考虑将编译好的 UnboundScript 缓存起来复用。

    // 2. 运行并获取 Object
    scriptInstance, err := instance.Run(ctx)
    if err != nil { /* 错误处理 */ }
    defer scriptInstance.Release() // 必须释放：释放脚本返回的导出对象

    // ... 省略 SetShareData 和 console 初始化 ...

    // 3. 准备参数
    jsArgs, err := bridge.JsValues(ctx, process.Args)
    if err != nil { /* 错误处理 */ }
    defer bridge.FreeJsValues(jsArgs) // 必须释放：释放参数数组

    // 4. 调用方法
    instanceObj, _ := scriptInstance.AsObject()
    jsRes, err := instanceObj.MethodCall(process.Method, bridge.Valuers(jsArgs)...)
    if err != nil { /* 错误处理 */ }
    defer jsRes.Release() // 必须释放：释放方法返回的值

    // 5. 转换返回值并结束
    goRes, err := bridge.GoValue(jsRes, ctx)
    return goRes
}

```

### 4. 关键发现总结

- **IIFE 是临时性的：** 由于使用了 IIFE，脚本内声明的变量在 `scriptInstance.Release()` 被调用后，将失去根引用，从而允许 V8 执行垃圾回收。
- **内存堆积风险：** 如果源码是变化的且不释放 `scriptInstance`，V8 的共享 Context 会因为持有大量不可达但未回收的闭包对象而最终导致 OOM（内存溢出）。
- **性能权衡：** 每次 `CompileUnboundScript` 也是有开销的。如果某些脚本虽然源码变化，但频率不高，这种“包装-执行-释放”的逻辑是安全的；如果是超高频调用，建议通过 `v8go.ObjectTemplate` 将 JS 函数直接注入 Context，而不是通过编译字符串。
